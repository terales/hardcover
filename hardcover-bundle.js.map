{"version":3,"sources":["webpack:///webpack/bootstrap 5bf4336ae7667a39c4d2","webpack:///../~/twgl.js/dist/3.x/twgl-full.js","webpack:///../~/twgl.js/dist/3.x/twgl.js","webpack:///./node.js","webpack:///./_render.js","webpack:///./coordinatesGrid.js","webpack:///./hardcoverNode.js","webpack:///../~/webgl-fundamentals/webgl/resources/webgl-lessons-ui.js","webpack:///./shaderFragment.glsl","webpack:///./shaderVertex.glsl","webpack:///./_entry.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oCAAoC;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA,iEAAiE;;AAEjE;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,kBAAkB,iCAAiC;AACnD;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,wCAAwC;AACxC;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,+BAA+B;AAC7C,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,IAAI;;AAEJ;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;;AAEA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,wCAAwC;AACtD,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN,yBAAyB;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,QAAQ;AACzB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,YAAY;AAC7B,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,8BAA8B;AAC/C,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B,+FAA+F,gDAAgD;AAC/I,iBAAiB,OAAO;AACxB,iBAAiB,QAAQ;AACzB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA,sBAAsB,6CAA6C;AACnE;AACA;AACA;AACA,gBAAgB,wDAAwD;AACxE;AACA;;AAEA;AACA;AACA,qEAAqE,qCAAqC;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gCAAgC;AACxE;AACA;AACA,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oEAAoE;AAC5F,wBAAwB,oEAAoE;AAC5F,wBAAwB,oEAAoE;AAC5F,wBAAwB,kGAAkG;AAC1H,wBAAwB,oEAAoE;AAC5F;AACA;AACA;AACA;AACA;AACA,wBAAwB,mFAAmF;AAC3G,wBAAwB,mFAAmF;AAC3G,wBAAwB,mFAAmF;AAC3G,wBAAwB,mFAAmF;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,mBAAmB;AACjC,eAAe,wCAAwC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,WAAW;AACzB;AACA,cAAc,UAAU;AACxB;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA,oDAAoD;AACpD,+FAA+F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC,6CAA6C;AAC7C,qCAAqC;AACrC,8CAA8C;AAC9C,mCAAmC;AACnC,4CAA4C;AAC5C,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,YAAY;AAC7B,iBAAiB,wCAAwC;AACzD;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,0CAA0C;AACvE,OAAO,iCAAiC;AACxC;AACA;AACA;AACA;AACA,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yCAAyC;AACpE,2BAA2B,yCAAyC;AACpE,2BAA2B,yCAAyC;AACpE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAA+C;AAC1E,2BAA2B,+CAA+C;AAC1E,0BAA0B,+CAA+C;AACzE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,mBAAmB;AACjC,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,mBAAmB;AACjC,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;;AAEA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,4BAA4B;AAC1C,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,qDAAqD,2CAA2C,6CAA6C;AAC3J,4CAA4C;AAC5C,cAAc,KAAK;AACnB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,qFAAqF,iCAAiC;AACtH;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,QAAQ;AACzB,iBAAiB,OAAO;AACxB,iBAAiB,wBAAwB,6CAA6C;AACtF,iBAAiB,uBAAuB,6CAA6C;AACrF,iBAAiB,4BAA4B,uDAAuD;AACpG,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kFAAkF;AAClF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,qBAAqB;AACrB,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,mBAAmB;AACnB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,4BAA4B;AAC5B,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,oBAAoB;AACpB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,0BAA0B;AAC1B,4BAA4B;AAC5B,0BAA0B;AAC1B,iCAAiC;AACjC,gCAAgC;AAChC,uCAAuC;AACvC,mCAAmC;AACnC,8BAA8B;AAC9B,8BAA8B;AAC9B,gCAAgC;AAChC,oCAAoC;AACpC,uCAAuC;AACvC,uCAAuC;AACvC,yCAAyC;AACzC,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,uBAAuB;AACvB,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,gCAAgC;AAChC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,wBAAwB;AACxB,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;;AAE9B;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,0BAA0B;AACxC,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,iBAAiB;AAClC,iBAAiB,uBAAuB;AACxC,iBAAiB,yEAAyE;AAC1F;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA,cAAc,oCAAoC;AAClD,cAAc,SAAS;AACvB,cAAc,0BAA0B;AACxC;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,cAAc,oCAAoC;AAClD,cAAc,SAAS;AACvB,cAAc,0BAA0B;AACxC;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,0BAA0B;AACxC,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,0BAA0B;AACxC;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,0BAA0B;AACxC;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,cAAc,aAAa;AAC3B,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B,gBAAgB,iBAAiB;AACjC,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,4EAA4E;AAC1F,cAAc,gEAAgE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,4CAA4C;AAC1G;AACA,cAAc,sBAAsB;AACpC,cAAc,4EAA4E;AAC1F,cAAc,gEAAgE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,wBAAwB,6CAA6C;AACnF,cAAc,gEAAgE;AAC9E,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,SAAS;AAC1B,8DAA8D,mCAAmC;AACjG,iBAAiB,KAAK;AACtB,iBAAiB,KAAK;AACtB,iBAAiB,KAAK;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB;AACjB,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,cAAc,aAAa;AAC3B,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;;AAEN;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,YAAY;AAC7B,iBAAiB,aAAa;AAC9B;AACA,iBAAiB,YAAY;AAC7B,iBAAiB,OAAO;AACxB,iBAAiB,iCAAiC;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,cAAc,aAAa;AAC3B,cAAc,6BAA6B;AAC3C,gBAAgB,oDAAoD;AACpE,cAAc,OAAO;AACrB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,cAAc,wBAAwB;AACtC,4BAA4B;AAC5B,cAAc,OAAO;AACrB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C;AACA,cAAc,uBAAuB;AACrC,cAAc,uDAAuD;AACrE,4BAA4B,oCAAoC;AAChE,yBAAyB,oDAAoD;AAC7E,cAAc,6BAA6B;AAC3C,WAAW,yCAAyC;AACpD,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA,cAAc,uBAAuB;AACrC,cAAc,uDAAuD;AACrE,4BAA4B,oCAAoC;AAChE,yBAAyB,oDAAoD;AAC7E,cAAc,6BAA6B;AAC3C,WAAW,yCAAyC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,6BAA6B,qDAAqD,yCAAyC;AACzI,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAoD;AAClE;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,0CAA0C;AAC/E;AACA,YAAY,gCAAgC;AAC5C,cAAc,aAAa;AAC3B,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA4D,0CAA0C;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAyC;AAClE,yBAAyB,yCAAyC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAyC;AAClE,yBAAyB,yCAAyC;AAClE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,cAAc,0BAA0B;AACxC,cAAc,wCAAwC;AACtD;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,oDAAoD,2CAA2C,oCAAoC,wCAAwC;AACzL,cAAc,qDAAqD,0CAA0C,6CAA6C;AAC1J,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,aAAa;AAC9B,iBAAiB,yBAAyB;AAC1C,iBAAiB,yBAAyB;AAC1C,iBAAiB,6BAA6B;AAC9C,iBAAiB,kDAAkD;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA,cAAc,aAAa;AAC3B,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,oCAAoC;AAClD,cAAc,SAAS;AACvB,cAAc,0BAA0B;AACxC;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;;AAEA,sBAAsB;;AAEtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA,gCAAgC;;AAEhC;AACA,wBAAwB;AACxB;;AAEA;AACA,uCAAuC;AACvC,sCAAsC;AACtC,sCAAsC;AACtC,qCAAqC;;AAErC;AACA;AACA;AACA;AACA,oBAAoB,iCAAiC;AACrD,sDAAsD;AACtD;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA,8BAA8B,sEAAsE,GAAG,wBAAwB;;AAE/H;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,iBAAiB;AAClC,iBAAiB,cAAc,wEAAwE,wCAAwC;AAC/I;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+BAA+B;AAC5C,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,gCAAgC;AAC9C;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+BAA+B;AAC5C,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,4BAA4B,qDAAqD,wCAAwC;AACvI,cAAc,gCAAgC,0DAA0D,wCAAwC;AAChJ,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,4BAA4B,uDAAuD,wCAAwC;AACzI;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;;AAEA,sBAAsB;AACtB;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB,gCAAgC;;AAEhC;AACA,wBAAwB;;AAExB;AACA,uCAAuC;AACvC,sCAAsC;AACtC,sCAAsC;AACtC,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,qBAAqB;AACrB,2BAA2B;AAC3B,eAAe;AACf,gBAAgB;AAChB,eAAe;AACf,uBAAuB;AACvB,cAAc;AACd,sBAAsB;AACtB,eAAe;AACf,uBAAuB;AACvB,gBAAgB;AAChB,wBAAwB;AACxB,2BAA2B;AAC3B,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,uBAAuB;AACvB,6BAA6B;AAC7B,iBAAiB;AACjB,kBAAkB;;AAElB;AACA,gBAAgB;AAChB,sBAAsB;AACtB,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB,iBAAiB;AACjB,mBAAmB;AACnB,kBAAkB;AAClB,mBAAmB;AACnB,kBAAkB;AAClB,iBAAiB;AACjB,uBAAuB;AACvB,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB,kBAAkB;AAClB,oBAAoB;AACpB,mBAAmB;AACnB,oBAAoB;AACpB,mBAAmB;AACnB,kBAAkB;AAClB,mBAAmB;AACnB,oBAAoB;AACpB,wBAAwB;AACxB,4BAA4B;AAC5B,qBAAqB;AACrB,oBAAoB;AACpB,oBAAoB;AACpB,oBAAoB;AACpB,mBAAmB;AACnB,qBAAqB;AACrB,oBAAoB;AACpB,qBAAqB;AACrB,oBAAoB;AACpB,mBAAmB;AACnB,0BAA0B;AAC1B,yBAAyB;AACzB,qBAAqB;AACrB,mBAAmB;AACnB,sBAAsB;AACtB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,oBAAoB;AACpB,wBAAwB;AACxB,sBAAsB;AACtB,qBAAqB;AACrB,qBAAqB;AACrB,sBAAsB;AACtB;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B,gCAAgC;AAChC,8BAA8B;AAC9B,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,2BAA2B;AACzC,eAAe,EAAE,wDAAwD,iCAAiC;AAC1G;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA,+CAA+C,yCAAyC;AACxF,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mHAAmH;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,uCAAuC,8BAA8B;AACrE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,2BAA2B;AACzC,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,2BAA2B;AACzC,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,oBAAoB;AAClC,cAAc,WAAW;AACzB,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,cAAc,sBAAsB;AACpC,cAAc,2CAA2C;AACzD,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd,YAAY;AACZ;AACA,cAAc,sBAAsB;AACpC,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,2BAA2B;AACzC;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,2BAA2B;AACzC,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,YAAY;AAC1B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,mBAAmB;AACjC;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,gCAAgC,KAAK;AAC1D;AACA;AACA;AACA;AACA,gBAAgB,oCAAoC;AACpD;AACA;;AAEA;AACA;AACA;AACA,cAAc,EAAE;AAChB,cAAc,aAAa;AAC3B,cAAc,uBAAuB;AACrC;AACA;;AAEA;AACA;AACA;AACA,cAAc,EAAE;AAChB,cAAc,8BAA8B,6DAA6D,iCAAiC;AAC1I,cAAc,wCAAwC;AACtD;AACA;;AAEA;AACA;AACA;AACA,cAAc,EAAE;AAChB,cAAc,aAAa;AAC3B,cAAc,mBAAmB;AACjC;AACA;;AAEA;AACA;AACA;AACA,cAAc,EAAE;AAChB,cAAc,aAAa;AAC3B,cAAc,mBAAmB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC,cAAc,iCAAiC;AAC/C;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,2BAA2B,iCAAiC;AAC5D,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,uBAAuB;AACrC,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,2BAA2B;AACzC,cAAc,iCAAiC;AAC/C,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,EAAE;AAChB,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAiD;AACvE;AACA,qBAAqB,2BAA2B;AAChD;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,2CAA2C;AACzD,cAAc,kCAAkC;AAChD,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,uBAAuB;AACxC;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,0CAA0C;AACvE,OAAO,iCAAiC;AACxC;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,kDAAkD;AAChE,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,0BAA0B;AACxC,cAAc,wCAAwC;AACtD,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA,cAAc,mDAAmD;AACjE,cAAc,uBAAuB;AACrC,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,oCAAoC;AACrE,gBAAgB,wBAAwB;AACxC;AACA;;AAEA;AACA;AACA,cAAc,YAAY;AAC1B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,KAAK;AACnB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,KAAK;AACnB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,OAAO;AACrB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,KAAK;AACnB,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,KAAK;AACnB;AACA,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,KAAK;AACnB;AACA,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,KAAK;AACnB;AACA,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,KAAK;AACnB;AACA,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD;AACA,cAAc,KAAK;AACnB;AACA,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2DAA2D;AAC3D;AACA,cAAc,oBAAoB;AAClC,cAAc,KAAK;AACnB;AACA,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,eAAe,KAAK;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iCAAiC,oCAAoC;AACrE,gBAAgB,wBAAwB;AACxC;AACA;;AAEA;AACA;AACA,cAAc,YAAY;AAC1B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gDAAgD;AAChD;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C;AAC9C;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6DAA6D;AAC7D;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0DAA0D;AAC1D;AACA,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,cAAc,oBAAoB;AAClC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,6BAA6B;AACvF,mBAAmB,6BAA6B,kBAAkB;AAClE,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6BAA6B;AAC1E,uCAAuC,6CAA6C;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,YAAY;AAC1B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,4BAA4B;AAC1C,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,4BAA4B;AAC1C,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,OAAO;AACrB,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,OAAO;AACrB,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,OAAO;AACrB,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,uCAAuC;AACrD,cAAc,OAAO;AACrB,eAAe,uCAAuC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,6BAA6B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,uBAAuB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,wBAAwB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,6BAA6B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,wBAAwB;AAC5C,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,yBAAyB;AAC7C,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,eAAe,uBAAuB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,eAAe,6BAA6B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,uBAAuB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,6BAA6B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mCAAmC;AACxD;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,eAAe,uBAAuB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,eAAe,6BAA6B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,eAAe;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,uBAAuB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,6BAA6B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,uBAAuB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,6BAA6B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,uBAAuB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,6BAA6B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,0BAA0B;AAClD;AACA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,uBAAuB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,6BAA6B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,iBAAiB;AACzC;;AAEA,sBAAsB,gBAAgB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,uCAAuC;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,qCAAqC;AACnD,cAAc,6CAA6C;AAC3D,eAAe,qCAAqC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,cAAc,iBAAiB;AAC/B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,iDAAiD;AAC/D,cAAc,OAAO;AACrB,eAAe,iDAAiD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,CAAC;AACD,C;;;;;;AC3lRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oCAAoC;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA,iEAAiE;;AAEjE;AACA;;AAEA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,kBAAkB,iCAAiC;AACnD;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,wCAAwC;AACxC;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,+BAA+B;AAC7C,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,IAAI;;AAEJ;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;;AAEA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,wCAAwC;AACtD,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN,yBAAyB;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,QAAQ;AACzB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,YAAY;AAC7B,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,8BAA8B;AAC/C,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B,+FAA+F,gDAAgD;AAC/I,iBAAiB,OAAO;AACxB,iBAAiB,QAAQ;AACzB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA,sBAAsB,6CAA6C;AACnE;AACA;AACA;AACA,gBAAgB,wDAAwD;AACxE;AACA;;AAEA;AACA;AACA,qEAAqE,qCAAqC;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gCAAgC;AACxE;AACA;AACA,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oEAAoE;AAC5F,wBAAwB,oEAAoE;AAC5F,wBAAwB,oEAAoE;AAC5F,wBAAwB,kGAAkG;AAC1H,wBAAwB,oEAAoE;AAC5F;AACA;AACA;AACA;AACA;AACA,wBAAwB,mFAAmF;AAC3G,wBAAwB,mFAAmF;AAC3G,wBAAwB,mFAAmF;AAC3G,wBAAwB,mFAAmF;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,mBAAmB;AACjC,eAAe,wCAAwC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,WAAW;AACzB;AACA,cAAc,UAAU;AACxB;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA,oDAAoD;AACpD,+FAA+F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC,6CAA6C;AAC7C,qCAAqC;AACrC,8CAA8C;AAC9C,mCAAmC;AACnC,4CAA4C;AAC5C,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,YAAY;AAC7B,iBAAiB,wCAAwC;AACzD;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,0CAA0C;AACvE,OAAO,iCAAiC;AACxC;AACA;AACA;AACA;AACA,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yCAAyC;AACpE,2BAA2B,yCAAyC;AACpE,2BAA2B,yCAAyC;AACpE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAA+C;AAC1E,2BAA2B,+CAA+C;AAC1E,0BAA0B,+CAA+C;AACzE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,mBAAmB;AACjC,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,mBAAmB;AACjC,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;;AAEA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,4BAA4B;AAC1C,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,qDAAqD,2CAA2C,6CAA6C;AAC3J,4CAA4C;AAC5C,cAAc,KAAK;AACnB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,qFAAqF,iCAAiC;AACtH;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,QAAQ;AACzB,iBAAiB,OAAO;AACxB,iBAAiB,wBAAwB,6CAA6C;AACtF,iBAAiB,uBAAuB,6CAA6C;AACrF,iBAAiB,4BAA4B,uDAAuD;AACpG,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kFAAkF;AAClF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,qBAAqB;AACrB,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,mBAAmB;AACnB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,4BAA4B;AAC5B,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,oBAAoB;AACpB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,0BAA0B;AAC1B,4BAA4B;AAC5B,0BAA0B;AAC1B,iCAAiC;AACjC,gCAAgC;AAChC,uCAAuC;AACvC,mCAAmC;AACnC,8BAA8B;AAC9B,8BAA8B;AAC9B,gCAAgC;AAChC,oCAAoC;AACpC,uCAAuC;AACvC,uCAAuC;AACvC,yCAAyC;AACzC,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,uBAAuB;AACvB,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,gCAAgC;AAChC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,wBAAwB;AACxB,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;;AAE9B;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,0BAA0B;AACxC,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,iBAAiB;AAClC,iBAAiB,uBAAuB;AACxC,iBAAiB,yEAAyE;AAC1F;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA,cAAc,oCAAoC;AAClD,cAAc,SAAS;AACvB,cAAc,0BAA0B;AACxC;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,cAAc,oCAAoC;AAClD,cAAc,SAAS;AACvB,cAAc,0BAA0B;AACxC;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,0BAA0B;AACxC,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,0BAA0B;AACxC;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,0BAA0B;AACxC;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,cAAc,aAAa;AAC3B,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B,gBAAgB,iBAAiB;AACjC,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,4EAA4E;AAC1F,cAAc,gEAAgE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,4CAA4C;AAC1G;AACA,cAAc,sBAAsB;AACpC,cAAc,4EAA4E;AAC1F,cAAc,gEAAgE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,wBAAwB,6CAA6C;AACnF,cAAc,gEAAgE;AAC9E,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,SAAS;AAC1B,8DAA8D,mCAAmC;AACjG,iBAAiB,KAAK;AACtB,iBAAiB,KAAK;AACtB,iBAAiB,KAAK;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB;AACjB,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,cAAc,aAAa;AAC3B,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;;AAEN;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,YAAY;AAC7B,iBAAiB,aAAa;AAC9B;AACA,iBAAiB,YAAY;AAC7B,iBAAiB,OAAO;AACxB,iBAAiB,iCAAiC;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,cAAc,aAAa;AAC3B,cAAc,6BAA6B;AAC3C,gBAAgB,oDAAoD;AACpE,cAAc,OAAO;AACrB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,cAAc,wBAAwB;AACtC,4BAA4B;AAC5B,cAAc,OAAO;AACrB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C;AACA,cAAc,uBAAuB;AACrC,cAAc,uDAAuD;AACrE,4BAA4B,oCAAoC;AAChE,yBAAyB,oDAAoD;AAC7E,cAAc,6BAA6B;AAC3C,WAAW,yCAAyC;AACpD,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA,cAAc,uBAAuB;AACrC,cAAc,uDAAuD;AACrE,4BAA4B,oCAAoC;AAChE,yBAAyB,oDAAoD;AAC7E,cAAc,6BAA6B;AAC3C,WAAW,yCAAyC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,6BAA6B,qDAAqD,yCAAyC;AACzI,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAoD;AAClE;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,0CAA0C;AAC/E;AACA,YAAY,gCAAgC;AAC5C,cAAc,aAAa;AAC3B,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA4D,0CAA0C;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAyC;AAClE,yBAAyB,yCAAyC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAyC;AAClE,yBAAyB,yCAAyC;AAClE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,cAAc,0BAA0B;AACxC,cAAc,wCAAwC;AACtD;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAoE;AAC3F,uBAAuB,oEAAoE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,oDAAoD,2CAA2C,oCAAoC,wCAAwC;AACzL,cAAc,qDAAqD,0CAA0C,6CAA6C;AAC1J,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,aAAa;AAC9B,iBAAiB,yBAAyB;AAC1C,iBAAiB,yBAAyB;AAC1C,iBAAiB,6BAA6B;AAC9C,iBAAiB,kDAAkD;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA,cAAc,aAAa;AAC3B,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,oCAAoC;AAClD,cAAc,SAAS;AACvB,cAAc,0BAA0B;AACxC;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;;AAEA,sBAAsB;;AAEtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA,gCAAgC;;AAEhC;AACA,wBAAwB;AACxB;;AAEA;AACA,uCAAuC;AACvC,sCAAsC;AACtC,sCAAsC;AACtC,qCAAqC;;AAErC;AACA;AACA;AACA;AACA,oBAAoB,iCAAiC;AACrD,sDAAsD;AACtD;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA,8BAA8B,sEAAsE,GAAG,wBAAwB;;AAE/H;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,iBAAiB;AAClC,iBAAiB,cAAc,wEAAwE,wCAAwC;AAC/I;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+BAA+B;AAC5C,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,gCAAgC;AAC9C;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+BAA+B;AAC5C,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,4BAA4B,qDAAqD,wCAAwC;AACvI,cAAc,gCAAgC,0DAA0D,wCAAwC;AAChJ,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,4BAA4B,uDAAuD,wCAAwC;AACzI;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;;AAEA,sBAAsB;AACtB;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB,gCAAgC;;AAEhC;AACA,wBAAwB;;AAExB;AACA,uCAAuC;AACvC,sCAAsC;AACtC,sCAAsC;AACtC,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,qBAAqB;AACrB,2BAA2B;AAC3B,eAAe;AACf,gBAAgB;AAChB,eAAe;AACf,uBAAuB;AACvB,cAAc;AACd,sBAAsB;AACtB,eAAe;AACf,uBAAuB;AACvB,gBAAgB;AAChB,wBAAwB;AACxB,2BAA2B;AAC3B,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,uBAAuB;AACvB,6BAA6B;AAC7B,iBAAiB;AACjB,kBAAkB;;AAElB;AACA,gBAAgB;AAChB,sBAAsB;AACtB,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB,iBAAiB;AACjB,mBAAmB;AACnB,kBAAkB;AAClB,mBAAmB;AACnB,kBAAkB;AAClB,iBAAiB;AACjB,uBAAuB;AACvB,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB,kBAAkB;AAClB,oBAAoB;AACpB,mBAAmB;AACnB,oBAAoB;AACpB,mBAAmB;AACnB,kBAAkB;AAClB,mBAAmB;AACnB,oBAAoB;AACpB,wBAAwB;AACxB,4BAA4B;AAC5B,qBAAqB;AACrB,oBAAoB;AACpB,oBAAoB;AACpB,oBAAoB;AACpB,mBAAmB;AACnB,qBAAqB;AACrB,oBAAoB;AACpB,qBAAqB;AACrB,oBAAoB;AACpB,mBAAmB;AACnB,0BAA0B;AAC1B,yBAAyB;AACzB,qBAAqB;AACrB,mBAAmB;AACnB,sBAAsB;AACtB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,oBAAoB;AACpB,wBAAwB;AACxB,sBAAsB;AACtB,qBAAqB;AACrB,qBAAqB;AACrB,sBAAsB;AACtB;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B,gCAAgC;AAChC,8BAA8B;AAC9B,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,2BAA2B;AACzC,eAAe,EAAE,wDAAwD,iCAAiC;AAC1G;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA,+CAA+C,yCAAyC;AACxF,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mHAAmH;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,uCAAuC,8BAA8B;AACrE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,2BAA2B;AACzC,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,2BAA2B;AACzC,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,oBAAoB;AAClC,cAAc,WAAW;AACzB,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,cAAc,sBAAsB;AACpC,cAAc,2CAA2C;AACzD,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd,YAAY;AACZ;AACA,cAAc,sBAAsB;AACpC,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,2BAA2B;AACzC;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,2BAA2B;AACzC,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,YAAY;AAC1B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,mBAAmB;AACjC;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,gCAAgC,KAAK;AAC1D;AACA;AACA;AACA;AACA,gBAAgB,oCAAoC;AACpD;AACA;;AAEA;AACA;AACA;AACA,cAAc,EAAE;AAChB,cAAc,aAAa;AAC3B,cAAc,uBAAuB;AACrC;AACA;;AAEA;AACA;AACA;AACA,cAAc,EAAE;AAChB,cAAc,8BAA8B,6DAA6D,iCAAiC;AAC1I,cAAc,wCAAwC;AACtD;AACA;;AAEA;AACA;AACA;AACA,cAAc,EAAE;AAChB,cAAc,aAAa;AAC3B,cAAc,mBAAmB;AACjC;AACA;;AAEA;AACA;AACA;AACA,cAAc,EAAE;AAChB,cAAc,aAAa;AAC3B,cAAc,mBAAmB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC,cAAc,iCAAiC;AAC/C;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,2BAA2B,iCAAiC;AAC5D,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,uBAAuB;AACrC,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,2BAA2B;AACzC,cAAc,iCAAiC;AAC/C,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,aAAa;AAC3B,cAAc,2BAA2B;AACzC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,EAAE;AAChB,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAiD;AACvE;AACA,qBAAqB,2BAA2B;AAChD;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,2CAA2C;AACzD,cAAc,kCAAkC;AAChD,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,OAAO;AACP;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,uBAAuB;AACxC;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,0CAA0C;AACvE,OAAO,iCAAiC;AACxC;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,kDAAkD;AAChE,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,0BAA0B;AACxC,cAAc,wCAAwC;AACtD,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA,cAAc,mDAAmD;AACjE,cAAc,uBAAuB;AACrC,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,CAAC;AACD,C;;;;;;;AC9qKA;AAAA;AAAA;AACa;;AAEb;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,C;;;;;;;;;;;;;ACjDA;AAAA;;AAEA;AACA;AACW;;AAEX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;;;;;;;;;;;ACnCA;AAAA;;AAEA;AACA;AACW;;AAEX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC,mIAA4D,0BAA0B;AACtF;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;AC/DA;AAAA;;AAEA;AACA;AACW;;AAEX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iFAA+B;AAC/B,kFAAgC;AAChC;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,4HAAqD,yBAAyB;AAC9E,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oBAAoB;AACpB;AACA;AACA;AACA;;;AAGA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,KAAK;AAAA;AACL,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,KAAK;AAC9C;AACA,8DAA8D,IAAI,SAAS,IAAI,WAAW,MAAM;AAChG;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;ACpPD,0CAA0C,6BAA6B,qBAAqB,8BAA8B,KAAK,K;;;;;;ACA/H,4CAA4C,8BAA8B,qBAAqB,0CAA0C,KAAK,K;;;;;;;;;;;;;;;;;;;;;ACA9I;AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA","file":"hardcover-bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5bf4336ae7667a39c4d2","/*!\n * @license twgl.js 3.3.0 Copyright (c) 2015, Gregg Tavares All Rights Reserved.\n * Available via the MIT license.\n * see: http://github.com/greggman/twgl.js for details\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"twgl\"] = factory();\n\telse\n\t\troot[\"twgl\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(10), __webpack_require__(11), __webpack_require__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = function (twgl, m4, v3, primitives) {\n\n\t  \"use strict\";\n\n\t  twgl.m4 = m4;\n\t  twgl.v3 = v3;\n\t  twgl.primitives = primitives;\n\t  return twgl;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(7), __webpack_require__(6), __webpack_require__(8), __webpack_require__(3), __webpack_require__(9), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (attributes, draw, framebuffers, programs, textures, typedArrays, vertexArrays, utils) {\n\t  \"use strict\";\n\n\t  /**\n\t   * The main TWGL module.\n\t   *\n\t   * For most use cases you shouldn't need anything outside this module.\n\t   * Exceptions between the stuff added to twgl-full (v3, m4, primitives)\n\t   *\n\t   * @module twgl\n\t   * @borrows module:twgl/attributes.setAttribInfoBufferFromArray as setAttribInfoBufferFromArray\n\t   * @borrows module:twgl/attributes.createBufferInfoFromArrays as createBufferInfoFromArrays\n\t   * @borrows module:twgl/attributes.createVertexArrayInfo as createVertexArrayInfo\n\t   * @borrows module:twgl/draw.drawBufferInfo as drawBufferInfo\n\t   * @borrows module:twgl/draw.drawObjectList as drawObjectList\n\t   * @borrows module:twgl/framebuffers.createFramebufferInfo as createFramebufferInfo\n\t   * @borrows module:twgl/framebuffers.resizeFramebufferInfo as resizeFramebufferInfo\n\t   * @borrows module:twgl/framebuffers.bindFramebufferInfo as bindFramebufferInfo\n\t   * @borrows module:twgl/programs.createProgramInfo as createProgramInfo\n\t   * @borrows module:twgl/programs.createUniformBlockInfo as createUniformBlockInfo\n\t   * @borrows module:twgl/programs.bindUniformBlock as bindUniformBlock\n\t   * @borrows module:twgl/programs.setUniformBlock as setUniformBlock\n\t   * @borrows module:twgl/programs.setBlockUniforms as setBlockUniforms\n\t   * @borrows module:twgl/programs.setUniforms as setUniforms\n\t   * @borrows module:twgl/programs.setBuffersAndAttributes as setBuffersAndAttributes\n\t   * @borrows module:twgl/textures.setTextureFromArray as setTextureFromArray\n\t   * @borrows module:twgl/textures.createTexture as createTexture\n\t   * @borrows module:twgl/textures.resizeTexture as resizeTexture\n\t   * @borrows module:twgl/textures.createTextures as createTextures\n\t   */\n\n\t  // make sure we don't see a global gl\n\n\t  var gl = undefined; // eslint-disable-line\n\t  var defaults = {\n\t    enableVertexArrayObjects: true\n\t  };\n\n\t  /**\n\t   * Various default settings for twgl.\n\t   *\n\t   * Note: You can call this any number of times. Example:\n\t   *\n\t   *     twgl.setDefaults({ textureColor: [1, 0, 0, 1] });\n\t   *     twgl.setDefaults({ attribPrefix: 'a_' });\n\t   *\n\t   * is equivalent to\n\t   *\n\t   *     twgl.setDefaults({\n\t   *       textureColor: [1, 0, 0, 1],\n\t   *       attribPrefix: 'a_',\n\t   *     });\n\t   *\n\t   * @typedef {Object} Defaults\n\t   * @property {string} attribPrefix The prefix to stick on attributes\n\t   *\n\t   *   When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`\n\t   *   as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.\n\t   *\n\t   *   In otherwords I'll create arrays of geometry like this\n\t   *\n\t   *       var arrays = {\n\t   *         position: ...\n\t   *         normal: ...\n\t   *         texcoord: ...\n\t   *       };\n\t   *\n\t   *   But need those mapped to attributes and my attributes start with `a_`.\n\t   *\n\t   *   Default: `\"\"`\n\t   *\n\t   * @property {number[]} textureColor Array of 4 values in the range 0 to 1\n\t   *\n\t   *   The default texture color is used when loading textures from\n\t   *   urls. Because the URL will be loaded async we'd like to be\n\t   *   able to use the texture immediately. By putting a 1x1 pixel\n\t   *   color in the texture we can start using the texture before\n\t   *   the URL has loaded.\n\t   *\n\t   *   Default: `[0.5, 0.75, 1, 1]`\n\t   *\n\t   * @property {string} crossOrigin\n\t   *\n\t   *   If not undefined sets the crossOrigin attribute on images\n\t   *   that twgl creates when downloading images for textures.\n\t   *\n\t   *   Also see {@link module:twgl.TextureOptions}.\n\t   *\n\t   * @property {bool} enableVertexArrayObjects\n\t   *\n\t   *   If true then in WebGL 1.0 will attempt to get the `OES_vertex_array_object` extension.\n\t   *   If successful it will copy create/bind/delete/isVertexArrayOES from the extension to\n\t   *   the WebGLRenderingContext removing the OES at the end which is the standard entry point\n\t   *   for WebGL 2.\n\t   *\n\t   *   Note: According to webglstats.com 90% of devices support `OES_vertex_array_object`.\n\t   *   If you just want to count on support I suggest using [this polyfill](https://github.com/KhronosGroup/WebGL/blob/master/sdk/demos/google/resources/OESVertexArrayObject.js)\n\t   *   or ignoring devices that don't support them.\n\t   *\n\t   *   Default: `true`\n\t   *\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Sets various defaults for twgl.\n\t   *\n\t   * In the interest of terseness which is kind of the point\n\t   * of twgl I've integrated a few of the older functions here\n\t   *\n\t   * @param {module:twgl.Defaults} newDefaults The default settings.\n\t   * @memberOf module:twgl\n\t   */\n\t  function setDefaults(newDefaults) {\n\t    utils.copyExistingProperties(newDefaults, defaults);\n\t    attributes.setDefaults_(newDefaults); // eslint-disable-line\n\t    textures.setDefaults_(newDefaults); // eslint-disable-line\n\t  }\n\n\t  /**\n\t   * Adds Vertex Array Objects to WebGL 1 GL contexts if available\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   */\n\t  function addVertexArrayObjectSupport(gl) {\n\t    if (!gl || !defaults.enableVertexArrayObjects) {\n\t      return;\n\t    }\n\t    if (utils.isWebGL1(gl)) {\n\t      var ext = gl.getExtension(\"OES_vertex_array_object\");\n\t      if (ext) {\n\t        gl.createVertexArray = function () {\n\t          return ext.createVertexArrayOES();\n\t        };\n\t        gl.deleteVertexArray = function (v) {\n\t          ext.deleteVertexArrayOES(v);\n\t        };\n\t        gl.isVertexArray = function (v) {\n\t          return ext.isVertexArrayOES(v);\n\t        };\n\t        gl.bindVertexArray = function (v) {\n\t          ext.bindVertexArrayOES(v);\n\t        };\n\t        gl.VERTEX_ARRAY_BINDING = ext.VERTEX_ARRAY_BINDING_OES;\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * Creates a webgl context.\n\t   * @param {HTMLCanvasElement} canvas The canvas tag to get\n\t   *     context from. If one is not passed in one will be\n\t   *     created.\n\t   * @return {WebGLRenderingContext} The created context.\n\t   */\n\t  function create3DContext(canvas, opt_attribs) {\n\t    var names = [\"webgl\", \"experimental-webgl\"];\n\t    var context = null;\n\t    for (var ii = 0; ii < names.length; ++ii) {\n\t      context = canvas.getContext(names[ii], opt_attribs);\n\t      if (context) {\n\t        break;\n\t      }\n\t    }\n\t    return context;\n\t  }\n\n\t  /**\n\t   * Gets a WebGL context.\n\t   * @param {HTMLCanvasElement} canvas a canvas element.\n\t   * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes\n\t   * @memberOf module:twgl\n\t   */\n\t  function getWebGLContext(canvas, opt_attribs) {\n\t    var gl = create3DContext(canvas, opt_attribs);\n\t    addVertexArrayObjectSupport(gl);\n\t    return gl;\n\t  }\n\n\t  /**\n\t   * Creates a webgl context.\n\t   *\n\t   * Will return a WebGL2 context if possible.\n\t   *\n\t   * You can check if it's WebGL2 with\n\t   *\n\t   *     twgl.isWebGL2(gl);\n\t   *\n\t   * @param {HTMLCanvasElement} canvas The canvas tag to get\n\t   *     context from. If one is not passed in one will be\n\t   *     created.\n\t   * @return {WebGLRenderingContext} The created context.\n\t   */\n\t  function createContext(canvas, opt_attribs) {\n\t    var names = [\"webgl2\", \"webgl\", \"experimental-webgl\"];\n\t    var context = null;\n\t    for (var ii = 0; ii < names.length; ++ii) {\n\t      context = canvas.getContext(names[ii], opt_attribs);\n\t      if (context) {\n\t        break;\n\t      }\n\t    }\n\t    return context;\n\t  }\n\n\t  /**\n\t   * Gets a WebGL context.  Will create a WebGL2 context if possible.\n\t   *\n\t   * You can check if it's WebGL2 with\n\t   *\n\t   *    function isWebGL2(gl) {\n\t   *      return gl.getParameter(gl.VERSION).indexOf(\"WebGL 2.0 \") == 0;\n\t   *    }\n\t   *\n\t   * @param {HTMLCanvasElement} canvas a canvas element.\n\t   * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes\n\t   * @return {WebGLRenderingContext} The created context.\n\t   * @memberOf module:twgl\n\t   */\n\t  function getContext(canvas, opt_attribs) {\n\t    var gl = createContext(canvas, opt_attribs);\n\t    addVertexArrayObjectSupport(gl);\n\t    return gl;\n\t  }\n\n\t  /**\n\t   * Resize a canvas to match the size it's displayed.\n\t   * @param {HTMLCanvasElement} canvas The canvas to resize.\n\t   * @param {number} [multiplier] So you can pass in `window.devicePixelRatio` if you want to.\n\t   * @return {boolean} true if the canvas was resized.\n\t   * @memberOf module:twgl\n\t   */\n\t  function resizeCanvasToDisplaySize(canvas, multiplier) {\n\t    multiplier = multiplier || 1;\n\t    multiplier = Math.max(1, multiplier);\n\t    var width = canvas.clientWidth * multiplier | 0;\n\t    var height = canvas.clientHeight * multiplier | 0;\n\t    if (canvas.width !== width || canvas.height !== height) {\n\t      canvas.width = width;\n\t      canvas.height = height;\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  var api = {\n\t    \"getContext\": getContext,\n\t    \"getWebGLContext\": getWebGLContext,\n\t    \"isWebGL1\": utils.isWebGL1,\n\t    \"isWebGL2\": utils.isWebGL2,\n\t    \"resizeCanvasToDisplaySize\": resizeCanvasToDisplaySize,\n\t    \"setDefaults\": setDefaults\n\t  };\n\n\t  function notPrivate(name) {\n\t    return name[name.length - 1] !== '_';\n\t  }\n\n\t  function copyPublicProperties(src, dst) {\n\t    Object.keys(src).filter(notPrivate).forEach(function (key) {\n\t      dst[key] = src[key];\n\t    });\n\t    return dst;\n\t  }\n\n\t  var apis = {\n\t    attributes: attributes,\n\t    draw: draw,\n\t    framebuffers: framebuffers,\n\t    programs: programs,\n\t    textures: textures,\n\t    typedArrays: typedArrays,\n\t    vertexArrays: vertexArrays\n\t  };\n\t  Object.keys(apis).forEach(function (name) {\n\t    var srcApi = apis[name];\n\t    copyPublicProperties(srcApi, api);\n\t    api[name] = copyPublicProperties(srcApi, {});\n\t  });\n\n\t  return api;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (typedArrays, utils) {\n\t  \"use strict\";\n\n\t  /**\n\t   * Low level attribute and buffer related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.attributes` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/attributes\n\t   */\n\n\t  // make sure we don't see a global gl\n\n\t  var gl = undefined; // eslint-disable-line\n\t  var defaults = {\n\t    attribPrefix: \"\"\n\t  };\n\n\t  /**\n\t   * Sets the default attrib prefix\n\t   *\n\t   * When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`\n\t   * as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.\n\t   *\n\t   * In otherwords I'll create arrays of geometry like this\n\t   *\n\t   *     var arrays = {\n\t   *       position: ...\n\t   *       normal: ...\n\t   *       texcoord: ...\n\t   *     };\n\t   *\n\t   * But need those mapped to attributes and my attributes start with `a_`.\n\t   *\n\t   * @deprecated see {@link module:twgl.setDefaults}\n\t   * @param {string} prefix prefix for attribs\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function setAttributePrefix(prefix) {\n\t    defaults.attribPrefix = prefix;\n\t  }\n\n\t  function setDefaults(newDefaults) {\n\t    utils.copyExistingProperties(newDefaults, defaults);\n\t  }\n\n\t  function setBufferFromTypedArray(gl, type, buffer, array, drawType) {\n\t    gl.bindBuffer(type, buffer);\n\t    gl.bufferData(type, array, drawType || gl.STATIC_DRAW);\n\t  }\n\n\t  /**\n\t   * Given typed array creates a WebGLBuffer and copies the typed array\n\t   * into it.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {ArrayBuffer|ArrayBufferView|WebGLBuffer} typedArray the typed array. Note: If a WebGLBuffer is passed in it will just be returned. No action will be taken\n\t   * @param {number} [type] the GL bind type for the buffer. Default = `gl.ARRAY_BUFFER`.\n\t   * @param {number} [drawType] the GL draw type for the buffer. Default = 'gl.STATIC_DRAW`.\n\t   * @return {WebGLBuffer} the created WebGLBuffer\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBufferFromTypedArray(gl, typedArray, type, drawType) {\n\t    if (typedArray instanceof WebGLBuffer) {\n\t      return typedArray;\n\t    }\n\t    type = type || gl.ARRAY_BUFFER;\n\t    var buffer = gl.createBuffer();\n\t    setBufferFromTypedArray(gl, type, buffer, typedArray, drawType);\n\t    return buffer;\n\t  }\n\n\t  function isIndices(name) {\n\t    return name === \"indices\";\n\t  }\n\n\t  // This is really just a guess. Though I can't really imagine using\n\t  // anything else? Maybe for some compression?\n\t  function getNormalizationForTypedArray(typedArray) {\n\t    if (typedArray instanceof Int8Array) {\n\t      return true;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Uint8Array) {\n\t      return true;\n\t    } // eslint-disable-line\n\t    return false;\n\t  }\n\n\t  // This is really just a guess. Though I can't really imagine using\n\t  // anything else? Maybe for some compression?\n\t  function getNormalizationForTypedArrayType(typedArrayType) {\n\t    if (typedArrayType === Int8Array) {\n\t      return true;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Uint8Array) {\n\t      return true;\n\t    } // eslint-disable-line\n\t    return false;\n\t  }\n\n\t  function getArray(array) {\n\t    return array.length ? array : array.data;\n\t  }\n\n\t  var texcoordRE = /coord|texture/i;\n\t  var colorRE = /color|colour/i;\n\n\t  function guessNumComponentsFromName(name, length) {\n\t    var numComponents;\n\t    if (texcoordRE.test(name)) {\n\t      numComponents = 2;\n\t    } else if (colorRE.test(name)) {\n\t      numComponents = 4;\n\t    } else {\n\t      numComponents = 3; // position, normals, indices ...\n\t    }\n\n\t    if (length % numComponents > 0) {\n\t      throw \"Can not guess numComponents for attribute '\" + name + \"'. Tried \" + numComponents + \" but \" + length + \" values is not evenly divisible by \" + numComponents + \". You should specify it.\";\n\t    }\n\n\t    return numComponents;\n\t  }\n\n\t  function getNumComponents(array, arrayName) {\n\t    return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);\n\t  }\n\n\t  function makeTypedArray(array, name) {\n\t    if (typedArrays.isArrayBuffer(array)) {\n\t      return array;\n\t    }\n\n\t    if (typedArrays.isArrayBuffer(array.data)) {\n\t      return array.data;\n\t    }\n\n\t    if (Array.isArray(array)) {\n\t      array = {\n\t        data: array\n\t      };\n\t    }\n\n\t    var Type = array.type;\n\t    if (!Type) {\n\t      if (isIndices(name)) {\n\t        Type = Uint16Array;\n\t      } else {\n\t        Type = Float32Array;\n\t      }\n\t    }\n\t    return new Type(array.data);\n\t  }\n\n\t  /**\n\t   * The info for an attribute. This is effectively just the arguments to `gl.vertexAttribPointer` plus the WebGLBuffer\n\t   * for the attribute.\n\t   *\n\t   * @typedef {Object} AttribInfo\n\t   * @property {number} [numComponents] the number of components for this attribute.\n\t   * @property {number} [size] synonym for `numComponents`.\n\t   * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`\n\t   * @property {boolean} [normalize] whether or not to normalize the data. Default = false\n\t   * @property {number} [offset] offset into buffer in bytes. Default = 0\n\t   * @property {number} [stride] the stride in bytes per element. Default = 0\n\t   * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute\n\t   * @property {number} [drawType] the draw type passed to gl.bufferData. Default = gl.STATIC_DRAW\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Use this type of array spec when TWGL can't guess the type or number of compoments of an array\n\t   * @typedef {Object} FullArraySpec\n\t   * @property {(number|number[]|ArrayBuffer)} data The data of the array. A number alone becomes the number of elements of type.\n\t   * @property {number} [numComponents] number of components for `vertexAttribPointer`. Default is based on the name of the array.\n\t   *    If `coord` is in the name assumes `numComponents = 2`.\n\t   *    If `color` is in the name assumes `numComponents = 4`.\n\t   *    otherwise assumes `numComponents = 3`\n\t   * @property {constructor} type The type. This is only used if `data` is a JavaScript array. It is the constructor for the typedarray. (eg. `Uint8Array`).\n\t   * For example if you want colors in a `Uint8Array` you might have a `FullArraySpec` like `{ type: Uint8Array, data: [255,0,255,255, ...], }`.\n\t   * @property {number} [size] synonym for `numComponents`.\n\t   * @property {boolean} [normalize] normalize for `vertexAttribPointer`. Default is true if type is `Int8Array` or `Uint8Array` otherwise false.\n\t   * @property {number} [stride] stride for `vertexAttribPointer`. Default = 0\n\t   * @property {number} [offset] offset for `vertexAttribPointer`. Default = 0\n\t   * @property {string} [attrib] name of attribute this array maps to. Defaults to same name as array prefixed by the default attribPrefix.\n\t   * @property {string} [name] synonym for `attrib`.\n\t   * @property {string} [attribName] synonym for `attrib`.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * An individual array in {@link module:twgl.Arrays}\n\t   *\n\t   * When passed to {@link module:twgl.createBufferInfoFromArrays} if an ArraySpec is `number[]` or `ArrayBuffer`\n\t   * the types will be guessed based on the name. `indices` will be `Uint16Array`, everything else will\n\t   * be `Float32Array`. If an ArraySpec is a number it's the number of floats for an empty (zeroed) buffer.\n\t   *\n\t   * @typedef {(number|number[]|ArrayBuffer|module:twgl.FullArraySpec)} ArraySpec\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * This is a JavaScript object of arrays by name. The names should match your shader's attributes. If your\n\t   * attributes have a common prefix you can specify it by calling {@link module:twgl.setAttributePrefix}.\n\t   *\n\t   *     Bare JavaScript Arrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: [-1, 1, 0],\n\t   *            normal: [0, 1, 0],\n\t   *            ...\n\t   *         }\n\t   *\n\t   *     Bare TypedArrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: new Float32Array([-1, 1, 0]),\n\t   *            color: new Uint8Array([255, 128, 64, 255]),\n\t   *            ...\n\t   *         }\n\t   *\n\t   * *   Will guess at `numComponents` if not specified based on name.\n\t   *\n\t   *     If `coord` is in the name assumes `numComponents = 2`\n\t   *\n\t   *     If `color` is in the name assumes `numComponents = 4`\n\t   *\n\t   *     otherwise assumes `numComponents = 3`\n\t   *\n\t   * Objects with various fields. See {@link module:twgl.FullArraySpec}.\n\t   *\n\t   *     var arrays = {\n\t   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n\t   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n\t   *     };\n\t   *\n\t   * @typedef {Object.<string, module:twgl.ArraySpec>} Arrays\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a set of attribute data and WebGLBuffers from set of arrays\n\t   *\n\t   * Given\n\t   *\n\t   *      var arrays = {\n\t   *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n\t   *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },\n\t   *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n\t   *      };\n\t   *\n\t   * returns something like\n\t   *\n\t   *      var attribs = {\n\t   *        position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n\t   *        texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n\t   *        normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n\t   *        color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },\n\t   *      };\n\t   *\n\t   * notes:\n\t   *\n\t   * *   Arrays can take various forms\n\t   *\n\t   *     Bare JavaScript Arrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: [-1, 1, 0],\n\t   *            normal: [0, 1, 0],\n\t   *            ...\n\t   *         }\n\t   *\n\t   *     Bare TypedArrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: new Float32Array([-1, 1, 0]),\n\t   *            color: new Uint8Array([255, 128, 64, 255]),\n\t   *            ...\n\t   *         }\n\t   *\n\t   * *   Will guess at `numComponents` if not specified based on name.\n\t   *\n\t   *     If `coord` is in the name assumes `numComponents = 2`\n\t   *\n\t   *     If `color` is in the name assumes `numComponents = 4`\n\t   *\n\t   *     otherwise assumes `numComponents = 3`\n\t   *\n\t   * @param {WebGLRenderingContext} gl The webgl rendering context.\n\t   * @param {module:twgl.Arrays} arrays The arrays\n\t   * @return {Object.<string, module:twgl.AttribInfo>} the attribs\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createAttribsFromArrays(gl, arrays) {\n\t    var attribs = {};\n\t    Object.keys(arrays).forEach(function (arrayName) {\n\t      if (!isIndices(arrayName)) {\n\t        var array = arrays[arrayName];\n\t        var attribName = array.attrib || array.name || array.attribName || defaults.attribPrefix + arrayName;\n\t        var buffer;\n\t        var type;\n\t        var normalization;\n\t        var numComponents;\n\t        var numValues;\n\t        if (typeof array === \"number\" || typeof array.data === \"number\") {\n\t          numValues = array.data || array;\n\t          var arrayType = array.type || Float32Array;\n\t          var numBytes = numValues * arrayType.BYTES_PER_ELEMENT;\n\t          type = typedArrays.getGLTypeForTypedArrayType(arrayType);\n\t          normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArrayType(arrayType);\n\t          numComponents = array.numComponents || array.size || guessNumComponentsFromName(arrayName, numValues);\n\t          buffer = gl.createBuffer();\n\t          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t          gl.bufferData(gl.ARRAY_BUFFER, numBytes, array.drawType || gl.STATIC_DRAW);\n\t        } else {\n\t          var typedArray = makeTypedArray(array, arrayName);\n\t          buffer = createBufferFromTypedArray(gl, typedArray, undefined, array.drawType);\n\t          type = typedArrays.getGLTypeForTypedArray(typedArray);\n\t          normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArray(typedArray);\n\t          numComponents = getNumComponents(array, arrayName);\n\t          numValues = typedArray.length;\n\t        }\n\t        attribs[attribName] = {\n\t          buffer: buffer,\n\t          numComponents: numComponents,\n\t          type: type,\n\t          normalize: normalization,\n\t          stride: array.stride || 0,\n\t          offset: array.offset || 0,\n\t          drawType: array.drawType\n\t        };\n\t      }\n\t    });\n\t    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\t    return attribs;\n\t  }\n\n\t  /**\n\t   * Sets the contents of a buffer attached to an attribInfo\n\t   *\n\t   * This is helper function to dynamically update a buffer.\n\t   *\n\t   * Let's say you make a bufferInfo\n\t   *\n\t   *     var arrays = {\n\t   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n\t   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n\t   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n\t   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n\t   *     };\n\t   *     var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\n\t   *\n\t   *  And you want to dynamically upate the positions. You could do this\n\t   *\n\t   *     // assuming arrays.position has already been updated with new data.\n\t   *     twgl.setAttribInfoBufferFromArray(gl, bufferInfo.attribs.position, arrays.position);\n\t   *\n\t   * @param {WebGLRenderingContext} gl\n\t   * @param {AttribInfo} attribInfo The attribInfo who's buffer contents to set. NOTE: If you have an attribute prefix\n\t   *   the name of the attribute will include the prefix.\n\t   * @param {ArraySpec} array Note: it is arguably ineffient to pass in anything but a typed array because anything\n\t   *    else will have to be converted to a typed array before it can be used by WebGL. During init time that\n\t   *    inefficiency is usually not important but if you're updating data dynamically best to be efficient.\n\t   * @param {number} [offset] an optional offset into the buffer. This is only an offset into the WebGL buffer\n\t   *    not the array. To pass in an offset into the array itself use a typed array and create an `ArrayBufferView`\n\t   *    for the portion of the array you want to use.\n\t   *\n\t   *        var someArray = new Float32Array(1000); // an array with 1000 floats\n\t   *        var someSubArray = new Float32Array(someArray.buffer, offsetInBytes, sizeInUnits); // a view into someArray\n\t   *\n\t   *    Now you can pass `someSubArray` into setAttribInfoBufferFromArray`\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function setAttribInfoBufferFromArray(gl, attribInfo, array, offset) {\n\t    array = makeTypedArray(array);\n\t    if (offset !== undefined) {\n\t      gl.bindBuffer(gl.ARRAY_BUFFER, attribInfo.buffer);\n\t      gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);\n\t    } else {\n\t      setBufferFromTypedArray(gl, gl.ARRAY_BUFFER, attribInfo.buffer, array, attribInfo.drawType);\n\t    }\n\t  }\n\n\t  function getBytesPerValueForGLType(gl, type) {\n\t    if (type === gl.BYTE) return 1; // eslint-disable-line\n\t    if (type === gl.UNSIGNED_BYTE) return 1; // eslint-disable-line\n\t    if (type === gl.SHORT) return 2; // eslint-disable-line\n\t    if (type === gl.UNSIGNED_SHORT) return 2; // eslint-disable-line\n\t    if (type === gl.INT) return 4; // eslint-disable-line\n\t    if (type === gl.UNSIGNED_INT) return 4; // eslint-disable-line\n\t    if (type === gl.FLOAT) return 4; // eslint-disable-line\n\t    return 0;\n\t  }\n\n\t  /**\n\t   * tries to get the number of elements from a set of arrays.\n\t   */\n\t  var positionKeys = ['position', 'positions', 'a_position'];\n\t  function getNumElementsFromNonIndexedArrays(arrays) {\n\t    var key;\n\t    for (var ii = 0; ii < positionKeys.length; ++ii) {\n\t      key = positionKeys[ii];\n\t      if (key in arrays) {\n\t        break;\n\t      }\n\t    }\n\t    if (ii === positionKeys.length) {\n\t      key = Object.keys(arrays)[0];\n\t    }\n\t    var array = arrays[key];\n\t    var length = getArray(array).length;\n\t    var numComponents = getNumComponents(array, key);\n\t    var numElements = length / numComponents;\n\t    if (length % numComponents > 0) {\n\t      throw \"numComponents \" + numComponents + \" not correct for length \" + length;\n\t    }\n\t    return numElements;\n\t  }\n\n\t  function getNumElementsFromAttributes(gl, attribs) {\n\t    var key;\n\t    for (var ii = 0; ii < positionKeys.length; ++ii) {\n\t      key = positionKeys[ii];\n\t      if (key in attribs) {\n\t        break;\n\t      }\n\t      key = defaults.attribPrefix + key;\n\t      if (key in attribs) {\n\t        break;\n\t      }\n\t    }\n\t    if (ii === positionKeys.length) {\n\t      key = Object.keys(attribs)[0];\n\t    }\n\t    var attrib = attribs[key];\n\t    gl.bindBuffer(gl.ARRAY_BUFFER, attrib.buffer);\n\t    var numBytes = gl.getBufferParameter(gl.ARRAY_BUFFER, gl.BUFFER_SIZE);\n\t    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n\t    var bytesPerValue = getBytesPerValueForGLType(gl, attrib.type);\n\t    var totalElements = numBytes / bytesPerValue;\n\t    var numComponents = attrib.numComponents || attrib.size;\n\t    // TODO: check stride\n\t    var numElements = totalElements / numComponents;\n\t    if (numElements % 1 !== 0) {\n\t      throw \"numComponents \" + numComponents + \" not correct for length \" + length;\n\t    }\n\t    return numElements;\n\t  }\n\n\t  /**\n\t   * @typedef {Object} BufferInfo\n\t   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n\t   * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..\n\t   * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.\n\t   * @property {Object.<string, module:twgl.AttribInfo>} [attribs] The attribs approriate to call `setAttributes`\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a BufferInfo from an object of arrays.\n\t   *\n\t   * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to\n\t   * {@link module:twgl:drawBufferInfo}.\n\t   *\n\t   * Given an object like\n\t   *\n\t   *     var arrays = {\n\t   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n\t   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n\t   *     };\n\t   *\n\t   *  Creates an BufferInfo like this\n\t   *\n\t   *     bufferInfo = {\n\t   *       numElements: 4,        // or whatever the number of elements is\n\t   *       indices: WebGLBuffer,  // this property will not exist if there are no indices\n\t   *       attribs: {\n\t   *         a_position: { buffer: WebGLBuffer, numComponents: 3, },\n\t   *         a_normal:   { buffer: WebGLBuffer, numComponents: 3, },\n\t   *         a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },\n\t   *       },\n\t   *     };\n\t   *\n\t   *  The properties of arrays can be JavaScript arrays in which case the number of components\n\t   *  will be guessed.\n\t   *\n\t   *     var arrays = {\n\t   *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],\n\t   *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],\n\t   *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],\n\t   *        indices:  [0, 1, 2, 1, 2, 3],\n\t   *     };\n\t   *\n\t   *  They can also by TypedArrays\n\t   *\n\t   *     var arrays = {\n\t   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n\t   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n\t   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n\t   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n\t   *     };\n\t   *\n\t   *  Or augmentedTypedArrays\n\t   *\n\t   *     var positions = createAugmentedTypedArray(3, 4);\n\t   *     var texcoords = createAugmentedTypedArray(2, 4);\n\t   *     var normals   = createAugmentedTypedArray(3, 4);\n\t   *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);\n\t   *\n\t   *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);\n\t   *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);\n\t   *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);\n\t   *     indices.push([0, 1, 2, 1, 2, 3]);\n\t   *\n\t   *     var arrays = {\n\t   *        position: positions,\n\t   *        texcoord: texcoords,\n\t   *        normal:   normals,\n\t   *        indices:  indices,\n\t   *     };\n\t   *\n\t   * For the last example it is equivalent to\n\t   *\n\t   *     var bufferInfo = {\n\t   *       attribs: {\n\t   *         a_position: { numComponents: 3, buffer: gl.createBuffer(), },\n\t   *         a_texcoods: { numComponents: 2, buffer: gl.createBuffer(), },\n\t   *         a_normals: { numComponents: 3, buffer: gl.createBuffer(), },\n\t   *       },\n\t   *       indices: gl.createBuffer(),\n\t   *       numElements: 6,\n\t   *     };\n\t   *\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_position.buffer);\n\t   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_texcoord.buffer);\n\t   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_normal.buffer);\n\t   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);\n\t   *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);\n\t   *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {module:twgl.Arrays} arrays Your data\n\t   * @return {module:twgl.BufferInfo} A BufferInfo\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBufferInfoFromArrays(gl, arrays) {\n\t    var bufferInfo = {\n\t      attribs: createAttribsFromArrays(gl, arrays)\n\t    };\n\t    var indices = arrays.indices;\n\t    if (indices) {\n\t      indices = makeTypedArray(indices, \"indices\");\n\t      bufferInfo.indices = createBufferFromTypedArray(gl, indices, gl.ELEMENT_ARRAY_BUFFER);\n\t      bufferInfo.numElements = indices.length;\n\t      bufferInfo.elementType = typedArrays.getGLTypeForTypedArray(indices);\n\t    } else {\n\t      bufferInfo.numElements = getNumElementsFromAttributes(gl, bufferInfo.attribs);\n\t    }\n\n\t    return bufferInfo;\n\t  }\n\n\t  /**\n\t   * Creates a buffer from an array, typed array, or array spec\n\t   *\n\t   * Given something like this\n\t   *\n\t   *     [1, 2, 3],\n\t   *\n\t   * or\n\t   *\n\t   *     new Uint16Array([1,2,3]);\n\t   *\n\t   * or\n\t   *\n\t   *     {\n\t   *        data: [1, 2, 3],\n\t   *        type: Uint8Array,\n\t   *     }\n\t   *\n\t   * returns a WebGLBuffer that constains the given data.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n\t   * @param {module:twgl.ArraySpec} array an array, typed array, or array spec.\n\t   * @param {string} arrayName name of array. Used to guess the type if type can not be dervied other wise.\n\t   * @return {WebGLBuffer} a WebGLBuffer containing the data in array.\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBufferFromArray(gl, array, arrayName) {\n\t    var type = arrayName === \"indices\" ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n\t    var typedArray = makeTypedArray(array, arrayName);\n\t    return createBufferFromTypedArray(gl, typedArray, type);\n\t  }\n\n\t  /**\n\t   * Creates buffers from arrays or typed arrays\n\t   *\n\t   * Given something like this\n\t   *\n\t   *     var arrays = {\n\t   *        positions: [1, 2, 3],\n\t   *        normals: [0, 0, 1],\n\t   *     }\n\t   *\n\t   * returns something like\n\t   *\n\t   *     buffers = {\n\t   *       positions: WebGLBuffer,\n\t   *       normals: WebGLBuffer,\n\t   *     }\n\t   *\n\t   * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n\t   * @param {module:twgl.Arrays} arrays\n\t   * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBuffersFromArrays(gl, arrays) {\n\t    var buffers = {};\n\t    Object.keys(arrays).forEach(function (key) {\n\t      buffers[key] = createBufferFromArray(gl, arrays[key], key);\n\t    });\n\n\t    // Ugh!\n\t    if (arrays.indices) {\n\t      buffers.numElements = arrays.indices.length;\n\t      buffers.elementType = typedArrays.getGLTypeForTypedArray(makeTypedArray(arrays.indices), 'indices');\n\t    } else {\n\t      buffers.numElements = getNumElementsFromNonIndexedArrays(arrays);\n\t    }\n\n\t    return buffers;\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"createAttribsFromArrays\": createAttribsFromArrays,\n\t    \"createBuffersFromArrays\": createBuffersFromArrays,\n\t    \"createBufferFromArray\": createBufferFromArray,\n\t    \"createBufferFromTypedArray\": createBufferFromTypedArray,\n\t    \"createBufferInfoFromArrays\": createBufferInfoFromArrays,\n\t    \"setAttribInfoBufferFromArray\": setAttribInfoBufferFromArray,\n\n\t    \"setAttributePrefix\": setAttributePrefix,\n\n\t    \"setDefaults_\": setDefaults,\n\t    \"getNumComponents_\": getNumComponents,\n\t    \"getArray_\": getArray\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t  \"use strict\";\n\n\t  /**\n\t   * Low level shader typed array related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.typedArray` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/typedArray\n\t   */\n\n\t  // make sure we don't see a global gl\n\n\t  var gl = undefined; // eslint-disable-line\n\n\t  /* DataType */\n\t  var BYTE = 0x1400;\n\t  var UNSIGNED_BYTE = 0x1401;\n\t  var SHORT = 0x1402;\n\t  var UNSIGNED_SHORT = 0x1403;\n\t  var INT = 0x1404;\n\t  var UNSIGNED_INT = 0x1405;\n\t  var FLOAT = 0x1406;\n\t  var UNSIGNED_SHORT_4_4_4_4 = 0x8033;\n\t  var UNSIGNED_SHORT_5_5_5_1 = 0x8034;\n\t  var UNSIGNED_SHORT_5_6_5 = 0x8363;\n\t  var HALF_FLOAT = 0x140B;\n\t  var UNSIGNED_INT_2_10_10_10_REV = 0x8368;\n\t  var UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;\n\t  var UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;\n\t  var FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;\n\t  var UNSIGNED_INT_24_8 = 0x84FA;\n\n\t  var glTypeToTypedArray = {};\n\t  {\n\t    var tt = glTypeToTypedArray;\n\t    tt[BYTE] = Int8Array;\n\t    tt[UNSIGNED_BYTE] = Uint8Array;\n\t    tt[SHORT] = Int16Array;\n\t    tt[UNSIGNED_SHORT] = Uint16Array;\n\t    tt[INT] = Int32Array;\n\t    tt[UNSIGNED_INT] = Uint32Array;\n\t    tt[FLOAT] = Float32Array;\n\t    tt[UNSIGNED_SHORT_4_4_4_4] = Uint16Array;\n\t    tt[UNSIGNED_SHORT_5_5_5_1] = Uint16Array;\n\t    tt[UNSIGNED_SHORT_5_6_5] = Uint16Array;\n\t    tt[HALF_FLOAT] = Uint16Array;\n\t    tt[UNSIGNED_INT_2_10_10_10_REV] = Uint32Array;\n\t    tt[UNSIGNED_INT_10F_11F_11F_REV] = Uint32Array;\n\t    tt[UNSIGNED_INT_5_9_9_9_REV] = Uint32Array;\n\t    tt[FLOAT_32_UNSIGNED_INT_24_8_REV] = Uint32Array;\n\t    tt[UNSIGNED_INT_24_8] = Uint32Array;\n\t  }\n\n\t  /**\n\t   * Get the GL type for a typedArray\n\t   * @param {ArrayBuffer|ArrayBufferView} typedArray a typedArray\n\t   * @return {number} the GL type for array. For example pass in an `Int8Array` and `gl.BYTE` will\n\t   *   be returned. Pass in a `Uint32Array` and `gl.UNSIGNED_INT` will be returned\n\t   * @memberOf module:twgl/typedArray\n\t   */\n\t  function getGLTypeForTypedArray(typedArray) {\n\t    if (typedArray instanceof Int8Array) {\n\t      return BYTE;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Uint8Array) {\n\t      return UNSIGNED_BYTE;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Uint8ClampedArray) {\n\t      return UNSIGNED_BYTE;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Int16Array) {\n\t      return SHORT;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Uint16Array) {\n\t      return UNSIGNED_SHORT;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Int32Array) {\n\t      return INT;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Uint32Array) {\n\t      return UNSIGNED_INT;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Float32Array) {\n\t      return FLOAT;\n\t    } // eslint-disable-line\n\t    throw \"unsupported typed array type\";\n\t  }\n\n\t  /**\n\t   * Get the GL type for a typedArray type\n\t   * @param {ArrayBufferViewType} typedArrayType a typedArray constructor\n\t   * @return {number} the GL type for type. For example pass in `Int8Array` and `gl.BYTE` will\n\t   *   be returned. Pass in `Uint32Array` and `gl.UNSIGNED_INT` will be returned\n\t   * @memberOf module:twgl/typedArray\n\t   */\n\t  function getGLTypeForTypedArrayType(typedArrayType) {\n\t    if (typedArrayType === Int8Array) {\n\t      return BYTE;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Uint8Array) {\n\t      return UNSIGNED_BYTE;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Uint8ClampedArray) {\n\t      return UNSIGNED_BYTE;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Int16Array) {\n\t      return SHORT;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Uint16Array) {\n\t      return UNSIGNED_SHORT;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Int32Array) {\n\t      return INT;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Uint32Array) {\n\t      return UNSIGNED_INT;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Float32Array) {\n\t      return FLOAT;\n\t    } // eslint-disable-line\n\t    throw \"unsupported typed array type\";\n\t  }\n\n\t  /**\n\t   * Get the typed array constructor for a given GL type\n\t   * @param {number} type the GL type. (eg: `gl.UNSIGNED_INT`)\n\t   * @return {function} the constructor for a the corresponding typed array. (eg. `Uint32Array`).\n\t   * @memberOf module:twgl/typedArray\n\t   */\n\t  function getTypedArrayTypeForGLType(type) {\n\t    var CTOR = glTypeToTypedArray[type];\n\t    if (!CTOR) {\n\t      throw \"unknown gl type\";\n\t    }\n\t    return CTOR;\n\t  }\n\n\t  function isArrayBuffer(a) {\n\t    return a && a.buffer && a.buffer instanceof ArrayBuffer;\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  return {\n\t    \"getGLTypeForTypedArray\": getGLTypeForTypedArray,\n\t    \"getGLTypeForTypedArrayType\": getGLTypeForTypedArrayType,\n\t    \"getTypedArrayTypeForGLType\": getTypedArrayTypeForGLType,\n\t    \"isArrayBuffer\": isArrayBuffer\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t  \"use strict\";\n\n\t  /**\n\t   * Copy an object 1 level deep\n\t   * @param {object} src object to copy\n\t   * @return {object} the copy\n\t   */\n\n\t  function shallowCopy(src) {\n\t    var dst = {};\n\t    Object.keys(src).forEach(function (key) {\n\t      dst[key] = src[key];\n\t    });\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Copy named properties\n\t   *\n\t   * @param {string[]} names names of properties to copy\n\t   * @param {object} src object to copy properties from\n\t   * @param {object} dst object to copy properties to\n\t   */\n\t  function copyNamedProperties(names, src, dst) {\n\t    names.forEach(function (name) {\n\t      var value = src[name];\n\t      if (value !== undefined) {\n\t        dst[name] = value;\n\t      }\n\t    });\n\t  }\n\n\t  /**\n\t   * Copies properties from source to dest only if a matching key is in dest\n\t   *\n\t   * @param {Object.<string, ?>} src the source\n\t   * @param {Object.<string, ?>} dst the dest\n\t   */\n\t  function copyExistingProperties(src, dst) {\n\t    Object.keys(dst).forEach(function (key) {\n\t      if (dst.hasOwnProperty(key) && src.hasOwnProperty(key)) {\n\t        dst[key] = src[key];\n\t      }\n\t    });\n\t  }\n\n\t  /**\n\t   * Gets the gl version as a number\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @return {number} version of gl\n\t   */\n\t  //function getVersionAsNumber(gl) {\n\t  //  return parseFloat(gl.getParameter(gl.VERSION).substr(6));\n\t  //}\n\n\t  /**\n\t   * Check if context is WebGL 2.0\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @return {bool} true if it's WebGL 2.0\n\t   * @memberOf module:twgl\n\t   */\n\t  function isWebGL2(gl) {\n\t    // This is the correct check but it's slow\n\t    //return gl.getParameter(gl.VERSION).indexOf(\"WebGL 2.0\") === 0;\n\t    // This might also be the correct check but I'm assuming it's slow-ish\n\t    // return gl instanceof WebGL2RenderingContext;\n\t    return !!gl.texStorage2D;\n\t  }\n\n\t  /**\n\t   * Check if context is WebGL 1.0\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @return {bool} true if it's WebGL 1.0\n\t   * @memberOf module:twgl\n\t   */\n\t  function isWebGL1(gl) {\n\t    // This is the correct check but it's slow\n\t    //var version = getVersionAsNumber(gl);\n\t    //return version <= 1.0 && version > 0.0;  // because as of 2016/5 Edge returns 0.96\n\t    // This might also be the correct check but I'm assuming it's slow-ish\n\t    // return gl instanceof WebGLRenderingContext;\n\t    return !gl.texStorage2D;\n\t  }\n\n\t  var error = window.console && window.console.error && typeof window.console.error === \"function\" ? window.console.error.bind(window.console) : function () {};\n\n\t  var warn = window.console && window.console.warn && typeof window.console.warn === \"function\" ? window.console.warn.bind(window.console) : function () {};\n\n\t  return {\n\t    copyExistingProperties: copyExistingProperties,\n\t    copyNamedProperties: copyNamedProperties,\n\t    shallowCopy: shallowCopy,\n\t    isWebGL1: isWebGL1,\n\t    isWebGL2: isWebGL2,\n\t    error: error,\n\t    warn: warn\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (programs) {\n\t  \"use strict\";\n\n\t  /**\n\t   * Drawing related functions\n\t   *\n\t   * For backward compatibily they are available at both `twgl.draw` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/draw\n\t   */\n\n\t  /**\n\t   * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate\n\t   *\n\t   * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself\n\t   * but calling this means if you switch from indexed data to non-indexed\n\t   * data you don't have to remember to update your draw call.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} bufferInfo A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays} or\n\t   *   a VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}\n\t   * @param {enum} [type] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...). Defaults to `gl.TRIANGLES`\n\t   * @param {number} [count] An optional count. Defaults to bufferInfo.numElements\n\t   * @param {number} [offset] An optional offset. Defaults to 0.\n\t   * @memberOf module:twgl/draw\n\t   */\n\n\t  function drawBufferInfo(gl, bufferInfo, type, count, offset) {\n\t    type = type === undefined ? gl.TRIANGLES : type;\n\t    var indices = bufferInfo.indices;\n\t    var elementType = bufferInfo.elementType;\n\t    var numElements = count === undefined ? bufferInfo.numElements : count;\n\t    offset = offset === undefined ? 0 : offset;\n\t    if (elementType || indices) {\n\t      gl.drawElements(type, numElements, elementType === undefined ? gl.UNSIGNED_SHORT : bufferInfo.elementType, offset);\n\t    } else {\n\t      gl.drawArrays(type, offset, numElements);\n\t    }\n\t  }\n\n\t  /**\n\t   * A DrawObject is useful for putting objects in to an array and passing them to {@link module:twgl.drawObjectList}.\n\t   *\n\t   * You need either a `BufferInfo` or a `VertexArrayInfo`.\n\t   *\n\t   * @typedef {Object} DrawObject\n\t   * @property {boolean} [active] whether or not to draw. Default = `true` (must be `false` to be not true). In otherwords `undefined` = `true`\n\t   * @property {number} [type] type to draw eg. `gl.TRIANGLES`, `gl.LINES`, etc...\n\t   * @property {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}\n\t   * @property {module:twgl.BufferInfo} [bufferInfo] A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays}\n\t   * @property {module:twgl.VertexArrayInfo} [vertexArrayInfo] A VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}\n\t   * @property {Object<string, ?>} uniforms The values for the uniforms.\n\t   *   You can pass multiple objects by putting them in an array. For example\n\t   *\n\t   *     var sharedUniforms = {\n\t   *       u_fogNear: 10,\n\t   *       u_projection: ...\n\t   *       ...\n\t   *     };\n\t   *\n\t   *     var localUniforms = {\n\t   *       u_world: ...\n\t   *       u_diffuseColor: ...\n\t   *     };\n\t   *\n\t   *     var drawObj = {\n\t   *       ...\n\t   *       uniforms: [sharedUniforms, localUniforms],\n\t   *     };\n\t   *\n\t   * @property {number} [offset] the offset to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to 0.\n\t   * @property {number} [count] the count to pass to `gl.drawArrays` or `gl.drawElemnts`. Defaults to bufferInfo.numElements.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Draws a list of objects\n\t   * @param {DrawObject[]} objectsToDraw an array of objects to draw.\n\t   * @memberOf module:twgl/draw\n\t   */\n\t  function drawObjectList(gl, objectsToDraw) {\n\t    var lastUsedProgramInfo = null;\n\t    var lastUsedBufferInfo = null;\n\n\t    objectsToDraw.forEach(function (object) {\n\t      if (object.active === false) {\n\t        return;\n\t      }\n\n\t      var programInfo = object.programInfo;\n\t      var bufferInfo = object.vertexArrayInfo || object.bufferInfo;\n\t      var bindBuffers = false;\n\t      var type = object.type === undefined ? gl.TRIANGLES : object.type;\n\n\t      if (programInfo !== lastUsedProgramInfo) {\n\t        lastUsedProgramInfo = programInfo;\n\t        gl.useProgram(programInfo.program);\n\n\t        // We have to rebind buffers when changing programs because we\n\t        // only bind buffers the program uses. So if 2 programs use the same\n\t        // bufferInfo but the 1st one uses only positions the when the\n\t        // we switch to the 2nd one some of the attributes will not be on.\n\t        bindBuffers = true;\n\t      }\n\n\t      // Setup all the needed attributes.\n\t      if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {\n\t        if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject && !bufferInfo.vertexArrayObject) {\n\t          gl.bindVertexArray(null);\n\t        }\n\t        lastUsedBufferInfo = bufferInfo;\n\t        programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n\t      }\n\n\t      // Set the uniforms.\n\t      programs.setUniforms(programInfo, object.uniforms);\n\n\t      // Draw\n\t      drawBufferInfo(gl, bufferInfo, type, object.count, object.offset);\n\t    });\n\n\t    if (lastUsedBufferInfo.vertexArrayObject) {\n\t      gl.bindVertexArray(null);\n\t    }\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"drawBufferInfo\": drawBufferInfo,\n\t    \"drawObjectList\": drawObjectList\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (utils) {\n\t  \"use strict\";\n\n\t  /**\n\t   * Low level shader program related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.programs` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/programs\n\t   */\n\n\t  var error = utils.error;\n\t  var warn = utils.warn;\n\n\t  var FLOAT = 0x1406;\n\t  var FLOAT_VEC2 = 0x8B50;\n\t  var FLOAT_VEC3 = 0x8B51;\n\t  var FLOAT_VEC4 = 0x8B52;\n\t  var INT = 0x1404;\n\t  var INT_VEC2 = 0x8B53;\n\t  var INT_VEC3 = 0x8B54;\n\t  var INT_VEC4 = 0x8B55;\n\t  var BOOL = 0x8B56;\n\t  var BOOL_VEC2 = 0x8B57;\n\t  var BOOL_VEC3 = 0x8B58;\n\t  var BOOL_VEC4 = 0x8B59;\n\t  var FLOAT_MAT2 = 0x8B5A;\n\t  var FLOAT_MAT3 = 0x8B5B;\n\t  var FLOAT_MAT4 = 0x8B5C;\n\t  var SAMPLER_2D = 0x8B5E;\n\t  var SAMPLER_CUBE = 0x8B60;\n\t  var SAMPLER_3D = 0x8B5F;\n\t  var SAMPLER_2D_SHADOW = 0x8B62;\n\t  var FLOAT_MAT2x3 = 0x8B65;\n\t  var FLOAT_MAT2x4 = 0x8B66;\n\t  var FLOAT_MAT3x2 = 0x8B67;\n\t  var FLOAT_MAT3x4 = 0x8B68;\n\t  var FLOAT_MAT4x2 = 0x8B69;\n\t  var FLOAT_MAT4x3 = 0x8B6A;\n\t  var SAMPLER_2D_ARRAY = 0x8DC1;\n\t  var SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;\n\t  var SAMPLER_CUBE_SHADOW = 0x8DC5;\n\t  var UNSIGNED_INT = 0x1405;\n\t  var UNSIGNED_INT_VEC2 = 0x8DC6;\n\t  var UNSIGNED_INT_VEC3 = 0x8DC7;\n\t  var UNSIGNED_INT_VEC4 = 0x8DC8;\n\t  var INT_SAMPLER_2D = 0x8DCA;\n\t  var INT_SAMPLER_3D = 0x8DCB;\n\t  var INT_SAMPLER_CUBE = 0x8DCC;\n\t  var INT_SAMPLER_2D_ARRAY = 0x8DCF;\n\t  var UNSIGNED_INT_SAMPLER_2D = 0x8DD2;\n\t  var UNSIGNED_INT_SAMPLER_3D = 0x8DD3;\n\t  var UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;\n\t  var UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;\n\n\t  var TEXTURE_2D = 0x0DE1;\n\t  var TEXTURE_CUBE_MAP = 0x8513;\n\t  var TEXTURE_3D = 0x806F;\n\t  var TEXTURE_2D_ARRAY = 0x8C1A;\n\n\t  var typeMap = {};\n\n\t  /**\n\t   * Returns the corresponding bind point for a given sampler type\n\t   */\n\t  function getBindPointForSamplerType(gl, type) {\n\t    return typeMap[type].bindPoint;\n\t  }\n\n\t  // This kind of sucks! If you could compose functions as in `var fn = gl[name];`\n\t  // this code could be a lot smaller but that is sadly really slow (T_T)\n\n\t  function floatSetter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform1f(location, v);\n\t    };\n\t  }\n\n\t  function floatArraySetter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform1fv(location, v);\n\t    };\n\t  }\n\n\t  function floatVec2Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform2fv(location, v);\n\t    };\n\t  }\n\n\t  function floatVec3Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform3fv(location, v);\n\t    };\n\t  }\n\n\t  function floatVec4Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform4fv(location, v);\n\t    };\n\t  }\n\n\t  function intSetter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform1i(location, v);\n\t    };\n\t  }\n\n\t  function intArraySetter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform1iv(location, v);\n\t    };\n\t  }\n\n\t  function intVec2Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform2iv(location, v);\n\t    };\n\t  }\n\n\t  function intVec3Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform3iv(location, v);\n\t    };\n\t  }\n\n\t  function intVec4Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform4iv(location, v);\n\t    };\n\t  }\n\n\t  function uintSetter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform1ui(location, v);\n\t    };\n\t  }\n\n\t  function uintArraySetter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform1uiv(location, v);\n\t    };\n\t  }\n\n\t  function uintVec2Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform2uiv(location, v);\n\t    };\n\t  }\n\n\t  function uintVec3Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform3uiv(location, v);\n\t    };\n\t  }\n\n\t  function uintVec4Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform4uiv(location, v);\n\t    };\n\t  }\n\n\t  function floatMat2Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix2fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat3Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix3fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat4Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix4fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat23Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix2x3fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat32Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix3x2fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat24Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix2x4fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat42Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix4x2fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat34Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix3x4fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat43Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix4x3fv(location, false, v);\n\t    };\n\t  }\n\n\t  function samplerSetter(gl, type, unit, location) {\n\t    var bindPoint = getBindPointForSamplerType(gl, type);\n\t    return utils.isWebGL2(gl) ? function (textureOrPair) {\n\t      var texture = void 0;\n\t      var sampler = void 0;\n\t      if (textureOrPair instanceof WebGLTexture) {\n\t        texture = textureOrPair;\n\t        sampler = null;\n\t      } else {\n\t        texture = textureOrPair.texture;\n\t        sampler = textureOrPair.sampler;\n\t      }\n\t      gl.uniform1i(location, unit);\n\t      gl.activeTexture(gl.TEXTURE0 + unit);\n\t      gl.bindTexture(bindPoint, texture);\n\t      gl.bindSampler(unit, sampler);\n\t    } : function (texture) {\n\t      gl.uniform1i(location, unit);\n\t      gl.activeTexture(gl.TEXTURE0 + unit);\n\t      gl.bindTexture(bindPoint, texture);\n\t    };\n\t  }\n\n\t  function samplerArraySetter(gl, type, unit, location, size) {\n\t    var bindPoint = getBindPointForSamplerType(gl, type);\n\t    var units = new Int32Array(size);\n\t    for (var ii = 0; ii < size; ++ii) {\n\t      units[ii] = unit + ii;\n\t    }\n\n\t    return utils.isWebGL2(gl) ? function (textures) {\n\t      gl.uniform1iv(location, units);\n\t      textures.forEach(function (textureOrPair, index) {\n\t        gl.activeTexture(gl.TEXTURE0 + units[index]);\n\t        var texture = void 0;\n\t        var sampler = void 0;\n\t        if (textureOrPair instanceof WebGLTexture) {\n\t          texture = textureOrPair;\n\t          sampler = null;\n\t        } else {\n\t          texture = textureOrPair.texture;\n\t          sampler = textureOrPair.sampler;\n\t        }\n\t        gl.bindSampler(unit, sampler);\n\t        gl.bindTexture(bindPoint, texture);\n\t      });\n\t    } : function (textures) {\n\t      gl.uniform1iv(location, units);\n\t      textures.forEach(function (texture, index) {\n\t        gl.activeTexture(gl.TEXTURE0 + units[index]);\n\t        gl.bindTexture(bindPoint, texture);\n\t      });\n\t    };\n\t  }\n\n\t  typeMap[FLOAT] = { Type: Float32Array, size: 4, setter: floatSetter, arraySetter: floatArraySetter };\n\t  typeMap[FLOAT_VEC2] = { Type: Float32Array, size: 8, setter: floatVec2Setter };\n\t  typeMap[FLOAT_VEC3] = { Type: Float32Array, size: 12, setter: floatVec3Setter };\n\t  typeMap[FLOAT_VEC4] = { Type: Float32Array, size: 16, setter: floatVec4Setter };\n\t  typeMap[INT] = { Type: Int32Array, size: 4, setter: intSetter, arraySetter: intArraySetter };\n\t  typeMap[INT_VEC2] = { Type: Int32Array, size: 8, setter: intVec2Setter };\n\t  typeMap[INT_VEC3] = { Type: Int32Array, size: 12, setter: intVec3Setter };\n\t  typeMap[INT_VEC4] = { Type: Int32Array, size: 16, setter: intVec4Setter };\n\t  typeMap[UNSIGNED_INT] = { Type: Uint32Array, size: 4, setter: uintSetter, arraySetter: uintArraySetter };\n\t  typeMap[UNSIGNED_INT_VEC2] = { Type: Uint32Array, size: 8, setter: uintVec2Setter };\n\t  typeMap[UNSIGNED_INT_VEC3] = { Type: Uint32Array, size: 12, setter: uintVec3Setter };\n\t  typeMap[UNSIGNED_INT_VEC4] = { Type: Uint32Array, size: 16, setter: uintVec4Setter };\n\t  typeMap[BOOL] = { Type: Uint32Array, size: 4, setter: intSetter, arraySetter: intArraySetter };\n\t  typeMap[BOOL_VEC2] = { Type: Uint32Array, size: 8, setter: intVec2Setter };\n\t  typeMap[BOOL_VEC3] = { Type: Uint32Array, size: 12, setter: intVec3Setter };\n\t  typeMap[BOOL_VEC4] = { Type: Uint32Array, size: 16, setter: intVec4Setter };\n\t  typeMap[FLOAT_MAT2] = { Type: Float32Array, size: 16, setter: floatMat2Setter };\n\t  typeMap[FLOAT_MAT3] = { Type: Float32Array, size: 36, setter: floatMat3Setter };\n\t  typeMap[FLOAT_MAT4] = { Type: Float32Array, size: 64, setter: floatMat4Setter };\n\t  typeMap[FLOAT_MAT2x3] = { Type: Float32Array, size: 24, setter: floatMat23Setter };\n\t  typeMap[FLOAT_MAT2x4] = { Type: Float32Array, size: 32, setter: floatMat24Setter };\n\t  typeMap[FLOAT_MAT3x2] = { Type: Float32Array, size: 24, setter: floatMat32Setter };\n\t  typeMap[FLOAT_MAT3x4] = { Type: Float32Array, size: 48, setter: floatMat34Setter };\n\t  typeMap[FLOAT_MAT4x2] = { Type: Float32Array, size: 32, setter: floatMat42Setter };\n\t  typeMap[FLOAT_MAT4x3] = { Type: Float32Array, size: 48, setter: floatMat43Setter };\n\t  typeMap[SAMPLER_2D] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D };\n\t  typeMap[SAMPLER_CUBE] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP };\n\t  typeMap[SAMPLER_3D] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D };\n\t  typeMap[SAMPLER_2D_SHADOW] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D };\n\t  typeMap[SAMPLER_2D_ARRAY] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY };\n\t  typeMap[SAMPLER_2D_ARRAY_SHADOW] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY };\n\t  typeMap[SAMPLER_CUBE_SHADOW] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP };\n\t  typeMap[INT_SAMPLER_2D] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D };\n\t  typeMap[INT_SAMPLER_3D] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D };\n\t  typeMap[INT_SAMPLER_CUBE] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP };\n\t  typeMap[INT_SAMPLER_2D_ARRAY] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY };\n\t  typeMap[UNSIGNED_INT_SAMPLER_2D] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D };\n\t  typeMap[UNSIGNED_INT_SAMPLER_3D] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D };\n\t  typeMap[UNSIGNED_INT_SAMPLER_CUBE] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP };\n\t  typeMap[UNSIGNED_INT_SAMPLER_2D_ARRAY] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY };\n\n\t  function floatAttribSetter(gl, index) {\n\t    return function (b) {\n\t      gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n\t      gl.enableVertexAttribArray(index);\n\t      gl.vertexAttribPointer(index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);\n\t    };\n\t  }\n\n\t  function intAttribSetter(gl, index) {\n\t    return function (b) {\n\t      gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n\t      gl.enableVertexAttribArray(index);\n\t      gl.vertexAttribIPointer(index, b.numComponents || b.size, b.type || gl.INT, b.stride || 0, b.offset || 0);\n\t    };\n\t  }\n\n\t  function matAttribSetter(gl, index, typeInfo) {\n\t    var defaultSize = typeInfo.size;\n\t    var count = typeInfo.count;\n\n\t    return function (b) {\n\t      gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n\t      var numComponents = b.size || b.numComponents || defaultSize;\n\t      var size = numComponents / count;\n\t      var type = b.type || gl.FLOAT;\n\t      var typeInfo = typeMap[type];\n\t      var stride = typeInfo.size * numComponents;\n\t      var normalize = b.normalize || false;\n\t      var offset = b.offset || 0;\n\t      var rowOffset = stride / count;\n\t      for (var i = 0; i < count; ++i) {\n\t        gl.enableVertexAttribArray(index + i);\n\t        gl.vertexAttribPointer(index + i, size, type, normalize, stride, offset + rowOffset * i);\n\t      }\n\t    };\n\t  }\n\n\t  var attrTypeMap = {};\n\t  attrTypeMap[FLOAT] = { size: 4, setter: floatAttribSetter };\n\t  attrTypeMap[FLOAT_VEC2] = { size: 8, setter: floatAttribSetter };\n\t  attrTypeMap[FLOAT_VEC3] = { size: 12, setter: floatAttribSetter };\n\t  attrTypeMap[FLOAT_VEC4] = { size: 16, setter: floatAttribSetter };\n\t  attrTypeMap[INT] = { size: 4, setter: intAttribSetter };\n\t  attrTypeMap[INT_VEC2] = { size: 8, setter: intAttribSetter };\n\t  attrTypeMap[INT_VEC3] = { size: 12, setter: intAttribSetter };\n\t  attrTypeMap[INT_VEC4] = { size: 16, setter: intAttribSetter };\n\t  attrTypeMap[UNSIGNED_INT] = { size: 4, setter: intAttribSetter };\n\t  attrTypeMap[UNSIGNED_INT_VEC2] = { size: 8, setter: intAttribSetter };\n\t  attrTypeMap[UNSIGNED_INT_VEC3] = { size: 12, setter: intAttribSetter };\n\t  attrTypeMap[UNSIGNED_INT_VEC4] = { size: 16, setter: intAttribSetter };\n\t  attrTypeMap[BOOL] = { size: 4, setter: intAttribSetter };\n\t  attrTypeMap[BOOL_VEC2] = { size: 8, setter: intAttribSetter };\n\t  attrTypeMap[BOOL_VEC3] = { size: 12, setter: intAttribSetter };\n\t  attrTypeMap[BOOL_VEC4] = { size: 16, setter: intAttribSetter };\n\t  attrTypeMap[FLOAT_MAT2] = { size: 4, setter: matAttribSetter, count: 2 };\n\t  attrTypeMap[FLOAT_MAT3] = { size: 9, setter: matAttribSetter, count: 3 };\n\t  attrTypeMap[FLOAT_MAT4] = { size: 16, setter: matAttribSetter, count: 4 };\n\n\t  // make sure we don't see a global gl\n\t  var gl = undefined; // eslint-disable-line\n\n\t  /**\n\t   * Error Callback\n\t   * @callback ErrorCallback\n\t   * @param {string} msg error message.\n\t   * @param {number} [lineOffset] amount to add to line number\n\t   * @memberOf module:twgl\n\t   */\n\n\t  function addLineNumbers(src, lineOffset) {\n\t    lineOffset = lineOffset || 0;\n\t    ++lineOffset;\n\n\t    return src.split(\"\\n\").map(function (line, ndx) {\n\t      return ndx + lineOffset + \": \" + line;\n\t    }).join(\"\\n\");\n\t  }\n\n\t  var spaceRE = /^[ \\t]*\\n/;\n\n\t  /**\n\t   * Loads a shader.\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {string} shaderSource The shader source.\n\t   * @param {number} shaderType The type of shader.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors.\n\t   * @return {WebGLShader} The created shader.\n\t   */\n\t  function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\n\t    var errFn = opt_errorCallback || error;\n\t    // Create the shader object\n\t    var shader = gl.createShader(shaderType);\n\n\t    // Remove the first end of line because WebGL 2.0 requires\n\t    // #version 300 es\n\t    // as the first line. No whitespace allowed before that line\n\t    // so\n\t    //\n\t    // <script>\n\t    // #version 300 es\n\t    // </script>\n\t    //\n\t    // Has one line before it which is invalid according to GLSL ES 3.00\n\t    //\n\t    var lineOffset = 0;\n\t    if (spaceRE.test(shaderSource)) {\n\t      lineOffset = 1;\n\t      shaderSource = shaderSource.replace(spaceRE, '');\n\t    }\n\n\t    // Load the shader source\n\t    gl.shaderSource(shader, shaderSource);\n\n\t    // Compile the shader\n\t    gl.compileShader(shader);\n\n\t    // Check the compile status\n\t    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\t    if (!compiled) {\n\t      // Something went wrong during compilation; get the error\n\t      var lastError = gl.getShaderInfoLog(shader);\n\t      errFn(addLineNumbers(shaderSource, lineOffset) + \"\\n*** Error compiling shader: \" + lastError);\n\t      gl.deleteShader(shader);\n\t      return null;\n\t    }\n\n\t    return shader;\n\t  }\n\n\t  /**\n\t   * @typedef {Object} ProgramOptions\n\t   * @property {function(string)} [errorCallback] callback for errors\n\t   * @property {Object.<string,number>} [attribLocations] a attribute name to location map\n\t   * @property {(module:twgl.BufferInfo|Object.<string,module:twgl.AttribInfo>|string[])} [transformFeedbackVaryings] If passed\n\t   *   a BufferInfo will use the attribs names inside. If passed an object of AttribInfos will use the names from that object. Otherwise\n\t   *   you can pass an array of names.\n\t   * @property {number} [transformFeedbackMode] the mode to pass `gl.transformFeedbackVaryings`. Defaults to `SEPARATE_ATTRIBS`.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Gets the program options based on all these optional arguments\n\t   * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {module:twgl.ProgramOptions} an instance of ProgramOptions based on the arguments pased on\n\t   */\n\t  function getProgramOptions(opt_attribs, opt_locations, opt_errorCallback) {\n\t    if (typeof opt_locations === 'function') {\n\t      opt_errorCallback = opt_locations;\n\t      opt_locations = undefined;\n\t    }\n\t    if (typeof opt_attribs === 'function') {\n\t      opt_errorCallback = opt_attribs;\n\t      opt_attribs = undefined;\n\t    } else if (opt_attribs && !Array.isArray(opt_attribs)) {\n\t      // If we have an errorCallback we can just return this object\n\t      // Otherwise we need to construct one with default errorCallback\n\t      if (opt_attribs.errorCallback) {\n\t        return opt_attribs;\n\t      }\n\t      var opt = opt_attribs;\n\t      opt_errorCallback = opt.errorCallback;\n\t      opt_attribs = opt.attribLocations;\n\t      var transformFeedbackVaryings = opt.transformFeedbackVaryings;\n\t    }\n\n\t    var options = {\n\t      errorCallback: opt_errorCallback || error,\n\t      transformFeedbackVaryings: transformFeedbackVaryings\n\t    };\n\n\t    if (opt_attribs) {\n\t      var attribLocations = {};\n\t      if (Array.isArray(opt_attribs)) {\n\t        opt_attribs.forEach(function (attrib, ndx) {\n\t          attribLocations[attrib] = opt_locations ? opt_locations[ndx] : ndx;\n\t        });\n\t      } else {\n\t        attribLocations = opt_attribs;\n\t      }\n\t      options.attribLocations = attribLocations;\n\t    }\n\n\t    return options;\n\t  }\n\n\t  var defaultShaderType = [\"VERTEX_SHADER\", \"FRAGMENT_SHADER\"];\n\n\t  function getShaderTypeFromScriptType(scriptType) {\n\t    if (scriptType.indexOf(\"frag\") >= 0) {\n\t      return gl.FRAGMENT_SHADER;\n\t    } else if (scriptType.indexOf(\"vert\") >= 0) {\n\t      return gl.VERTEX_SHADER;\n\t    }\n\t    return undefined;\n\t  }\n\n\t  /**\n\t   * Creates a program, attaches (and/or compiles) shaders, binds attrib locations, links the\n\t   * program and calls useProgram.\n\t   *\n\t   * NOTE: There are 4 signatures for this function\n\t   *\n\t   *     twgl.createProgram(gl, [vs, fs], options);\n\t   *     twgl.createProgram(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLShader[]|string[]} shaders The shaders to attach, or element ids for their source, or strings that contain their source\n\t   * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {WebGLProgram?} the created program or null if error.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {\n\t    var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);\n\t    var program = gl.createProgram();\n\t    shaders.forEach(function (shader, ndx) {\n\t      if (typeof shader === 'string') {\n\t        var elem = document.getElementById(shader);\n\t        var src = elem ? elem.text : shader;\n\t        var type = defaultShaderType[ndx];\n\t        if (elem && elem.type) {\n\t          type = getShaderTypeFromScriptType(elem.type);\n\t        }\n\t        shader = loadShader(gl, src, type, progOptions.errorCallback);\n\t      }\n\t      gl.attachShader(program, shader);\n\t    });\n\t    if (progOptions.attribLocations) {\n\t      Object.keys(progOptions.attribLocations).forEach(function (attrib) {\n\t        gl.bindAttribLocation(program, progOptions.attribLocations[attrib], attrib);\n\t      });\n\t    }\n\t    var varyings = progOptions.transformFeedbackVaryings;\n\t    if (varyings) {\n\t      if (varyings.attribs) {\n\t        varyings = varyings.attribs;\n\t      }\n\t      if (!Array.isArray(varyings)) {\n\t        varyings = Object.keys(varyings);\n\t      }\n\t      gl.transformFeedbackVaryings(program, varyings, progOptions.transformFeedbackMode || gl.SEPARATE_ATTRIBS);\n\t    }\n\t    gl.linkProgram(program);\n\n\t    // Check the link status\n\t    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\t    if (!linked) {\n\t      // something went wrong with the link\n\t      var lastError = gl.getProgramInfoLog(program);\n\t      progOptions.errorCallback(\"Error in program linking:\" + lastError);\n\n\t      gl.deleteProgram(program);\n\t      return null;\n\t    }\n\t    return program;\n\t  }\n\n\t  /**\n\t   * Loads a shader from a script tag.\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {string} scriptId The id of the script tag.\n\t   * @param {number} [opt_shaderType] The type of shader. If not passed in it will\n\t   *     be derived from the type of the script tag.\n\t   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors.\n\t   * @return {WebGLShader?} The created shader or null if error.\n\t   */\n\t  function createShaderFromScript(gl, scriptId, opt_shaderType, opt_errorCallback) {\n\t    var shaderSource = \"\";\n\t    var shaderScript = document.getElementById(scriptId);\n\t    if (!shaderScript) {\n\t      throw \"*** Error: unknown script element\" + scriptId;\n\t    }\n\t    shaderSource = shaderScript.text;\n\n\t    var shaderType = opt_shaderType || getShaderTypeFromScriptType(shaderScript.type);\n\t    if (!shaderType) {\n\t      throw \"*** Error: unknown shader type\";\n\t    }\n\n\t    return loadShader(gl, shaderSource, shaderType, opt_errorCallback);\n\t  }\n\n\t  /**\n\t   * Creates a program from 2 script tags.\n\t   *\n\t   * NOTE: There are 4 signatures for this function\n\t   *\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_options);\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {string[]} shaderScriptIds Array of ids of the script\n\t   *        tags for the shaders. The first is assumed to be the\n\t   *        vertex shader, the second the fragment shader.\n\t   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {WebGLProgram} The created program.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramFromScripts(gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {\n\t    var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);\n\t    var shaders = [];\n\t    for (var ii = 0; ii < shaderScriptIds.length; ++ii) {\n\t      var shader = createShaderFromScript(gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], progOptions.errorCallback);\n\t      if (!shader) {\n\t        return null;\n\t      }\n\t      shaders.push(shader);\n\t    }\n\t    return createProgram(gl, shaders, progOptions);\n\t  }\n\n\t  /**\n\t   * Creates a program from 2 sources.\n\t   *\n\t   * NOTE: There are 4 signatures for this function\n\t   *\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_options);\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {string[]} shaderSources Array of sources for the\n\t   *        shaders. The first is assumed to be the vertex shader,\n\t   *        the second the fragment shader.\n\t   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {WebGLProgram} The created program.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n\t    var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);\n\t    var shaders = [];\n\t    for (var ii = 0; ii < shaderSources.length; ++ii) {\n\t      var shader = loadShader(gl, shaderSources[ii], gl[defaultShaderType[ii]], progOptions.errorCallback);\n\t      if (!shader) {\n\t        return null;\n\t      }\n\t      shaders.push(shader);\n\t    }\n\t    return createProgram(gl, shaders, progOptions);\n\t  }\n\n\t  /**\n\t   * Creates setter functions for all uniforms of a shader\n\t   * program.\n\t   *\n\t   * @see {@link module:twgl.setUniforms}\n\t   *\n\t   * @param {WebGLProgram} program the program to create setters for.\n\t   * @returns {Object.<string, function>} an object with a setter by name for each uniform\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformSetters(gl, program) {\n\t    var textureUnit = 0;\n\n\t    /**\n\t     * Creates a setter for a uniform of the given program with it's\n\t     * location embedded in the setter.\n\t     * @param {WebGLProgram} program\n\t     * @param {WebGLUniformInfo} uniformInfo\n\t     * @returns {function} the created setter.\n\t     */\n\t    function createUniformSetter(program, uniformInfo) {\n\t      var location = gl.getUniformLocation(program, uniformInfo.name);\n\t      var isArray = uniformInfo.size > 1 && uniformInfo.name.substr(-3) === \"[0]\";\n\t      var type = uniformInfo.type;\n\t      var typeInfo = typeMap[type];\n\t      if (!typeInfo) {\n\t        throw \"unknown type: 0x\" + type.toString(16); // we should never get here.\n\t      }\n\t      if (typeInfo.bindPoint) {\n\t        // it's a sampler\n\t        var unit = textureUnit;\n\t        textureUnit += uniformInfo.size;\n\n\t        if (isArray) {\n\t          return typeInfo.arraySetter(gl, type, unit, location, uniformInfo.size);\n\t        } else {\n\t          return typeInfo.setter(gl, type, unit, location, uniformInfo.size);\n\t        }\n\t      } else {\n\t        if (typeInfo.arraySetter && isArray) {\n\t          return typeInfo.arraySetter(gl, location);\n\t        } else {\n\t          return typeInfo.setter(gl, location);\n\t        }\n\t      }\n\t    }\n\n\t    var uniformSetters = {};\n\t    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n\t    for (var ii = 0; ii < numUniforms; ++ii) {\n\t      var uniformInfo = gl.getActiveUniform(program, ii);\n\t      if (!uniformInfo) {\n\t        break;\n\t      }\n\t      var name = uniformInfo.name;\n\t      // remove the array suffix.\n\t      if (name.substr(-3) === \"[0]\") {\n\t        name = name.substr(0, name.length - 3);\n\t      }\n\t      var setter = createUniformSetter(program, uniformInfo);\n\t      uniformSetters[name] = setter;\n\t    }\n\t    return uniformSetters;\n\t  }\n\n\t  /**\n\t   * @typedef {Object} TransformFeedbackInfo\n\t   * @property {number} index index of transform feedback\n\t   * @property {number} type GL type\n\t   * @property {number} size 1 - 4\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Create TransformFeedbackInfo for passing to bind/unbindTransformFeedbackInfo.\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {WebGLProgram} program an existing WebGLProgram.\n\t   * @return {Object<string, module:twgl.TransformFeedbackInfo>}\n\t   * @memberOf module:twgl\n\t   */\n\t  function createTransformFeedbackInfo(gl, program) {\n\t    var info = {};\n\t    var numVaryings = gl.getProgramParameter(program, gl.TRANSFORM_FEEDBACK_VARYINGS);\n\t    for (var ii = 0; ii < numVaryings; ++ii) {\n\t      var varying = gl.getTransformFeedbackVarying(program, ii);\n\t      info[varying.name] = {\n\t        index: ii,\n\t        type: varying.type,\n\t        size: varying.size\n\t      };\n\t    }\n\t    return info;\n\t  }\n\n\t  /**\n\t   * Binds buffers for transform feedback.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {(module:twgl.ProgramInfo|Object<string, module:twgl.TransformFeedbackInfo>)} transformFeedbackInfo A ProgramInfo or TransformFeedbackInfo.\n\t   * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.\n\t   * @memberOf module:twgl\n\t   */\n\t  function bindTransformFeedbackInfo(gl, transformFeedbackInfo, bufferInfo) {\n\t    if (transformFeedbackInfo.transformFeedbackInfo) {\n\t      transformFeedbackInfo = transformFeedbackInfo.transformFeedbackInfo;\n\t    }\n\t    if (bufferInfo.attribs) {\n\t      bufferInfo = bufferInfo.attribs;\n\t    }\n\t    for (var name in bufferInfo) {\n\t      var varying = transformFeedbackInfo[name];\n\t      if (varying) {\n\t        var buf = bufferInfo[name];\n\t        if (buf.offset) {\n\t          gl.bindBufferRange(gl.TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer, buf.offset, buf.size);\n\t        } else {\n\t          gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer);\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * Unbinds buffers afetr transform feedback.\n\t   *\n\t   * Buffers can not be bound to 2 bind points so if you try to bind a buffer used\n\t   * in a transform feedback as an ARRAY_BUFFER for an attribute it will fail.\n\t   *\n\t   * This function unbinds all buffers that were bound with {@link module:twgl.bindTransformFeedbackInfo}.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {(module:twgl.ProgramInfo|Object<string, module:twgl.TransformFeedbackInfo>)} transformFeedbackInfo A ProgramInfo or TransformFeedbackInfo.\n\t   * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.\n\t   */\n\t  function unbindTransformFeedbackInfo(gl, transformFeedbackInfo, bufferInfo) {\n\t    if (transformFeedbackInfo.transformFeedbackInfo) {\n\t      transformFeedbackInfo = transformFeedbackInfo.transformFeedbackInfo;\n\t    }\n\t    if (bufferInfo.attribs) {\n\t      bufferInfo = bufferInfo.attribs;\n\t    }\n\t    for (var name in bufferInfo) {\n\t      var varying = transformFeedbackInfo[name];\n\t      if (varying) {\n\t        gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, varying.index, null);\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * Creates a transform feedback and sets the buffers\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}\n\t   * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.\n\t   * @return {WebGLTransformFeedback} the created transform feedback\n\t   * @memberOf module:twgl\n\t   */\n\t  function createTransformFeedback(gl, programInfo, bufferInfo) {\n\t    var tf = gl.createTransformFeedback();\n\t    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);\n\t    gl.useProgram(programInfo.program);\n\t    bindTransformFeedbackInfo(gl, programInfo, bufferInfo);\n\t    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n\t    // This is only needed because of a bug in Chrome 56. Will remove\n\t    // when chrome fixes it.\n\t    unbindTransformFeedbackInfo(gl, programInfo, bufferInfo);\n\t    return tf;\n\t  }\n\n\t  /**\n\t   * @typedef {Object} UniformData\n\t   * @property {number} type The WebGL type enum for this uniform\n\t   * @property {number} size The number of elements for this uniform\n\t   * @property {number} blockNdx The block index this uniform appears in\n\t   * @property {number} offset The byte offset in the block for this uniform's value\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * The specification for one UniformBlockObject\n\t   *\n\t   * @typedef {Object} BlockSpec\n\t   * @property {number} index The index of the block.\n\t   * @property {number} size The size in bytes needed for the block\n\t   * @property {number[]} uniformIndices The indices of the uniforms used by the block. These indices\n\t   *    correspond to entries in a UniformData array in the {@link module:twgl.UniformBlockSpec}.\n\t   * @property {bool} usedByVertexShader Self explanitory\n\t   * @property {bool} usedByFragmentShader Self explanitory\n\t   * @property {bool} used Self explanitory\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * A `UniformBlockSpec` represents the data needed to create and bind\n\t   * UniformBlockObjects for a given program\n\t   *\n\t   * @typedef {Object} UniformBlockSpec\n\t   * @property {Object.<string, module:twgl.BlockSpec> blockSpecs The BlockSpec for each block by block name\n\t   * @property {UniformData[]} uniformData An array of data for each uniform by uniform index.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a UniformBlockSpec for the given program.\n\t   *\n\t   * A UniformBlockSpec represents the data needed to create and bind\n\t   * UniformBlockObjects\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL2 Rendering Context\n\t   * @param {WebGLProgram} program A WebGLProgram for a successfully linked program\n\t   * @return {module:twgl.UniformBlockSpec} The created UniformBlockSpec\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformBlockSpecFromProgram(gl, program) {\n\t    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\t    var uniformData = [];\n\t    var uniformIndices = [];\n\n\t    for (var ii = 0; ii < numUniforms; ++ii) {\n\t      uniformIndices.push(ii);\n\t      uniformData.push({});\n\t      var uniformInfo = gl.getActiveUniform(program, ii);\n\t      if (!uniformInfo) {\n\t        break;\n\t      }\n\t      // REMOVE [0]?\n\t      uniformData[ii].name = uniformInfo.name;\n\t    }\n\n\t    [[\"UNIFORM_TYPE\", \"type\"], [\"UNIFORM_SIZE\", \"size\"], // num elements\n\t    [\"UNIFORM_BLOCK_INDEX\", \"blockNdx\"], [\"UNIFORM_OFFSET\", \"offset\"]].forEach(function (pair) {\n\t      var pname = pair[0];\n\t      var key = pair[1];\n\t      gl.getActiveUniforms(program, uniformIndices, gl[pname]).forEach(function (value, ndx) {\n\t        uniformData[ndx][key] = value;\n\t      });\n\t    });\n\n\t    var blockSpecs = {};\n\n\t    var numUniformBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n\t    for (ii = 0; ii < numUniformBlocks; ++ii) {\n\t      var name = gl.getActiveUniformBlockName(program, ii);\n\t      var blockSpec = {\n\t        index: ii,\n\t        usedByVertexShader: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),\n\t        usedByFragmentShader: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),\n\t        size: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_DATA_SIZE),\n\t        uniformIndices: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES)\n\t      };\n\t      blockSpec.used = blockSpec.usedByVertexSahder || blockSpec.usedByFragmentShader;\n\t      blockSpecs[name] = blockSpec;\n\t    }\n\n\t    return {\n\t      blockSpecs: blockSpecs,\n\t      uniformData: uniformData\n\t    };\n\t  }\n\n\t  var arraySuffixRE = /\\[\\d+\\]\\.$/; // better way to check?\n\n\t  /**\n\t   * Represents a UniformBlockObject including an ArrayBuffer with all the uniform values\n\t   * and a corresponding WebGLBuffer to hold those values on the GPU\n\t   *\n\t   * @typedef {Object} UniformBlockInfo\n\t   * @property {string} name The name of the block\n\t   * @property {ArrayBuffer} array The array buffer that contains the uniform values\n\t   * @property {Float32Array} asFloat A float view on the array buffer. This is useful\n\t   *    inspecting the contents of the buffer in the debugger.\n\t   * @property {WebGLBuffer} buffer A WebGL buffer that will hold a copy of the uniform values for rendering.\n\t   * @property {number} [offset] offset into buffer\n\t   * @property {Object.<string, ArrayBufferView>} uniforms A uniform name to ArrayBufferView map.\n\t   *   each Uniform has a correctly typed `ArrayBufferView` into array at the correct offset\n\t   *   and length of that uniform. So for example a float uniform would have a 1 float `Float32Array`\n\t   *   view. A single mat4 would have a 16 element `Float32Array` view. An ivec2 would have an\n\t   *   `Int32Array` view, etc.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a `UniformBlockInfo` for the specified block\n\t   *\n\t   * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy\n\t   * `UniformBlockInfo` is returned**. This is because when debugging GLSL\n\t   * it is common to comment out large portions of a shader or for example set\n\t   * the final output to a constant. When that happens blocks get optimized out.\n\t   * If this function did not create dummy blocks your code would crash when debugging.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext\n\t   * @param {WebGLProgram} program A WebGLProgram\n\t   * @param {module:twgl.UniformBlockSpec} uinformBlockSpec. A UniformBlockSpec as returned\n\t   *     from {@link module:twgl.createUniformBlockSpecFromProgram}.\n\t   * @param {string} blockName The name of the block.\n\t   * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformBlockInfoFromProgram(gl, program, uniformBlockSpec, blockName) {\n\t    var blockSpecs = uniformBlockSpec.blockSpecs;\n\t    var uniformData = uniformBlockSpec.uniformData;\n\t    var blockSpec = blockSpecs[blockName];\n\t    if (!blockSpec) {\n\t      warn(\"no uniform block object named:\", blockName);\n\t      return {\n\t        name: blockName,\n\t        uniforms: {}\n\t      };\n\t    }\n\t    var array = new ArrayBuffer(blockSpec.size);\n\t    var buffer = gl.createBuffer();\n\t    var uniformBufferIndex = blockSpec.index;\n\t    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);\n\t    gl.uniformBlockBinding(program, blockSpec.index, uniformBufferIndex);\n\n\t    var prefix = blockName + \".\";\n\t    if (arraySuffixRE.test(prefix)) {\n\t      prefix = prefix.replace(arraySuffixRE, \".\");\n\t    }\n\t    var uniforms = {};\n\t    blockSpec.uniformIndices.forEach(function (uniformNdx) {\n\t      var data = uniformData[uniformNdx];\n\t      var typeInfo = typeMap[data.type];\n\t      var Type = typeInfo.Type;\n\t      var length = data.size * typeInfo.size;\n\t      var name = data.name;\n\t      if (name.substr(0, prefix.length) === prefix) {\n\t        name = name.substr(prefix.length);\n\t      }\n\t      uniforms[name] = new Type(array, data.offset, length / Type.BYTES_PER_ELEMENT);\n\t    });\n\t    return {\n\t      name: blockName,\n\t      array: array,\n\t      asFloat: new Float32Array(array), // for debugging\n\t      buffer: buffer,\n\t      uniforms: uniforms\n\t    };\n\t  }\n\n\t  /**\n\t   * Creates a `UniformBlockInfo` for the specified block\n\t   *\n\t   * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy\n\t   * `UniformBlockInfo` is returned**. This is because when debugging GLSL\n\t   * it is common to comment out large portions of a shader or for example set\n\t   * the final output to a constant. When that happens blocks get optimized out.\n\t   * If this function did not create dummy blocks your code would crash when debugging.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext\n\t   * @param {module:twgl.ProgramInfo} programInfo a `ProgramInfo`\n\t   *     as returned from {@link module:twgl.createProgramInfo}\n\t   * @param {string} blockName The name of the block.\n\t   * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformBlockInfo(gl, programInfo, blockName) {\n\t    return createUniformBlockInfoFromProgram(gl, programInfo.program, programInfo.uniformBlockSpec, blockName);\n\t  }\n\n\t  /**\n\t   * Binds a unform block to the matching uniform block point.\n\t   * Matches by blocks by name so blocks must have the same name not just the same\n\t   * structure.\n\t   *\n\t   * If you have changed any values and you upload the valus into the corresponding WebGLBuffer\n\t   * call {@link module:twgl.setUniformBlock} instead.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.\n\t   * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`\n\t   *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as\n\t   *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.\n\t   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from\n\t   *     {@link module:twgl.createUniformBlockInfo}.\n\t   * @return {bool} true if buffer was bound. If the programInfo has no block with the same block name\n\t   *     no buffer is bound.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function bindUniformBlock(gl, programInfo, uniformBlockInfo) {\n\t    var uniformBlockSpec = programInfo.uniformBlockSpec || programInfo;\n\t    var blockSpec = uniformBlockSpec.blockSpecs[uniformBlockInfo.name];\n\t    if (blockSpec) {\n\t      var bufferBindIndex = blockSpec.index;\n\t      gl.bindBufferRange(gl.UNIFORM_BUFFER, bufferBindIndex, uniformBlockInfo.buffer, uniformBlockInfo.offset || 0, uniformBlockInfo.array.byteLength);\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\n\t  /**\n\t   * Uploads the current uniform values to the corresponding WebGLBuffer\n\t   * and binds that buffer to the program's corresponding bind point for the uniform block object.\n\t   *\n\t   * If you haven't changed any values and you only need to bind the uniform block object\n\t   * call {@link module:twgl.bindUniformBlock} instead.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.\n\t   * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`\n\t   *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as\n\t   *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.\n\t   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from\n\t   *     {@link module:twgl.createUniformBlockInfo}.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setUniformBlock(gl, programInfo, uniformBlockInfo) {\n\t    if (bindUniformBlock(gl, programInfo, uniformBlockInfo)) {\n\t      gl.bufferData(gl.UNIFORM_BUFFER, uniformBlockInfo.array, gl.DYNAMIC_DRAW);\n\t    }\n\t  }\n\n\t  /**\n\t   * Sets values of a uniform block object\n\t   *\n\t   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo A UniformBlockInfo as returned by {@link module:twgl.createUniformBlockInfo}.\n\t   * @param {Object.<string, ?>} values A uniform name to value map where the value is correct for the given\n\t   *    type of uniform. So for example given a block like\n\t   *\n\t   *       uniform SomeBlock {\n\t   *         float someFloat;\n\t   *         vec2 someVec2;\n\t   *         vec3 someVec3Array[2];\n\t   *         int someInt;\n\t   *       }\n\t   *\n\t   *  You can set the values of the uniform block with\n\t   *\n\t   *       twgl.setBlockUniforms(someBlockInfo, {\n\t   *          someFloat: 12.3,\n\t   *          someVec2: [1, 2],\n\t   *          someVec3Array: [1, 2, 3, 4, 5, 6],\n\t   *          someInt: 5,\n\t   *       }\n\t   *\n\t   *  Arrays can be JavaScript arrays or typed arrays\n\t   *\n\t   *  Any name that doesn't match will be ignored\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setBlockUniforms(uniformBlockInfo, values) {\n\t    var uniforms = uniformBlockInfo.uniforms;\n\t    for (var name in values) {\n\t      var array = uniforms[name];\n\t      if (array) {\n\t        var value = values[name];\n\t        if (value.length) {\n\t          array.set(value);\n\t        } else {\n\t          array[0] = value;\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * Set uniforms and binds related textures.\n\t   *\n\t   * example:\n\t   *\n\t   *     var programInfo = createProgramInfo(\n\t   *         gl, [\"some-vs\", \"some-fs\"]);\n\t   *\n\t   *     var tex1 = gl.createTexture();\n\t   *     var tex2 = gl.createTexture();\n\t   *\n\t   *     ... assume we setup the textures with data ...\n\t   *\n\t   *     var uniforms = {\n\t   *       u_someSampler: tex1,\n\t   *       u_someOtherSampler: tex2,\n\t   *       u_someColor: [1,0,0,1],\n\t   *       u_somePosition: [0,1,1],\n\t   *       u_someMatrix: [\n\t   *         1,0,0,0,\n\t   *         0,1,0,0,\n\t   *         0,0,1,0,\n\t   *         0,0,0,0,\n\t   *       ],\n\t   *     };\n\t   *\n\t   *     gl.useProgram(program);\n\t   *\n\t   * This will automatically bind the textures AND set the\n\t   * uniforms.\n\t   *\n\t   *     twgl.setUniforms(programInfo, uniforms);\n\t   *\n\t   * For the example above it is equivalent to\n\t   *\n\t   *     var texUnit = 0;\n\t   *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n\t   *     gl.bindTexture(gl.TEXTURE_2D, tex1);\n\t   *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n\t   *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n\t   *     gl.bindTexture(gl.TEXTURE_2D, tex2);\n\t   *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n\t   *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);\n\t   *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);\n\t   *     gl.uniformMatrix4fv(u_someMatrix, false, [\n\t   *         1,0,0,0,\n\t   *         0,1,0,0,\n\t   *         0,0,1,0,\n\t   *         0,0,0,0,\n\t   *       ]);\n\t   *\n\t   * Note it is perfectly reasonable to call `setUniforms` multiple times. For example\n\t   *\n\t   *     var uniforms = {\n\t   *       u_someSampler: tex1,\n\t   *       u_someOtherSampler: tex2,\n\t   *     };\n\t   *\n\t   *     var moreUniforms {\n\t   *       u_someColor: [1,0,0,1],\n\t   *       u_somePosition: [0,1,1],\n\t   *       u_someMatrix: [\n\t   *         1,0,0,0,\n\t   *         0,1,0,0,\n\t   *         0,0,1,0,\n\t   *         0,0,0,0,\n\t   *       ],\n\t   *     };\n\t   *\n\t   *     twgl.setUniforms(programInfo, uniforms);\n\t   *     twgl.setUniforms(programInfo, moreUniforms);\n\t   *\n\t   * You can also add WebGLSamplers to uniform samplers as in\n\t   *\n\t   *     var uniforms = {\n\t   *       u_someSampler: {\n\t   *         texture: someWebGLTexture,\n\t   *         sampler: someWebGLSampler,\n\t   *       },\n\t   *     };\n\t   *\n\t   * In which case both the sampler and texture will be bound to the\n\t   * same unit.\n\t   *\n\t   * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from\n\t   *        `createUniformSetters`.\n\t   * @param {Object.<string, ?>} values an object with values for the\n\t   *        uniforms.\n\t   *   You can pass multiple objects by putting them in an array or by calling with more arguments.For example\n\t   *\n\t   *     var sharedUniforms = {\n\t   *       u_fogNear: 10,\n\t   *       u_projection: ...\n\t   *       ...\n\t   *     };\n\t   *\n\t   *     var localUniforms = {\n\t   *       u_world: ...\n\t   *       u_diffuseColor: ...\n\t   *     };\n\t   *\n\t   *     twgl.setUniforms(programInfo, sharedUniforms, localUniforms);\n\t   *\n\t   *     // is the same as\n\t   *\n\t   *     twgl.setUniforms(programInfo, [sharedUniforms, localUniforms]);\n\t   *\n\t   *     // is the same as\n\t   *\n\t   *     twgl.setUniforms(programInfo, sharedUniforms);\n\t   *     twgl.setUniforms(programInfo, localUniforms};\n\t   *\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setUniforms(setters, values) {\n\t    // eslint-disable-line\n\t    var actualSetters = setters.uniformSetters || setters;\n\t    var numArgs = arguments.length;\n\t    for (var andx = 1; andx < numArgs; ++andx) {\n\t      var vals = arguments[andx];\n\t      if (Array.isArray(vals)) {\n\t        var numValues = vals.length;\n\t        for (var ii = 0; ii < numValues; ++ii) {\n\t          setUniforms(actualSetters, vals[ii]);\n\t        }\n\t      } else {\n\t        for (var name in vals) {\n\t          var setter = actualSetters[name];\n\t          if (setter) {\n\t            setter(vals[name]);\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * Creates setter functions for all attributes of a shader\n\t   * program. You can pass this to {@link module:twgl.setBuffersAndAttributes} to set all your buffers and attributes.\n\t   *\n\t   * @see {@link module:twgl.setAttributes} for example\n\t   * @param {WebGLProgram} program the program to create setters for.\n\t   * @return {Object.<string, function>} an object with a setter for each attribute by name.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createAttributeSetters(gl, program) {\n\t    var attribSetters = {};\n\n\t    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\t    for (var ii = 0; ii < numAttribs; ++ii) {\n\t      var attribInfo = gl.getActiveAttrib(program, ii);\n\t      if (!attribInfo) {\n\t        break;\n\t      }\n\t      var index = gl.getAttribLocation(program, attribInfo.name);\n\t      var typeInfo = attrTypeMap[attribInfo.type];\n\t      attribSetters[attribInfo.name] = typeInfo.setter(gl, index, typeInfo);\n\t    }\n\n\t    return attribSetters;\n\t  }\n\n\t  /**\n\t   * Sets attributes and binds buffers (deprecated... use {@link module:twgl.setBuffersAndAttributes})\n\t   *\n\t   * Example:\n\t   *\n\t   *     var program = createProgramFromScripts(\n\t   *         gl, [\"some-vs\", \"some-fs\");\n\t   *\n\t   *     var attribSetters = createAttributeSetters(program);\n\t   *\n\t   *     var positionBuffer = gl.createBuffer();\n\t   *     var texcoordBuffer = gl.createBuffer();\n\t   *\n\t   *     var attribs = {\n\t   *       a_position: {buffer: positionBuffer, numComponents: 3},\n\t   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n\t   *     };\n\t   *\n\t   *     gl.useProgram(program);\n\t   *\n\t   * This will automatically bind the buffers AND set the\n\t   * attributes.\n\t   *\n\t   *     setAttributes(attribSetters, attribs);\n\t   *\n\t   * Properties of attribs. For each attrib you can add\n\t   * properties:\n\t   *\n\t   * *   type: the type of data in the buffer. Default = gl.FLOAT\n\t   * *   normalize: whether or not to normalize the data. Default = false\n\t   * *   stride: the stride. Default = 0\n\t   * *   offset: offset into the buffer. Default = 0\n\t   *\n\t   * For example if you had 3 value float positions, 2 value\n\t   * float texcoord and 4 value uint8 colors you'd setup your\n\t   * attribs like this\n\t   *\n\t   *     var attribs = {\n\t   *       a_position: {buffer: positionBuffer, numComponents: 3},\n\t   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n\t   *       a_color: {\n\t   *         buffer: colorBuffer,\n\t   *         numComponents: 4,\n\t   *         type: gl.UNSIGNED_BYTE,\n\t   *         normalize: true,\n\t   *       },\n\t   *     };\n\t   *\n\t   * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters\n\t   * @param {Object.<string, module:twgl.AttribInfo>} buffers AttribInfos mapped by attribute name.\n\t   * @memberOf module:twgl/programs\n\t   * @deprecated use {@link module:twgl.setBuffersAndAttributes}\n\t   */\n\t  function setAttributes(setters, buffers) {\n\t    for (var name in buffers) {\n\t      var setter = setters[name];\n\t      if (setter) {\n\t        setter(buffers[name]);\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate\n\t   *\n\t   * Example:\n\t   *\n\t   *     var programInfo = createProgramInfo(\n\t   *         gl, [\"some-vs\", \"some-fs\");\n\t   *\n\t   *     var arrays = {\n\t   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *     };\n\t   *\n\t   *     var bufferInfo = createBufferInfoFromArrays(gl, arrays);\n\t   *\n\t   *     gl.useProgram(programInfo.program);\n\t   *\n\t   * This will automatically bind the buffers AND set the\n\t   * attributes.\n\t   *\n\t   *     setBuffersAndAttributes(gl, programInfo, bufferInfo);\n\t   *\n\t   * For the example above it is equivilent to\n\t   *\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\t   *     gl.enableVertexAttribArray(a_positionLocation);\n\t   *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n\t   *     gl.enableVertexAttribArray(a_texcoordLocation);\n\t   *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n\t   * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters A `ProgramInfo` as returned from {@link module:twgl.createProgrmaInfo} or Attribute setters as returned from {@link module:twgl.createAttributeSetters}\n\t   * @param {(module:twgl.BufferInfo|module:twgl.vertexArrayInfo)} buffers a `BufferInfo` as returned from {@link module:twgl.createBufferInfoFromArrays}.\n\t   *   or a `VertexArrayInfo` as returned from {@link module:twgl.createVertexArrayInfo}\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setBuffersAndAttributes(gl, programInfo, buffers) {\n\t    if (buffers.vertexArrayObject) {\n\t      gl.bindVertexArray(buffers.vertexArrayObject);\n\t    } else {\n\t      setAttributes(programInfo.attribSetters || programInfo, buffers.attribs);\n\t      if (buffers.indices) {\n\t        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * @typedef {Object} ProgramInfo\n\t   * @property {WebGLProgram} program A shader program\n\t   * @property {Object<string, function>} uniformSetters object of setters as returned from createUniformSetters,\n\t   * @property {Object<string, function>} attribSetters object of setters as returned from createAttribSetters,\n\t   * @propetty {module:twgl.UniformBlockSpec} [uniformBlockSpace] a uniform block spec for making UniformBlockInfos with createUniformBlockInfo etc..\n\t   * @property {Object<string, module:twgl.TransformFeedbackInfo>} [transformFeedbackInfo] info for transform feedbacks\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a ProgramInfo from an existing program.\n\t   *\n\t   * A ProgramInfo contains\n\t   *\n\t   *     programInfo = {\n\t   *        program: WebGLProgram,\n\t   *        uniformSetters: object of setters as returned from createUniformSetters,\n\t   *        attribSetters: object of setters as returned from createAttribSetters,\n\t   *     }\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {WebGLProgram} program an existing WebGLProgram.\n\t   * @return {module:twgl.ProgramInfo} The created ProgramInfo.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramInfoFromProgram(gl, program) {\n\t    var uniformSetters = createUniformSetters(gl, program);\n\t    var attribSetters = createAttributeSetters(gl, program);\n\t    var programInfo = {\n\t      program: program,\n\t      uniformSetters: uniformSetters,\n\t      attribSetters: attribSetters\n\t    };\n\n\t    if (utils.isWebGL2(gl)) {\n\t      programInfo.uniformBlockSpec = createUniformBlockSpecFromProgram(gl, program);\n\t      programInfo.transformFeedbackInfo = createTransformFeedbackInfo(gl, program);\n\t    }\n\n\t    return programInfo;\n\t  }\n\n\t  /**\n\t   * Creates a ProgramInfo from 2 sources.\n\t   *\n\t   * A ProgramInfo contains\n\t   *\n\t   *     programInfo = {\n\t   *        program: WebGLProgram,\n\t   *        uniformSetters: object of setters as returned from createUniformSetters,\n\t   *        attribSetters: object of setters as returned from createAttribSetters,\n\t   *     }\n\t   *\n\t   * NOTE: There are 4 signatures for this function\n\t   *\n\t   *     twgl.createProgramInfo(gl, [vs, fs], options);\n\t   *     twgl.createProgramInfo(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {string[]} shaderSources Array of sources for the\n\t   *        shaders or ids. The first is assumed to be the vertex shader,\n\t   *        the second the fragment shader.\n\t   * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the attributes. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {module:twgl.ProgramInfo?} The created ProgramInfo or null if it failed to link or compile\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramInfo(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n\t    var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);\n\t    var good = true;\n\t    shaderSources = shaderSources.map(function (source) {\n\t      // Lets assume if there is no \\n it's an id\n\t      if (source.indexOf(\"\\n\") < 0) {\n\t        var script = document.getElementById(source);\n\t        if (!script) {\n\t          progOptions.errorCallback(\"no element with id: \" + source);\n\t          good = false;\n\t        } else {\n\t          source = script.text;\n\t        }\n\t      }\n\t      return source;\n\t    });\n\t    if (!good) {\n\t      return null;\n\t    }\n\t    var program = createProgramFromSources(gl, shaderSources, progOptions);\n\t    if (!program) {\n\t      return null;\n\t    }\n\t    return createProgramInfoFromProgram(gl, program);\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"createAttributeSetters\": createAttributeSetters,\n\n\t    \"createProgram\": createProgram,\n\t    \"createProgramFromScripts\": createProgramFromScripts,\n\t    \"createProgramFromSources\": createProgramFromSources,\n\t    \"createProgramInfo\": createProgramInfo,\n\t    \"createProgramInfoFromProgram\": createProgramInfoFromProgram,\n\t    \"createUniformSetters\": createUniformSetters,\n\t    \"createUniformBlockSpecFromProgram\": createUniformBlockSpecFromProgram,\n\t    \"createUniformBlockInfoFromProgram\": createUniformBlockInfoFromProgram,\n\t    \"createUniformBlockInfo\": createUniformBlockInfo,\n\n\t    \"createTransformFeedback\": createTransformFeedback,\n\t    \"createTransformFeedbackInfo\": createTransformFeedbackInfo,\n\t    \"bindTransformFeedbackInfo\": bindTransformFeedbackInfo,\n\n\t    \"setAttributes\": setAttributes,\n\t    \"setBuffersAndAttributes\": setBuffersAndAttributes,\n\t    \"setUniforms\": setUniforms,\n\t    \"setUniformBlock\": setUniformBlock,\n\t    \"setBlockUniforms\": setBlockUniforms,\n\t    \"bindUniformBlock\": bindUniformBlock\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (textures, utils) {\n\t  \"use strict\";\n\n\t  /**\n\t   * Framebuffer related functions\n\t   *\n\t   * For backward compatibily they are available at both `twgl.framebuffer` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/framebuffers\n\t   */\n\n\t  // make sure we don't see a global gl\n\n\t  var gl = undefined; // eslint-disable-line\n\n\t  var UNSIGNED_BYTE = 0x1401;\n\n\t  /* PixelFormat */\n\t  var DEPTH_COMPONENT = 0x1902;\n\t  var RGBA = 0x1908;\n\n\t  /* Framebuffer Object. */\n\t  var RGBA4 = 0x8056;\n\t  var RGB5_A1 = 0x8057;\n\t  var RGB565 = 0x8D62;\n\t  var DEPTH_COMPONENT16 = 0x81A5;\n\t  var STENCIL_INDEX = 0x1901;\n\t  var STENCIL_INDEX8 = 0x8D48;\n\t  var DEPTH_STENCIL = 0x84F9;\n\t  var COLOR_ATTACHMENT0 = 0x8CE0;\n\t  var DEPTH_ATTACHMENT = 0x8D00;\n\t  var STENCIL_ATTACHMENT = 0x8D20;\n\t  var DEPTH_STENCIL_ATTACHMENT = 0x821A;\n\n\t  /* TextureWrapMode */\n\t  var REPEAT = 0x2901; // eslint-disable-line\n\t  var CLAMP_TO_EDGE = 0x812F;\n\t  var MIRRORED_REPEAT = 0x8370; // eslint-disable-line\n\n\t  /* TextureMagFilter */\n\t  var NEAREST = 0x2600; // eslint-disable-line\n\t  var LINEAR = 0x2601;\n\n\t  /* TextureMinFilter */\n\t  var NEAREST_MIPMAP_NEAREST = 0x2700; // eslint-disable-line\n\t  var LINEAR_MIPMAP_NEAREST = 0x2701; // eslint-disable-line\n\t  var NEAREST_MIPMAP_LINEAR = 0x2702; // eslint-disable-line\n\t  var LINEAR_MIPMAP_LINEAR = 0x2703; // eslint-disable-line\n\n\t  /**\n\t   * The options for a framebuffer attachment.\n\t   *\n\t   * Note: For a `format` that is a texture include all the texture\n\t   * options from {@link module:twgl.TextureOptions} for example\n\t   * `min`, `mag`, `clamp`, etc... Note that unlike {@link module:twgl.TextureOptions}\n\t   * `auto` defaults to `false` for attachment textures but `min` and `mag` default\n\t   * to `gl.LINEAR` and `wrap` defaults to `CLAMP_TO_EDGE`\n\t   *\n\t   * @typedef {Object} AttachmentOptions\n\t   * @property {number} [attach] The attachment point. Defaults\n\t   *   to `gl.COLOR_ATTACTMENT0 + ndx` unless type is a depth or stencil type\n\t   *   then it's gl.DEPTH_ATTACHMENT or `gl.DEPTH_STENCIL_ATTACHMENT` depending\n\t   *   on the format or attachment type.\n\t   * @property {number} [format] The format. If one of `gl.RGBA4`,\n\t   *   `gl.RGB565`, `gl.RGB5_A1`, `gl.DEPTH_COMPONENT16`,\n\t   *   `gl.STENCIL_INDEX8` or `gl.DEPTH_STENCIL` then will create a\n\t   *   renderbuffer. Otherwise will create a texture. Default = `gl.RGBA`\n\t   * @property {number} [type] The type. Used for texture. Default = `gl.UNSIGNED_BYTE`.\n\t   * @property {number} [target] The texture target for `gl.framebufferTexture2D`.\n\t   *   Defaults to `gl.TEXTURE_2D`. Set to appropriate face for cube maps.\n\t   * @property {number} [level] level for `gl.framebufferTexture2D`. Defaults to 0.\n\t   * @property {WebGLObject} [attachment] An existing renderbuffer or texture.\n\t   *    If provided will attach this Object. This allows you to share\n\t   *    attachemnts across framebuffers.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  var defaultAttachments = [{ format: RGBA, type: UNSIGNED_BYTE, min: LINEAR, wrap: CLAMP_TO_EDGE }, { format: DEPTH_STENCIL }];\n\n\t  var attachmentsByFormat = {};\n\t  attachmentsByFormat[DEPTH_STENCIL] = DEPTH_STENCIL_ATTACHMENT;\n\t  attachmentsByFormat[STENCIL_INDEX] = STENCIL_ATTACHMENT;\n\t  attachmentsByFormat[STENCIL_INDEX8] = STENCIL_ATTACHMENT;\n\t  attachmentsByFormat[DEPTH_COMPONENT] = DEPTH_ATTACHMENT;\n\t  attachmentsByFormat[DEPTH_COMPONENT16] = DEPTH_ATTACHMENT;\n\n\t  function getAttachmentPointForFormat(format) {\n\t    return attachmentsByFormat[format];\n\t  }\n\n\t  var renderbufferFormats = {};\n\t  renderbufferFormats[RGBA4] = true;\n\t  renderbufferFormats[RGB5_A1] = true;\n\t  renderbufferFormats[RGB565] = true;\n\t  renderbufferFormats[DEPTH_STENCIL] = true;\n\t  renderbufferFormats[DEPTH_COMPONENT16] = true;\n\t  renderbufferFormats[STENCIL_INDEX] = true;\n\t  renderbufferFormats[STENCIL_INDEX8] = true;\n\n\t  function isRenderbufferFormat(format) {\n\t    return renderbufferFormats[format];\n\t  }\n\n\t  /**\n\t   * @typedef {Object} FramebufferInfo\n\t   * @property {WebGLFramebuffer} framebuffer The WebGLFramebuffer for this framebufferInfo\n\t   * @property {WebGLObject[]} attachments The created attachments in the same order as passed in to {@link module:twgl.createFramebufferInfo}.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a framebuffer and attachments.\n\t   *\n\t   * This returns a {@link module:twgl.FramebufferInfo} because it needs to return the attachments as well as the framebuffer.\n\t   *\n\t   * The simplest usage\n\t   *\n\t   *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer\n\t   *     var fbi = twgl.createFramebufferInfo(gl);\n\t   *\n\t   * More complex usage\n\t   *\n\t   *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer\n\t   *     var attachments = [\n\t   *       { format: RGB565, mag: NEAREST },\n\t   *       { format: STENCIL_INDEX8 },\n\t   *     ]\n\t   *     var fbi = twgl.createFramebufferInfo(gl, attachments);\n\t   *\n\t   * Passing in a specific size\n\t   *\n\t   *     var width = 256;\n\t   *     var height = 256;\n\t   *     var fbi = twgl.createFramebufferInfo(gl, attachments, width, height);\n\t   *\n\t   * **Note!!** It is up to you to check if the framebuffer is renderable by calling `gl.checkFramebufferStatus`.\n\t   * [WebGL only guarantees 3 combinations of attachments work](https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.6).\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.AttachmentOptions[]} [attachments] which attachments to create. If not provided the default is a framebuffer with an\n\t   *    `RGBA`, `UNSIGNED_BYTE` texture `COLOR_ATTACHMENT0` and a `DEPTH_STENCIL` renderbuffer `DEPTH_STENCIL_ATTACHMENT`.\n\t   * @param {number} [width] the width for the attachments. Default = size of drawingBuffer\n\t   * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer\n\t   * @return {module:twgl.FramebufferInfo} the framebuffer and attachments.\n\t   * @memberOf module:twgl/framebuffers\n\t   */\n\t  function createFramebufferInfo(gl, attachments, width, height) {\n\t    var target = gl.FRAMEBUFFER;\n\t    var fb = gl.createFramebuffer();\n\t    gl.bindFramebuffer(target, fb);\n\t    width = width || gl.drawingBufferWidth;\n\t    height = height || gl.drawingBufferHeight;\n\t    attachments = attachments || defaultAttachments;\n\t    var colorAttachmentCount = 0;\n\t    var framebufferInfo = {\n\t      framebuffer: fb,\n\t      attachments: [],\n\t      width: width,\n\t      height: height\n\t    };\n\t    attachments.forEach(function (attachmentOptions) {\n\t      var attachment = attachmentOptions.attachment;\n\t      var format = attachmentOptions.format;\n\t      var attachmentPoint = getAttachmentPointForFormat(format);\n\t      if (!attachmentPoint) {\n\t        attachmentPoint = COLOR_ATTACHMENT0 + colorAttachmentCount++;\n\t      }\n\t      if (!attachment) {\n\t        if (isRenderbufferFormat(format)) {\n\t          attachment = gl.createRenderbuffer();\n\t          gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);\n\t          gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);\n\t        } else {\n\t          var textureOptions = utils.shallowCopy(attachmentOptions);\n\t          textureOptions.width = width;\n\t          textureOptions.height = height;\n\t          if (textureOptions.auto === undefined) {\n\t            textureOptions.auto = false;\n\t            textureOptions.min = textureOptions.min || gl.LINEAR;\n\t            textureOptions.mag = textureOptions.mag || gl.LINEAR;\n\t            textureOptions.wrapS = textureOptions.wrapS || textureOptions.wrap || gl.CLAMP_TO_EDGE;\n\t            textureOptions.wrapT = textureOptions.wrapT || textureOptions.wrap || gl.CLAMP_TO_EDGE;\n\t          }\n\t          attachment = textures.createTexture(gl, textureOptions);\n\t        }\n\t      }\n\t      if (attachment instanceof WebGLRenderbuffer) {\n\t        gl.framebufferRenderbuffer(target, attachmentPoint, gl.RENDERBUFFER, attachment);\n\t      } else if (attachment instanceof WebGLTexture) {\n\t        gl.framebufferTexture2D(target, attachmentPoint, attachmentOptions.texTarget || gl.TEXTURE_2D, attachment, attachmentOptions.level || 0);\n\t      } else {\n\t        throw \"unknown attachment type\";\n\t      }\n\t      framebufferInfo.attachments.push(attachment);\n\t    });\n\t    return framebufferInfo;\n\t  }\n\n\t  /**\n\t   * Resizes the attachments of a framebuffer.\n\t   *\n\t   * You need to pass in the same `attachments` as you passed in {@link module:twgl.createFramebufferInfo}\n\t   * because TWGL has no idea the format/type of each attachment.\n\t   *\n\t   * The simplest usage\n\t   *\n\t   *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer\n\t   *     var fbi = twgl.createFramebufferInfo(gl);\n\t   *\n\t   *     ...\n\t   *\n\t   *     function render() {\n\t   *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {\n\t   *         // resize the attachments\n\t   *         twgl.resizeFramebufferInfo(gl, fbi);\n\t   *       }\n\t   *\n\t   * More complex usage\n\t   *\n\t   *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer\n\t   *     var attachments = [\n\t   *       { format: RGB565, mag: NEAREST },\n\t   *       { format: STENCIL_INDEX8 },\n\t   *     ]\n\t   *     var fbi = twgl.createFramebufferInfo(gl, attachments);\n\t   *\n\t   *     ...\n\t   *\n\t   *     function render() {\n\t   *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {\n\t   *         // resize the attachments to match\n\t   *         twgl.resizeFramebufferInfo(gl, fbi, attachments);\n\t   *       }\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.FramebufferInfo} framebufferInfo a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.\n\t   * @param {module:twgl.AttachmentOptions[]} [attachments] the same attachments options as passed to {@link module:twgl.createFramebufferInfo}.\n\t   * @param {number} [width] the width for the attachments. Default = size of drawingBuffer\n\t   * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer\n\t   * @memberOf module:twgl/framebuffers\n\t   */\n\t  function resizeFramebufferInfo(gl, framebufferInfo, attachments, width, height) {\n\t    width = width || gl.drawingBufferWidth;\n\t    height = height || gl.drawingBufferHeight;\n\t    framebufferInfo.width = width;\n\t    framebufferInfo.height = height;\n\t    attachments = attachments || defaultAttachments;\n\t    attachments.forEach(function (attachmentOptions, ndx) {\n\t      var attachment = framebufferInfo.attachments[ndx];\n\t      var format = attachmentOptions.format;\n\t      if (attachment instanceof WebGLRenderbuffer) {\n\t        gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);\n\t        gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);\n\t      } else if (attachment instanceof WebGLTexture) {\n\t        textures.resizeTexture(gl, attachment, attachmentOptions, width, height);\n\t      } else {\n\t        throw \"unknown attachment type\";\n\t      }\n\t    });\n\t  }\n\n\t  /**\n\t   * Binds a framebuffer\n\t   *\n\t   * This function pretty much soley exists because I spent hours\n\t   * trying to figure out why something I wrote wasn't working only\n\t   * to realize I forget to set the viewport dimensions.\n\t   * My hope is this function will fix that.\n\t   *\n\t   * It is effectively the same as\n\t   *\n\t   *     gl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);\n\t   *     gl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.FramebufferInfo} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.\n\t   *   If not passed will bind the canvas.\n\t   * @param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.\n\t   * @memberOf module:twgl/framebuffers\n\t   */\n\n\t  function bindFramebufferInfo(gl, framebufferInfo, target) {\n\t    target = target || gl.FRAMEBUFFER;\n\t    if (framebufferInfo) {\n\t      gl.bindFramebuffer(target, framebufferInfo.framebuffer);\n\t      gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);\n\t    } else {\n\t      gl.bindFramebuffer(target, null);\n\t      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n\t    }\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"bindFramebufferInfo\": bindFramebufferInfo,\n\t    \"createFramebufferInfo\": createFramebufferInfo,\n\t    \"resizeFramebufferInfo\": resizeFramebufferInfo\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (typedArrays, utils) {\n\t  \"use strict\";\n\n\t  /**\n\t   * Low level texture related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.textures` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/textures\n\t   */\n\n\t  // make sure we don't see a global gl\n\n\t  var gl = undefined; // eslint-disable-line\n\t  var defaults = {\n\t    textureColor: new Uint8Array([128, 192, 255, 255]),\n\t    textureOptions: {},\n\t    crossOrigin: undefined\n\t  };\n\t  var isArrayBuffer = typedArrays.isArrayBuffer;\n\n\t  // Should we make this on demand?\n\t  var ctx = document.createElement(\"canvas\").getContext(\"2d\");\n\n\t  /* PixelFormat */\n\t  var ALPHA = 0x1906;\n\t  var RGB = 0x1907;\n\t  var RGBA = 0x1908;\n\t  var LUMINANCE = 0x1909;\n\t  var LUMINANCE_ALPHA = 0x190A;\n\t  var DEPTH_COMPONENT = 0x1902;\n\t  var DEPTH_STENCIL = 0x84F9;\n\n\t  /* TextureWrapMode */\n\t  var REPEAT = 0x2901; // eslint-disable-line\n\t  var MIRRORED_REPEAT = 0x8370; // eslint-disable-line\n\n\t  /* TextureMagFilter */\n\t  var NEAREST = 0x2600; // eslint-disable-line\n\n\t  /* TextureMinFilter */\n\t  var NEAREST_MIPMAP_NEAREST = 0x2700; // eslint-disable-line\n\t  var LINEAR_MIPMAP_NEAREST = 0x2701; // eslint-disable-line\n\t  var NEAREST_MIPMAP_LINEAR = 0x2702; // eslint-disable-line\n\t  var LINEAR_MIPMAP_LINEAR = 0x2703; // eslint-disable-line\n\n\t  var R8 = 0x8229;\n\t  var R8_SNORM = 0x8F94;\n\t  var R16F = 0x822D;\n\t  var R32F = 0x822E;\n\t  var R8UI = 0x8232;\n\t  var R8I = 0x8231;\n\t  var RG16UI = 0x823A;\n\t  var RG16I = 0x8239;\n\t  var RG32UI = 0x823C;\n\t  var RG32I = 0x823B;\n\t  var RG8 = 0x822B;\n\t  var RG8_SNORM = 0x8F95;\n\t  var RG16F = 0x822F;\n\t  var RG32F = 0x8230;\n\t  var RG8UI = 0x8238;\n\t  var RG8I = 0x8237;\n\t  var R16UI = 0x8234;\n\t  var R16I = 0x8233;\n\t  var R32UI = 0x8236;\n\t  var R32I = 0x8235;\n\t  var RGB8 = 0x8051;\n\t  var SRGB8 = 0x8C41;\n\t  var RGB565 = 0x8D62;\n\t  var RGB8_SNORM = 0x8F96;\n\t  var R11F_G11F_B10F = 0x8C3A;\n\t  var RGB9_E5 = 0x8C3D;\n\t  var RGB16F = 0x881B;\n\t  var RGB32F = 0x8815;\n\t  var RGB8UI = 0x8D7D;\n\t  var RGB8I = 0x8D8F;\n\t  var RGB16UI = 0x8D77;\n\t  var RGB16I = 0x8D89;\n\t  var RGB32UI = 0x8D71;\n\t  var RGB32I = 0x8D83;\n\t  var RGBA8 = 0x8058;\n\t  var SRGB8_ALPHA8 = 0x8C43;\n\t  var RGBA8_SNORM = 0x8F97;\n\t  var RGB5_A1 = 0x8057;\n\t  var RGBA4 = 0x8056;\n\t  var RGB10_A2 = 0x8059;\n\t  var RGBA16F = 0x881A;\n\t  var RGBA32F = 0x8814;\n\t  var RGBA8UI = 0x8D7C;\n\t  var RGBA8I = 0x8D8E;\n\t  var RGB10_A2UI = 0x906F;\n\t  var RGBA16UI = 0x8D76;\n\t  var RGBA16I = 0x8D88;\n\t  var RGBA32I = 0x8D82;\n\t  var RGBA32UI = 0x8D70;\n\n\t  var DEPTH_COMPONENT16 = 0x81A5;\n\t  var DEPTH_COMPONENT24 = 0x81A6;\n\t  var DEPTH_COMPONENT32F = 0x8CAC;\n\t  var DEPTH32F_STENCIL8 = 0x8CAD;\n\t  var DEPTH24_STENCIL8 = 0x88F0;\n\n\t  /* DataType */\n\t  var BYTE = 0x1400;\n\t  var UNSIGNED_BYTE = 0x1401;\n\t  var SHORT = 0x1402;\n\t  var UNSIGNED_SHORT = 0x1403;\n\t  var INT = 0x1404;\n\t  var UNSIGNED_INT = 0x1405;\n\t  var FLOAT = 0x1406;\n\t  var UNSIGNED_SHORT_4_4_4_4 = 0x8033;\n\t  var UNSIGNED_SHORT_5_5_5_1 = 0x8034;\n\t  var UNSIGNED_SHORT_5_6_5 = 0x8363;\n\t  var HALF_FLOAT = 0x140B;\n\t  var HALF_FLOAT_OES = 0x8D61; // Thanks Khronos for making this different >:(\n\t  var UNSIGNED_INT_2_10_10_10_REV = 0x8368;\n\t  var UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;\n\t  var UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;\n\t  var FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;\n\t  var UNSIGNED_INT_24_8 = 0x84FA;\n\n\t  var RG = 0x8227;\n\t  var RG_INTEGER = 0x8228;\n\t  var RED = 0x1903;\n\t  var RED_INTEGER = 0x8D94;\n\t  var RGB_INTEGER = 0x8D98;\n\t  var RGBA_INTEGER = 0x8D99;\n\n\t  var formatInfo = {};\n\t  {\n\t    // NOTE: this is named `numColorComponents` vs `numComponents` so we can let Uglify mangle\n\t    // the name.\n\t    var f = formatInfo;\n\t    f[ALPHA] = { numColorComponents: 1 };\n\t    f[LUMINANCE] = { numColorComponents: 1 };\n\t    f[LUMINANCE_ALPHA] = { numColorComponents: 2 };\n\t    f[RGB] = { numColorComponents: 3 };\n\t    f[RGBA] = { numColorComponents: 4 };\n\t    f[RED] = { numColorComponents: 1 };\n\t    f[RED_INTEGER] = { numColorComponents: 1 };\n\t    f[RG] = { numColorComponents: 2 };\n\t    f[RG_INTEGER] = { numColorComponents: 2 };\n\t    f[RGB] = { numColorComponents: 3 };\n\t    f[RGB_INTEGER] = { numColorComponents: 3 };\n\t    f[RGBA] = { numColorComponents: 4 };\n\t    f[RGBA_INTEGER] = { numColorComponents: 4 };\n\t    f[DEPTH_COMPONENT] = { numColorComponents: 1 };\n\t    f[DEPTH_STENCIL] = { numColorComponents: 2 };\n\t  }\n\n\t  var textureInternalFormatInfo = {};\n\t  {\n\t    (function () {\n\t      // NOTE: these properties need unique names so we can let Uglify mangle the name.\n\t      var t = textureInternalFormatInfo;\n\t      // unsized formats\n\t      t[ALPHA] = { textureFormat: ALPHA, colorRenderable: true, textureFilterable: true, bytesPerElement: [1, 2, 2, 4], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT] };\n\t      t[LUMINANCE] = { textureFormat: LUMINANCE, colorRenderable: true, textureFilterable: true, bytesPerElement: [1, 2, 2, 4], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT] };\n\t      t[LUMINANCE_ALPHA] = { textureFormat: LUMINANCE_ALPHA, colorRenderable: true, textureFilterable: true, bytesPerElement: [2, 4, 4, 8], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT] };\n\t      t[RGB] = { textureFormat: RGB, colorRenderable: true, textureFilterable: true, bytesPerElement: [3, 6, 6, 12, 2], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_5_6_5] };\n\t      t[RGBA] = { textureFormat: RGBA, colorRenderable: true, textureFilterable: true, bytesPerElement: [4, 8, 8, 16, 2, 2], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1] };\n\n\t      // sized formats\n\t      t[R8] = { textureFormat: RED, colorRenderable: true, textureFilterable: true, bytesPerElement: 1, type: UNSIGNED_BYTE };\n\t      t[R8_SNORM] = { textureFormat: RED, colorRenderable: false, textureFilterable: true, bytesPerElement: 1, type: BYTE };\n\t      t[R16F] = { textureFormat: RED, colorRenderable: false, textureFilterable: true, bytesPerElement: [4, 2], type: [FLOAT, HALF_FLOAT] };\n\t      t[R32F] = { textureFormat: RED, colorRenderable: false, textureFilterable: false, bytesPerElement: 4, type: FLOAT };\n\t      t[R8UI] = { textureFormat: RED_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 1, type: UNSIGNED_BYTE };\n\t      t[R8I] = { textureFormat: RED_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 1, type: BYTE };\n\t      t[R16UI] = { textureFormat: RED_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 2, type: UNSIGNED_SHORT };\n\t      t[R16I] = { textureFormat: RED_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 2, type: SHORT };\n\t      t[R32UI] = { textureFormat: RED_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: UNSIGNED_INT };\n\t      t[R32I] = { textureFormat: RED_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: INT };\n\t      t[RG8] = { textureFormat: RG, colorRenderable: true, textureFilterable: true, bytesPerElement: 2, type: UNSIGNED_BYTE };\n\t      t[RG8_SNORM] = { textureFormat: RG, colorRenderable: false, textureFilterable: true, bytesPerElement: 2, type: BYTE };\n\t      t[RG16F] = { textureFormat: RG, colorRenderable: false, textureFilterable: true, bytesPerElement: [8, 4], type: [FLOAT, HALF_FLOAT] };\n\t      t[RG32F] = { textureFormat: RG, colorRenderable: false, textureFilterable: false, bytesPerElement: 8, type: FLOAT };\n\t      t[RG8UI] = { textureFormat: RG_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 2, type: UNSIGNED_BYTE };\n\t      t[RG8I] = { textureFormat: RG_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 2, type: BYTE };\n\t      t[RG16UI] = { textureFormat: RG_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: UNSIGNED_SHORT };\n\t      t[RG16I] = { textureFormat: RG_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: SHORT };\n\t      t[RG32UI] = { textureFormat: RG_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 8, type: UNSIGNED_INT };\n\t      t[RG32I] = { textureFormat: RG_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 8, type: INT };\n\t      t[RGB8] = { textureFormat: RGB, colorRenderable: true, textureFilterable: true, bytesPerElement: 3, type: UNSIGNED_BYTE };\n\t      t[SRGB8] = { textureFormat: RGB, colorRenderable: false, textureFilterable: true, bytesPerElement: 3, type: UNSIGNED_BYTE };\n\t      t[RGB565] = { textureFormat: RGB, colorRenderable: true, textureFilterable: true, bytesPerElement: [3, 2], type: [UNSIGNED_BYTE, UNSIGNED_SHORT_5_6_5] };\n\t      t[RGB8_SNORM] = { textureFormat: RGB, colorRenderable: false, textureFilterable: true, bytesPerElement: 3, type: BYTE };\n\t      t[R11F_G11F_B10F] = { textureFormat: RGB, colorRenderable: false, textureFilterable: true, bytesPerElement: [12, 6, 4], type: [FLOAT, HALF_FLOAT, UNSIGNED_INT_10F_11F_11F_REV] };\n\t      t[RGB9_E5] = { textureFormat: RGB, colorRenderable: false, textureFilterable: true, bytesPerElement: [12, 6, 4], type: [FLOAT, HALF_FLOAT, UNSIGNED_INT_5_9_9_9_REV] };\n\t      t[RGB16F] = { textureFormat: RGB, colorRenderable: false, textureFilterable: true, bytesPerElement: [12, 6], type: [FLOAT, HALF_FLOAT] };\n\t      t[RGB32F] = { textureFormat: RGB, colorRenderable: false, textureFilterable: false, bytesPerElement: 12, type: FLOAT };\n\t      t[RGB8UI] = { textureFormat: RGB_INTEGER, colorRenderable: false, textureFilterable: false, bytesPerElement: 3, type: UNSIGNED_BYTE };\n\t      t[RGB8I] = { textureFormat: RGB_INTEGER, colorRenderable: false, textureFilterable: false, bytesPerElement: 3, type: BYTE };\n\t      t[RGB16UI] = { textureFormat: RGB_INTEGER, colorRenderable: false, textureFilterable: false, bytesPerElement: 6, type: UNSIGNED_SHORT };\n\t      t[RGB16I] = { textureFormat: RGB_INTEGER, colorRenderable: false, textureFilterable: false, bytesPerElement: 6, type: SHORT };\n\t      t[RGB32UI] = { textureFormat: RGB_INTEGER, colorRenderable: false, textureFilterable: false, bytesPerElement: 12, type: UNSIGNED_INT };\n\t      t[RGB32I] = { textureFormat: RGB_INTEGER, colorRenderable: false, textureFilterable: false, bytesPerElement: 12, type: INT };\n\t      t[RGBA8] = { textureFormat: RGBA, colorRenderable: true, textureFilterable: true, bytesPerElement: 4, type: UNSIGNED_BYTE };\n\t      t[SRGB8_ALPHA8] = { textureFormat: RGBA, colorRenderable: true, textureFilterable: true, bytesPerElement: 4, type: UNSIGNED_BYTE };\n\t      t[RGBA8_SNORM] = { textureFormat: RGBA, colorRenderable: false, textureFilterable: true, bytesPerElement: 4, type: BYTE };\n\t      t[RGB5_A1] = { textureFormat: RGBA, colorRenderable: true, textureFilterable: true, bytesPerElement: [4, 2, 4], type: [UNSIGNED_BYTE, UNSIGNED_SHORT_5_5_5_1, UNSIGNED_INT_2_10_10_10_REV] };\n\t      t[RGBA4] = { textureFormat: RGBA, colorRenderable: true, textureFilterable: true, bytesPerElement: [4, 2], type: [UNSIGNED_BYTE, UNSIGNED_SHORT_4_4_4_4] };\n\t      t[RGB10_A2] = { textureFormat: RGBA, colorRenderable: true, textureFilterable: true, bytesPerElement: 4, type: UNSIGNED_INT_2_10_10_10_REV };\n\t      t[RGBA16F] = { textureFormat: RGBA, colorRenderable: false, textureFilterable: true, bytesPerElement: [16, 8], type: [FLOAT, HALF_FLOAT] };\n\t      t[RGBA32F] = { textureFormat: RGBA, colorRenderable: false, textureFilterable: false, bytesPerElement: 16, type: FLOAT };\n\t      t[RGBA8UI] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: UNSIGNED_BYTE };\n\t      t[RGBA8I] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: BYTE };\n\t      t[RGB10_A2UI] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: UNSIGNED_INT_2_10_10_10_REV };\n\t      t[RGBA16UI] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 8, type: UNSIGNED_SHORT };\n\t      t[RGBA16I] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 8, type: SHORT };\n\t      t[RGBA32I] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 16, type: INT };\n\t      t[RGBA32UI] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 16, type: UNSIGNED_INT };\n\t      // Sized Internal\n\t      t[DEPTH_COMPONENT16] = { textureFormat: DEPTH_COMPONENT, colorRenderable: true, textureFilterable: false, bytesPerElement: [2, 4], type: [UNSIGNED_SHORT, UNSIGNED_INT] };\n\t      t[DEPTH_COMPONENT24] = { textureFormat: DEPTH_COMPONENT, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: UNSIGNED_INT };\n\t      t[DEPTH_COMPONENT32F] = { textureFormat: DEPTH_COMPONENT, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: FLOAT };\n\t      t[DEPTH24_STENCIL8] = { textureFormat: DEPTH_STENCIL, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: UNSIGNED_INT_24_8 };\n\t      t[DEPTH32F_STENCIL8] = { textureFormat: DEPTH_STENCIL, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: FLOAT_32_UNSIGNED_INT_24_8_REV };\n\n\t      Object.keys(t).forEach(function (internalFormat) {\n\t        var info = t[internalFormat];\n\t        info.bytesPerElementMap = {};\n\t        if (Array.isArray(info.bytesPerElement)) {\n\t          info.bytesPerElement.forEach(function (bytesPerElement, ndx) {\n\t            var type = info.type[ndx];\n\t            info.bytesPerElementMap[type] = bytesPerElement;\n\t          });\n\t        } else {\n\t          var type = info.type;\n\t          info.bytesPerElementMap[type] = info.bytesPerElement;\n\t        }\n\t      });\n\t    })();\n\t  }\n\n\t  /**\n\t   * Gets the number of bytes per element for a given internalFormat / type\n\t   * @param {number} internalFormat The internalFormat parameter from texImage2D etc..\n\t   * @param {number} type The type parameter for texImage2D etc..\n\t   * @return {number} the number of bytes per element for the given internalFormat, type combo\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function getBytesPerElementForInternalFormat(internalFormat, type) {\n\t    var info = textureInternalFormatInfo[internalFormat];\n\t    if (!info) {\n\t      throw \"unknown internal format\";\n\t    }\n\t    var bytesPerElement = info.bytesPerElementMap[type];\n\t    if (bytesPerElement === undefined) {\n\t      throw \"unknown internal format\";\n\t    }\n\t    return bytesPerElement;\n\t  }\n\n\t  /**\n\t   * Gets the format for a given internalFormat\n\t   *\n\t   * @param {number} internalFormat The internal format\n\t   * @return {{format:number, type:number}} the corresponding format and type\n\t   */\n\t  function getFormatAndTypeForInternalFormat(internalFormat) {\n\t    var info = textureInternalFormatInfo[internalFormat];\n\t    if (!info) {\n\t      throw \"unknown internal format\";\n\t    }\n\t    return {\n\t      format: info.textureFormat,\n\t      type: Array.isArray(info.type) ? info.type[0] : info.type\n\t    };\n\t  }\n\n\t  /**\n\t   * Returns true if value is power of 2\n\t   * @param {number} value number to check.\n\t   * @return true if value is power of 2\n\t   */\n\t  function isPowerOf2(value) {\n\t    return (value & value - 1) === 0;\n\t  }\n\n\t  /**\n\t   * Gets whether or not we can generate mips for the given format\n\t   * @param {number} internalFormat The internalFormat parameter from texImage2D etc..\n\t   * @param {number} type The type parameter for texImage2D etc..\n\t   * @return {boolean} true if we can generate mips\n\t   */\n\t  function canGenerateMipmap(gl, width, height, internalFormat /*, type */) {\n\t    if (!utils.isWebGL2(gl)) {\n\t      return isPowerOf2(width) && isPowerOf2(height);\n\t    }\n\t    var info = textureInternalFormatInfo[internalFormat];\n\t    if (!info) {\n\t      throw \"unknown internal format\";\n\t    }\n\t    return info.colorRenderable && info.textureFilterable;\n\t  }\n\n\t  /**\n\t   * Gets whether or not we can generate mips for the given format\n\t   * @param {number} internalFormat The internalFormat parameter from texImage2D etc..\n\t   * @param {number} type The type parameter for texImage2D etc..\n\t   * @return {boolean} true if we can generate mips\n\t   */\n\t  function canFilter(internalFormat /*, type */) {\n\t    var info = textureInternalFormatInfo[internalFormat];\n\t    if (!info) {\n\t      throw \"unknown internal format\";\n\t    }\n\t    return info.textureFilterable;\n\t  }\n\n\t  /**\n\t   * Gets the number of compontents for a given image format.\n\t   * @param {number} format the format.\n\t   * @return {number} the number of components for the format.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function getNumComponentsForFormat(format) {\n\t    var info = formatInfo[format];\n\t    if (!info) {\n\t      throw \"unknown format: \" + format;\n\t    }\n\t    return info.numColorComponents;\n\t  }\n\n\t  /**\n\t   * Gets the texture type for a given array type.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @return {number} the gl texture type\n\t   */\n\t  function getTextureTypeForArrayType(gl, src, defaultType) {\n\t    if (isArrayBuffer(src)) {\n\t      return typedArrays.getGLTypeForTypedArray(src);\n\t    }\n\t    return defaultType || gl.UNSIGNED_BYTE;\n\t  }\n\n\t  function guessDimensions(gl, target, width, height, numElements) {\n\t    if (numElements % 1 !== 0) {\n\t      throw \"can't guess dimensions\";\n\t    }\n\t    if (!width && !height) {\n\t      var size = Math.sqrt(numElements / (target === gl.TEXTURE_CUBE_MAP ? 6 : 1));\n\t      if (size % 1 === 0) {\n\t        width = size;\n\t        height = size;\n\t      } else {\n\t        width = numElements;\n\t        height = 1;\n\t      }\n\t    } else if (!height) {\n\t      height = numElements / width;\n\t      if (height % 1) {\n\t        throw \"can't guess dimensions\";\n\t      }\n\t    } else if (!width) {\n\t      width = numElements / height;\n\t      if (width % 1) {\n\t        throw \"can't guess dimensions\";\n\t      }\n\t    }\n\t    return {\n\t      width: width,\n\t      height: height\n\t    };\n\t  }\n\n\t  /**\n\t   * Sets the default texture color.\n\t   *\n\t   * The default texture color is used when loading textures from\n\t   * urls. Because the URL will be loaded async we'd like to be\n\t   * able to use the texture immediately. By putting a 1x1 pixel\n\t   * color in the texture we can start using the texture before\n\t   * the URL has loaded.\n\t   *\n\t   * @param {number[]} color Array of 4 values in the range 0 to 1\n\t   * @deprecated see {@link module:twgl.setDefaults}\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setDefaultTextureColor(color) {\n\t    defaults.textureColor = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);\n\t  }\n\n\t  function setDefaults(newDefaults) {\n\t    utils.copyExistingProperties(newDefaults, defaults);\n\t    if (newDefaults.textureColor) {\n\t      setDefaultTextureColor(newDefaults.textureColor);\n\t    }\n\t  }\n\n\t  /**\n\t   * Gets a string for gl enum\n\t   *\n\t   * Note: Several enums are the same. Without more\n\t   * context (which function) it's impossible to always\n\t   * give the correct enum.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {number} value the value of the enum you want to look up.\n\t   */\n\t  var glEnumToString = function () {\n\t    var enums;\n\n\t    function init(gl) {\n\t      if (!enums) {\n\t        enums = {};\n\t        for (var key in gl) {\n\t          if (typeof gl[key] === 'number') {\n\t            enums[gl[key]] = key;\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    return function glEnumToString(gl, value) {\n\t      init(gl);\n\t      return enums[value] || \"0x\" + value.toString(16);\n\t    };\n\t  }();\n\n\t  /**\n\t   * A function to generate the source for a texture.\n\t   * @callback TextureFunc\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} options the texture options\n\t   * @return {*} Returns any of the things documentented for `src` for {@link module:twgl.TextureOptions}.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Texture options passed to most texture functions. Each function will use whatever options\n\t   * are appropriate for its needs. This lets you pass the same options to all functions.\n\t   *\n\t   * @typedef {Object} TextureOptions\n\t   * @property {number} [target] the type of texture `gl.TEXTURE_2D` or `gl.TEXTURE_CUBE_MAP`. Defaults to `gl.TEXTURE_2D`.\n\t   * @property {number} [width] the width of the texture. Only used if src is an array or typed array or null.\n\t   * @property {number} [height] the height of a texture. Only used if src is an array or typed array or null.\n\t   * @property {number} [depth] the depth of a texture. Only used if src is an array or type array or null and target is `TEXTURE_3D` .\n\t   * @property {number} [min] the min filter setting (eg. `gl.LINEAR`). Defaults to `gl.NEAREST_MIPMAP_LINEAR`\n\t   *     or if texture is not a power of 2 on both dimensions then defaults to `gl.LINEAR`.\n\t   * @property {number} [mag] the mag filter setting (eg. `gl.LINEAR`). Defaults to `gl.LINEAR`\n\t   * @property {number} [minMag] both the min and mag filter settings.\n\t   * @property {number} [internalFormat] internal format for texture. Defaults to `gl.RGBA`\n\t   * @property {number} [format] format for texture. Defaults to `gl.RGBA`.\n\t   * @property {number} [type] type for texture. Defaults to `gl.UNSIGNED_BYTE` unless `src` is ArrayBuffer. If `src`\n\t   *     is ArrayBuffer defaults to type that matches ArrayBuffer type.\n\t   * @property {number} [wrap] Texture wrapping for both S and T (and R if TEXTURE_3D or WebGLSampler). Defaults to `gl.REPEAT` for 2D unless src is WebGL1 and src not npot and `gl.CLAMP_TO_EDGE` for cube\n\t   * @property {number} [wrapS] Texture wrapping for S. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n\t   * @property {number} [wrapT] Texture wrapping for T. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n\t   * @property {number} [wrapR] Texture wrapping for R. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n\t   * @property {number} [minLod] TEXTURE_MIN_LOD setting\n\t   * @property {number} [maxLod] TEXTURE_MAX_LOD setting\n\t   * @property {number} [baseLevel] TEXTURE_BASE_LEVEL setting\n\t   * @property {number} [maxLevel] TEXTURE_MAX_LEVEL setting\n\t   * @property {number} [unpackAlignment] The `gl.UNPACK_ALIGNMENT` used when uploading an array. Defaults to 1.\n\t   * @property {number} [premultiplyAlpha] Whether or not to premultiply alpha. Defaults to whatever the current setting is.\n\t   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n\t   *     the current setting for specific textures.\n\t   * @property {number} [flipY] Whether or not to flip the texture vertically on upload. Defaults to whatever the current setting is.\n\t   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n\t   *     the current setting for specific textures.\n\t   * @property {number} [colorspaceConversion] Whether or not to let the browser do colorspace conversion of the texture on upload. Defaults to whatever the current setting is.\n\t   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n\t   *     the current setting for specific textures.\n\t   * @property {(number[]|ArrayBuffer)} color color used as temporary 1x1 pixel color for textures loaded async when src is a string.\n\t   *    If it's a JavaScript array assumes color is 0 to 1 like most GL colors as in `[1, 0, 0, 1] = red=1, green=0, blue=0, alpha=0`.\n\t   *    Defaults to `[0.5, 0.75, 1, 1]`. See {@link module:twgl.setDefaultTextureColor}. If `false` texture is set. Can be used to re-load a texture\n\t   * @property {boolean} [auto] If not `false` then texture working filtering is set automatically for non-power of 2 images and\n\t   *    mips are generated for power of 2 images.\n\t   * @property {number[]} [cubeFaceOrder] The order that cube faces are pulled out of an img or set of images. The default is\n\t   *\n\t   *     [gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n\t   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n\t   *      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n\t   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n\t   *      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n\t   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]\n\t   *\n\t   * @property {(number[]|ArrayBuffer|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement|string|string[]|module:twgl.TextureFunc)} [src] source for texture\n\t   *\n\t   *    If `string` then it's assumed to be a URL to an image. The image will be downloaded async. A usable\n\t   *    1x1 pixel texture will be returned immediatley. The texture will be updated once the image has downloaded.\n\t   *    If `target` is `gl.TEXTURE_CUBE_MAP` will attempt to divide image into 6 square pieces. 1x6, 6x1, 3x2, 2x3.\n\t   *    The pieces will be uploaded in `cubeFaceOrder`\n\t   *\n\t   *    If `string[]` then it must have 6 entries, one for each face of a cube map. Target must be `gl.TEXTURE_CUBE_MAP`.\n\t   *\n\t   *    If `HTMLElement` then it wil be used immediately to create the contents of the texture. Examples `HTMLImageElement`,\n\t   *    `HTMLCanvasElement`, `HTMLVideoElement`.\n\t   *\n\t   *    If `number[]` or `ArrayBuffer` it's assumed to be data for a texture. If `width` or `height` is\n\t   *    not specified it is guessed as follows. First the number of elements is computed by `src.length / numComponets`\n\t   *    where `numComponents` is derived from `format`. If `target` is `gl.TEXTURE_CUBE_MAP` then `numElements` is divided\n\t   *    by 6. Then\n\t   *\n\t   *    *   If neither `width` nor `height` are specified and `sqrt(numElements)` is an integer then width and height\n\t   *        are set to `sqrt(numElements)`. Otherwise `width = numElements` and `height = 1`.\n\t   *\n\t   *    *   If only one of `width` or `height` is specified then the other equals `numElements / specifiedDimension`.\n\t   *\n\t   * If `number[]` will be converted to `type`.\n\t   *\n\t   * If `src` is a function it will be called with a `WebGLRenderingContext` and these options.\n\t   * Whatever it returns is subject to these rules. So it can return a string url, an `HTMLElement`\n\t   * an array etc...\n\t   *\n\t   * If `src` is undefined then an empty texture will be created of size `width` by `height`.\n\t   *\n\t   * @property {string} [crossOrigin] What to set the crossOrigin property of images when they are downloaded.\n\t   *    default: undefined. Also see {@link module:twgl.setDefaults}.\n\t   *\n\t   * @memberOf module:twgl\n\t   */\n\n\t  // NOTE: While querying GL is considered slow it's not remotely as slow\n\t  // as uploading a texture. On top of that you're unlikely to call this in\n\t  // a perf critical loop. Even if upload a texture every frame that's unlikely\n\t  // to be more than 1 or 2 textures a frame. In other words, the benefits of\n\t  // making the API easy to use outweigh any supposed perf benefits\n\t  var lastPackState = {};\n\n\t  /**\n\t   * Saves any packing state that will be set based on the options.\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   */\n\t  function savePackState(gl, options) {\n\t    if (options.colorspaceConversion !== undefined) {\n\t      lastPackState.colorspaceConversion = gl.getParameter(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL);\n\t      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, options.colorspaceConversion);\n\t    }\n\t    if (options.premultiplyAlpha !== undefined) {\n\t      lastPackState.premultiplyAlpha = gl.getParameter(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL);\n\t      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlpha);\n\t    }\n\t    if (options.flipY !== undefined) {\n\t      lastPackState.flipY = gl.getParameter(gl.UNPACK_FLIP_Y_WEBGL);\n\t      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, options.flipY);\n\t    }\n\t  }\n\n\t  /**\n\t   * Restores any packing state that was set based on the options.\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   */\n\t  function restorePackState(gl, options) {\n\t    if (options.colorspaceConversion !== undefined) {\n\t      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, lastPackState.colorspaceConversion);\n\t    }\n\t    if (options.premultiplyAlpha !== undefined) {\n\t      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, lastPackState.premultiplyAlpha);\n\t    }\n\t    if (options.flipY !== undefined) {\n\t      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, lastPackState.flipY);\n\t    }\n\t  }\n\n\t  var WebGLSamplerCtor = window.WebGLSampler || function NotWebGLSampler() {};\n\n\t  /**\n\t   * Sets the parameters of a texture or sampler\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {number|WebGLSampler} target texture target or sampler\n\t   * @param {function()} parameteriFn texParamteri or samplerParameteri fn\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   */\n\t  function setTextureSamplerParameters(gl, target, parameteriFn, options) {\n\t    if (options.minMag) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MIN_FILTER, options.minMag);\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MAG_FILTER, options.minMag);\n\t    }\n\t    if (options.min) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MIN_FILTER, options.min);\n\t    }\n\t    if (options.mag) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MAG_FILTER, options.mag);\n\t    }\n\t    if (options.wrap) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_WRAP_S, options.wrap);\n\t      parameteriFn.call(gl, target, gl.TEXTURE_WRAP_T, options.wrap);\n\t      if (target === gl.TEXTURE_3D || target instanceof WebGLSamplerCtor) {\n\t        parameteriFn.call(gl, target, gl.TEXTURE_WRAP_R, options.wrap);\n\t      }\n\t    }\n\t    if (options.wrapR) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_WRAP_R, options.wrapR);\n\t    }\n\t    if (options.wrapS) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_WRAP_S, options.wrapS);\n\t    }\n\t    if (options.wrapT) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_WRAP_T, options.wrapT);\n\t    }\n\t    if (options.minLod) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MIN_LOD, options.minLod);\n\t    }\n\t    if (options.maxLod) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MAX_LOD, options.maxLod);\n\t    }\n\t    if (options.baseLevel) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_BASE_LEVEL, options.baseLevel);\n\t    }\n\t    if (options.maxLevel) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MAX_LEVEL, options.maxLevel);\n\t    }\n\t  }\n\n\t  /**\n\t   * Sets the texture parameters of a texture.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureParameters(gl, tex, options) {\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    setTextureSamplerParameters(gl, target, gl.texParameteri, options);\n\t  }\n\n\t  /**\n\t   * Sets the sampler parameters of a sampler.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLSampler} sampler the WebGLSampler to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setSamplerParameters(gl, sampler, options) {\n\t    setTextureSamplerParameters(gl, sampler, gl.samplerParameteri, options);\n\t  }\n\n\t  /**\n\t   * Creates a new sampler object and sets parameters.\n\t   *\n\t   * Example:\n\t   *\n\t   *      const sampler = twgl.createSampler(gl, {\n\t   *        minMag: gl.NEAREST,         // sets both TEXTURE_MIN_FILTER and TEXTURE_MAG_FILTER\n\t   *        wrap: gl.CLAMP_TO_NEAREST,  // sets both TEXTURE_WRAP_S and TEXTURE_WRAP_T and TEXTURE_WRAP_R\n\t   *      });\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per sampler.\n\t   * @return {Object.<string,WebGLSampler>} the created samplers by name\n\t   */\n\t  function createSampler(gl, options) {\n\t    var sampler = gl.createSampler();\n\t    setSamplerParameters(gl, sampler, options);\n\t    return sampler;\n\t  }\n\n\t  /**\n\t   * Creates a multiple sampler objects and sets parameters on each.\n\t   *\n\t   * Example:\n\t   *\n\t   *      const samplers = twgl.createSamplers(gl, {\n\t   *        nearest: {\n\t   *          minMag: gl.NEAREST,\n\t   *        },\n\t   *        nearestClampS: {\n\t   *          minMag: gl.NEAREST,\n\t   *          wrapS: gl.CLAMP_TO_NEAREST,\n\t   *        },\n\t   *        linear: {\n\t   *          minMag: gl.LINEAR,\n\t   *        },\n\t   *        nearestClamp: {\n\t   *          minMag: gl.NEAREST,\n\t   *          wrap: gl.CLAMP_TO_EDGE,\n\t   *        },\n\t   *        linearClamp: {\n\t   *          minMag: gl.LINEAR,\n\t   *          wrap: gl.CLAMP_TO_EDGE,\n\t   *        },\n\t   *        linearClampT: {\n\t   *          minMag: gl.LINEAR,\n\t   *          wrapT: gl.CLAMP_TO_EDGE,\n\t   *        },\n\t   *      });\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set on the sampler\n\t   */\n\t  function createSamplers(gl, samplerOptions) {\n\t    var samplers = {};\n\t    Object.keys(samplerOptions).forEach(function (name) {\n\t      samplers[name] = createSampler(gl, samplerOptions[name]);\n\t    });\n\t    return samplers;\n\t  }\n\n\t  /**\n\t   * Makes a 1x1 pixel\n\t   * If no color is passed in uses the default color which can be set by calling `setDefaultTextureColor`.\n\t   * @param {(number[]|ArrayBuffer)} [color] The color using 0-1 values\n\t   * @return {Uint8Array} Unit8Array with color.\n\t   */\n\t  function make1Pixel(color) {\n\t    color = color || defaults.textureColor;\n\t    if (isArrayBuffer(color)) {\n\t      return color;\n\t    }\n\t    return new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);\n\t  }\n\n\t  /**\n\t   * Sets filtering or generates mips for texture based on width or height\n\t   * If width or height is not passed in uses `options.width` and//or `options.height`\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @param {number} [width] width of texture\n\t   * @param {number} [height] height of texture\n\t   * @param {number} [internalFormat] The internalFormat parameter from texImage2D etc..\n\t   * @param {number} [type] The type parameter for texImage2D etc..\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureFilteringForSize(gl, tex, options, width, height, internalFormat, type) {\n\t    options = options || defaults.textureOptions;\n\t    internalFormat = internalFormat || gl.RGBA;\n\t    type = type || gl.UNSIGNED_BYTE;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    width = width || options.width;\n\t    height = height || options.height;\n\t    gl.bindTexture(target, tex);\n\t    if (canGenerateMipmap(gl, width, height, internalFormat, type)) {\n\t      gl.generateMipmap(target);\n\t    } else {\n\t      var filtering = canFilter(internalFormat, type) ? gl.LINEAR : gl.NEAREST;\n\t      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filtering);\n\t      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filtering);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t    }\n\t  }\n\n\t  /**\n\t   * Gets an array of cubemap face enums\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @return {number[]} cubemap face enums\n\t   */\n\t  function getCubeFaceOrder(gl, options) {\n\t    options = options || {};\n\t    return options.cubeFaceOrder || [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];\n\t  }\n\n\t  /**\n\t   * @typedef {Object} FaceInfo\n\t   * @property {number} face gl enum for texImage2D\n\t   * @property {number} ndx face index (0 - 5) into source data\n\t   * @ignore\n\t   */\n\n\t  /**\n\t   * Gets an array of FaceInfos\n\t   * There's a bug in some NVidia drivers that will crash the driver if\n\t   * `gl.TEXTURE_CUBE_MAP_POSITIVE_X` is not uploaded first. So, we take\n\t   * the user's desired order from his faces to WebGL and make sure we\n\t   * do the faces in WebGL order\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @return {FaceInfo[]} cubemap face infos. Arguably the `face` property of each element is redundent but\n\t   *    it's needed internally to sort the array of `ndx` properties by `face`.\n\t   */\n\t  function getCubeFacesWithNdx(gl, options) {\n\t    var faces = getCubeFaceOrder(gl, options);\n\t    // work around bug in NVidia drivers. We have to upload the first face first else the driver crashes :(\n\t    var facesWithNdx = faces.map(function (face, ndx) {\n\t      return { face: face, ndx: ndx };\n\t    });\n\t    facesWithNdx.sort(function (a, b) {\n\t      return a.face - b.face;\n\t    });\n\t    return facesWithNdx;\n\t  }\n\n\t  /**\n\t   * Set a texture from the contents of an element. Will also set\n\t   * texture filtering or generate mips based on the dimensions of the element\n\t   * unless `options.auto === false`. If `target === gl.TEXTURE_CUBE_MAP` will\n\t   * attempt to slice image into 1x6, 2x3, 3x2, or 6x1 images, one for each face.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {HTMLElement} element a canvas, img, or video element.\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   * @kind function\n\t   */\n\t  function setTextureFromElement(gl, tex, element, options) {\n\t    options = options || defaults.textureOptions;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    var width = element.width;\n\t    var height = element.height;\n\t    var internalFormat = options.internalFormat || options.format || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var format = options.format || formatType.format;\n\t    var type = options.type || formatType.type;\n\t    savePackState(gl, options);\n\t    gl.bindTexture(target, tex);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      // guess the parts\n\t      var imgWidth = element.width;\n\t      var imgHeight = element.height;\n\t      var size;\n\t      var slices;\n\t      if (imgWidth / 6 === imgHeight) {\n\t        // It's 6x1\n\t        size = imgHeight;\n\t        slices = [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0];\n\t      } else if (imgHeight / 6 === imgWidth) {\n\t        // It's 1x6\n\t        size = imgWidth;\n\t        slices = [0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5];\n\t      } else if (imgWidth / 3 === imgHeight / 2) {\n\t        // It's 3x2\n\t        size = imgWidth / 3;\n\t        slices = [0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1];\n\t      } else if (imgWidth / 2 === imgHeight / 3) {\n\t        // It's 2x3\n\t        size = imgWidth / 2;\n\t        slices = [0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2];\n\t      } else {\n\t        throw \"can't figure out cube map from element: \" + (element.src ? element.src : element.nodeName);\n\t      }\n\t      ctx.canvas.width = size;\n\t      ctx.canvas.height = size;\n\t      width = size;\n\t      height = size;\n\t      getCubeFacesWithNdx(gl, options).forEach(function (f) {\n\t        var xOffset = slices[f.ndx * 2 + 0] * size;\n\t        var yOffset = slices[f.ndx * 2 + 1] * size;\n\t        ctx.drawImage(element, xOffset, yOffset, size, size, 0, 0, size, size);\n\t        gl.texImage2D(f.face, 0, internalFormat, format, type, ctx.canvas);\n\t      });\n\t      // Free up the canvas memory\n\t      ctx.canvas.width = 1;\n\t      ctx.canvas.height = 1;\n\t    } else if (target === gl.TEXTURE_3D) {\n\t      var smallest = Math.min(element.width, element.height);\n\t      var largest = Math.max(element.width, element.height);\n\t      var depth = largest / smallest;\n\t      if (depth % 1 !== 0) {\n\t        throw \"can not compute 3D dimensions of element\";\n\t      }\n\t      var xMult = element.width === largest ? 1 : 0;\n\t      var yMult = element.height === largest ? 1 : 0;\n\t      gl.texImage3D(target, 0, internalFormat, smallest, smallest, smallest, 0, format, type, null);\n\t      // remove this is texSubImage3D gets width and height arguments\n\t      ctx.canvas.width = smallest;\n\t      ctx.canvas.height = smallest;\n\t      for (var d = 0; d < depth; ++d) {\n\t        //        gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, d * smallest);\n\t        //        gl.texSubImage3D(target, 0, 0, 0, d, format, type, element);\n\t        var srcX = d * smallest * xMult;\n\t        var srcY = d * smallest * yMult;\n\t        var srcW = smallest;\n\t        var srcH = smallest;\n\t        var dstX = 0;\n\t        var dstY = 0;\n\t        var dstW = smallest;\n\t        var dstH = smallest;\n\t        ctx.drawImage(element, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);\n\t        gl.texSubImage3D(target, 0, 0, 0, d, smallest, smallest, 1, format, type, ctx.canvas);\n\t      }\n\t      ctx.canvas.width = 0;\n\t      ctx.canvas.height = 0;\n\t      // FIX (save state)\n\t      //      gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, 0);\n\t    } else {\n\t      gl.texImage2D(target, 0, internalFormat, format, type, element);\n\t    }\n\t    restorePackState(gl, options);\n\t    if (options.auto !== false) {\n\t      setTextureFilteringForSize(gl, tex, options, width, height, internalFormat, type);\n\t    }\n\t    setTextureParameters(gl, tex, options);\n\t  }\n\n\t  function noop() {}\n\n\t  /**\n\t   * Loads an image\n\t   * @param {string} url url to image\n\t   * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null\n\t   *     if there was an error\n\t   * @return {HTMLImageElement} the image being loaded.\n\t   */\n\t  function loadImage(url, crossOrigin, callback) {\n\t    callback = callback || noop;\n\t    var img = new Image();\n\t    crossOrigin = crossOrigin !== undefined ? crossOrigin : defaults.crossOrigin;\n\t    if (crossOrigin !== undefined) {\n\t      img.crossOrigin = crossOrigin;\n\t    }\n\n\t    function clearEventHandlers() {\n\t      img.removeEventListener('error', onError); // eslint-disable-line\n\t      img.removeEventListener('load', onLoad); // eslint-disable-line\n\t      img = null;\n\t    }\n\n\t    function onError() {\n\t      var msg = \"couldn't load image: \" + url;\n\t      utils.error(msg);\n\t      callback(msg, img);\n\t      clearEventHandlers();\n\t    }\n\n\t    function onLoad() {\n\t      callback(null, img);\n\t      clearEventHandlers();\n\t    }\n\n\t    img.addEventListener('error', onError);\n\t    img.addEventListener('load', onLoad);\n\t    img.src = url;\n\t    return img;\n\t  }\n\n\t  /**\n\t   * Sets a texture to a 1x1 pixel color. If `options.color === false` is nothing happens. If it's not set\n\t   * the default texture color is used which can be set by calling `setDefaultTextureColor`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureTo1PixelColor(gl, tex, options) {\n\t    options = options || defaults.textureOptions;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    if (options.color === false) {\n\t      return;\n\t    }\n\t    // Assume it's a URL\n\t    // Put 1x1 pixels in texture. That makes it renderable immediately regardless of filtering.\n\t    var color = make1Pixel(options.color);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      for (var ii = 0; ii < 6; ++ii) {\n\t        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n\t      }\n\t    } else if (target === gl.TEXTURE_3D || target === gl.TEXTURE_2D_ARRAY) {\n\t      gl.texImage3D(target, 0, gl.RGBA, 1, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n\t    } else {\n\t      gl.texImage2D(target, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n\t    }\n\t  }\n\n\t  /**\n\t   * The src image(s) used to create a texture.\n\t   *\n\t   * When you call {@link module:twgl.createTexture} or {@link module:twgl.createTextures}\n\t   * you can pass in urls for images to load into the textures. If it's a single url\n\t   * then this will be a single HTMLImageElement. If it's an array of urls used for a cubemap\n\t   * this will be a corresponding array of images for the cubemap.\n\t   *\n\t   * @typedef {HTMLImageElement|HTMLImageElement[]} TextureSrc\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * A callback for when an image finished downloading and been uploaded into a texture\n\t   * @callback TextureReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {WebGLTexture} texture the texture.\n\t   * @param {module:twgl.TextureSrc} souce image(s) used to as the src for the texture\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * A callback for when all images have finished downloading and been uploaded into their respective textures\n\t   * @callback TexturesReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {Object.<string, WebGLTexture>} textures the created textures by name. Same as returned by {@link module:twgl.createTextures}.\n\t   * @param {Object.<string, module:twgl.TextureSrc>} sources the image(s) used for the texture by name.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * A callback for when an image finished downloading and been uploaded into a texture\n\t   * @callback CubemapReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {WebGLTexture} tex the texture.\n\t   * @param {HTMLImageElement[]} imgs the images for each face.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * A callback for when an image finished downloading and been uploaded into a texture\n\t   * @callback ThreeDReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {WebGLTexture} tex the texture.\n\t   * @param {HTMLImageElement[]} imgs the images for each slice.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Loads a texture from an image from a Url as specified in `options.src`\n\t   * If `options.color !== false` will set the texture to a 1x1 pixel color so that the texture is\n\t   * immediately useable. It will be updated with the contents of the image once the image has finished\n\t   * downloading. Filtering options will be set as approriate for image unless `options.auto === false`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.TextureReadyCallback} [callback] A function to be called when the image has finished loading. err will\n\t   *    be non null if there was an error.\n\t   * @return {HTMLImageElement} the image being downloaded.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function loadTextureFromUrl(gl, tex, options, callback) {\n\t    callback = callback || noop;\n\t    options = options || defaults.textureOptions;\n\t    setTextureTo1PixelColor(gl, tex, options);\n\t    // Because it's async we need to copy the options.\n\t    options = utils.shallowCopy(options);\n\t    var img = loadImage(options.src, options.crossOrigin, function (err, img) {\n\t      if (err) {\n\t        callback(err, tex, img);\n\t      } else {\n\t        setTextureFromElement(gl, tex, img, options);\n\t        callback(null, tex, img);\n\t      }\n\t    });\n\t    return img;\n\t  }\n\n\t  /**\n\t   * Loads a cubemap from 6 urls as specified in `options.src`. Will set the cubemap to a 1x1 pixel color\n\t   * so that it is usable immediately unless `option.color === false`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.CubemapReadyCallback} [callback] A function to be called when all the images have finished loading. err will\n\t   *    be non null if there was an error.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function loadCubemapFromUrls(gl, tex, options, callback) {\n\t    callback = callback || noop;\n\t    var urls = options.src;\n\t    if (urls.length !== 6) {\n\t      throw \"there must be 6 urls for a cubemap\";\n\t    }\n\t    var internalFormat = options.internalFormat || options.format || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var format = options.format || formatType.format;\n\t    var type = options.type || gl.UNSIGNED_BYTE;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    if (target !== gl.TEXTURE_CUBE_MAP) {\n\t      throw \"target must be TEXTURE_CUBE_MAP\";\n\t    }\n\t    setTextureTo1PixelColor(gl, tex, options);\n\t    // Because it's async we need to copy the options.\n\t    options = utils.shallowCopy(options);\n\t    var numToLoad = 6;\n\t    var errors = [];\n\t    var imgs;\n\t    var faces = getCubeFaceOrder(gl, options);\n\n\t    function uploadImg(faceTarget) {\n\t      return function (err, img) {\n\t        --numToLoad;\n\t        if (err) {\n\t          errors.push(err);\n\t        } else {\n\t          if (img.width !== img.height) {\n\t            errors.push(\"cubemap face img is not a square: \" + img.src);\n\t          } else {\n\t            savePackState(gl, options);\n\t            gl.bindTexture(target, tex);\n\n\t            // So assuming this is the first image we now have one face that's img sized\n\t            // and 5 faces that are 1x1 pixel so size the other faces\n\t            if (numToLoad === 5) {\n\t              // use the default order\n\t              getCubeFaceOrder(gl).forEach(function (otherTarget) {\n\t                // Should we re-use the same face or a color?\n\t                gl.texImage2D(otherTarget, 0, internalFormat, format, type, img);\n\t              });\n\t            } else {\n\t              gl.texImage2D(faceTarget, 0, internalFormat, format, type, img);\n\t            }\n\n\t            restorePackState(gl, options);\n\t            gl.generateMipmap(target);\n\t          }\n\t        }\n\n\t        if (numToLoad === 0) {\n\t          callback(errors.length ? errors : undefined, imgs, tex);\n\t        }\n\t      };\n\t    }\n\n\t    imgs = urls.map(function (url, ndx) {\n\t      return loadImage(url, options.crossOrigin, uploadImg(faces[ndx]));\n\t    });\n\t  }\n\n\t  /**\n\t   * Loads a 2d array or 3d texture from urls as specified in `options.src`.\n\t   * Will set the texture to a 1x1 pixel color\n\t   * so that it is usable immediately unless `option.color === false`.\n\t   *\n\t   * If the width and height is not specified the width and height of the first\n\t   * image loaded will be used. Note that since images are loaded async\n\t   * which image downloads first is unknown.\n\t   *\n\t   * If an image is not the same size as the width and height it will be scaled\n\t   * to that width and height.\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.ThreeDReadyCallback} [callback] A function to be called when all the images have finished loading. err will\n\t   *    be non null if there was an error.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function loadSlicesFromUrls(gl, tex, options, callback) {\n\t    callback = callback || noop;\n\t    var urls = options.src;\n\t    var internalFormat = options.internalFormat || options.format || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var format = options.format || formatType.format;\n\t    var type = options.type || gl.UNSIGNED_BYTE;\n\t    var target = options.target || gl.TEXTURE_2D_ARRAY;\n\t    if (target !== gl.TEXTURE_3D && target !== gl.TEXTURE_2D_ARRAY) {\n\t      throw \"target must be TEXTURE_3D or TEXTURE_2D_ARRAY\";\n\t    }\n\t    setTextureTo1PixelColor(gl, tex, options);\n\t    // Because it's async we need to copy the options.\n\t    options = utils.shallowCopy(options);\n\t    var numToLoad = urls.length;\n\t    var errors = [];\n\t    var imgs;\n\t    var width = options.width;\n\t    var height = options.height;\n\t    var depth = urls.length;\n\t    var firstImage = true;\n\n\t    function uploadImg(slice) {\n\t      return function (err, img) {\n\t        --numToLoad;\n\t        if (err) {\n\t          errors.push(err);\n\t        } else {\n\t          savePackState(gl, options);\n\t          gl.bindTexture(target, tex);\n\n\t          if (firstImage) {\n\t            firstImage = false;\n\t            width = options.width || img.width;\n\t            height = options.height || img.height;\n\t            gl.texImage3D(target, 0, internalFormat, width, height, depth, 0, format, type, null);\n\n\t            // put it in every slice otherwise some slices will be 0,0,0,0\n\t            for (var s = 0; s < depth; ++s) {\n\t              gl.texSubImage3D(target, 0, 0, 0, s, width, height, 1, format, type, img);\n\t            }\n\t          } else {\n\t            var src = img;\n\t            if (img.width !== width || img.height !== height) {\n\t              // Size the image to fix\n\t              src = ctx.canvas;\n\t              ctx.canvas.width = width;\n\t              ctx.canvas.height = height;\n\t              ctx.drawImage(img, 0, 0, width, height);\n\t            }\n\n\t            gl.texSubImage3D(target, 0, 0, 0, slice, width, height, 1, format, type, src);\n\n\t            // free the canvas memory\n\t            if (src === ctx.canvas) {\n\t              ctx.canvas.width = 0;\n\t              ctx.canvas.height = 0;\n\t            }\n\t          }\n\n\t          restorePackState(gl, options);\n\t          gl.generateMipmap(target);\n\t        }\n\n\t        if (numToLoad === 0) {\n\t          callback(errors.length ? errors : undefined, imgs, tex);\n\t        }\n\t      };\n\t    }\n\n\t    imgs = urls.map(function (url, ndx) {\n\t      return loadImage(url, options.crossOrigin, uploadImg(ndx));\n\t    });\n\t  }\n\n\t  /**\n\t   * Sets a texture from an array or typed array. If the width or height is not provided will attempt to\n\t   * guess the size. See {@link module:twgl.TextureOptions}.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {(number[]|ArrayBuffer)} src An array or typed arry with texture data.\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureFromArray(gl, tex, src, options) {\n\t    options = options || defaults.textureOptions;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    var width = options.width;\n\t    var height = options.height;\n\t    var depth = options.depth;\n\t    var internalFormat = options.internalFormat || options.format || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var format = options.format || formatType.format;\n\t    var type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);\n\t    if (!isArrayBuffer(src)) {\n\t      var Type = typedArrays.getTypedArrayTypeForGLType(type);\n\t      src = new Type(src);\n\t    } else {\n\t      if (src instanceof Uint8ClampedArray) {\n\t        src = new Uint8Array(src.buffer);\n\t      }\n\t    }\n\t    var bytesPerElement = getBytesPerElementForInternalFormat(internalFormat, type);\n\t    var numElements = src.byteLength / bytesPerElement; // TODO: check UNPACK_ALIGNMENT?\n\t    if (numElements % 1) {\n\t      throw \"length wrong size for format: \" + glEnumToString(gl, format);\n\t    }\n\t    var dimensions;\n\t    if (target === gl.TEXTURE_3D) {\n\t      if (!width && !height && !depth) {\n\t        var size = Math.cbrt(numElements);\n\t        if (size % 1 !== 0) {\n\t          throw \"can't guess cube size of array of numElements: \" + numElements;\n\t        }\n\t        width = size;\n\t        height = size;\n\t        depth = size;\n\t      } else if (width && (!height || !depth)) {\n\t        dimensions = guessDimensions(gl, target, height, depth, numElements / width);\n\t        height = dimensions.width;\n\t        depth = dimensions.height;\n\t      } else if (height && (!width || !depth)) {\n\t        dimensions = guessDimensions(gl, target, width, depth, numElements / height);\n\t        width = dimensions.width;\n\t        depth = dimensions.height;\n\t      } else {\n\t        dimensions = guessDimensions(gl, target, width, height, numElements / depth);\n\t        width = dimensions.width;\n\t        height = dimensions.height;\n\t      }\n\t    } else {\n\t      dimensions = guessDimensions(gl, target, width, height, numElements);\n\t      width = dimensions.width;\n\t      height = dimensions.height;\n\t    }\n\t    gl.pixelStorei(gl.UNPACK_ALIGNMENT, options.unpackAlignment || 1);\n\t    savePackState(gl, options);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      (function () {\n\t        var elementsPerElement = bytesPerElement / src.BYTES_PER_ELEMENT;\n\t        var faceSize = numElements / 6 * elementsPerElement;\n\n\t        getCubeFacesWithNdx(gl, options).forEach(function (f) {\n\t          var offset = faceSize * f.ndx;\n\t          var data = src.subarray(offset, offset + faceSize);\n\t          gl.texImage2D(f.face, 0, internalFormat, width, height, 0, format, type, data);\n\t        });\n\t      })();\n\t    } else if (target === gl.TEXTURE_3D) {\n\t      gl.texImage3D(target, 0, internalFormat, width, height, depth, 0, format, type, src);\n\t    } else {\n\t      gl.texImage2D(target, 0, internalFormat, width, height, 0, format, type, src);\n\t    }\n\t    restorePackState(gl, options);\n\t    return {\n\t      width: width,\n\t      height: height,\n\t      depth: depth,\n\t      type: type\n\t    };\n\t  }\n\n\t  /**\n\t   * Sets a texture with no contents of a certain size. In other words calls `gl.texImage2D` with `null`.\n\t   * You must set `options.width` and `options.height`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setEmptyTexture(gl, tex, options) {\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    var internalFormat = options.internalFormat || options.format || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var format = options.format || formatType.format;\n\t    var type = options.type || formatType.type;\n\t    savePackState(gl, options);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      for (var ii = 0; ii < 6; ++ii) {\n\t        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, internalFormat, options.width, options.height, 0, format, type, null);\n\t      }\n\t    } else if (target === gl.TEXTURE_3D) {\n\t      gl.texImage3D(target, 0, internalFormat, options.width, options.height, options.depth, 0, format, type, null);\n\t    } else {\n\t      gl.texImage2D(target, 0, internalFormat, options.width, options.height, 0, format, type, null);\n\t    }\n\t    restorePackState(gl, options);\n\t  }\n\n\t  /**\n\t   * Creates a texture based on the options passed in.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.TextureReadyCallback} [callback] A callback called when an image has been downloaded and uploaded to the texture.\n\t   * @return {WebGLTexture} the created texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function createTexture(gl, options, callback) {\n\t    callback = callback || noop;\n\t    options = options || defaults.textureOptions;\n\t    var tex = gl.createTexture();\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    var width = options.width || 1;\n\t    var height = options.height || 1;\n\t    var internalFormat = options.internalFormat || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var type = options.type || formatType.type;\n\t    gl.bindTexture(target, tex);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      // this should have been the default for CUBEMAPS :(\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t    }\n\t    var src = options.src;\n\t    if (src) {\n\t      if (typeof src === \"function\") {\n\t        src = src(gl, options);\n\t      }\n\t      if (typeof src === \"string\") {\n\t        loadTextureFromUrl(gl, tex, options, callback);\n\t      } else if (isArrayBuffer(src) || Array.isArray(src) && (typeof src[0] === 'number' || Array.isArray(src[0]) || isArrayBuffer(src[0]))) {\n\t        var dimensions = setTextureFromArray(gl, tex, src, options);\n\t        width = dimensions.width;\n\t        height = dimensions.height;\n\t        type = dimensions.type;\n\t      } else if (Array.isArray(src) && typeof src[0] === 'string') {\n\t        if (target === gl.TEXTURE_CUBE_MAP) {\n\t          loadCubemapFromUrls(gl, tex, options, callback);\n\t        } else {\n\t          loadSlicesFromUrls(gl, tex, options, callback);\n\t        }\n\t      } else if (src instanceof HTMLElement) {\n\t        setTextureFromElement(gl, tex, src, options);\n\t        width = src.width;\n\t        height = src.height;\n\t      } else {\n\t        throw \"unsupported src type\";\n\t      }\n\t    } else {\n\t      setEmptyTexture(gl, tex, options);\n\t    }\n\t    if (options.auto !== false) {\n\t      setTextureFilteringForSize(gl, tex, options, width, height, internalFormat, type);\n\t    }\n\t    setTextureParameters(gl, tex, options);\n\t    return tex;\n\t  }\n\n\t  /**\n\t   * Resizes a texture based on the options passed in.\n\t   *\n\t   * Note: This is not a generic resize anything function.\n\t   * It's mostly used by {@link module:twgl.resizeFramebufferInfo}\n\t   * It will use `options.src` if it exists to try to determine a `type`\n\t   * otherwise it will assume `gl.UNSIGNED_BYTE`. No data is provided\n\t   * for the texture. Texture parameters will be set accordingly\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the texture to resize\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {number} [width] the new width. If not passed in will use `options.width`\n\t   * @param {number} [height] the new height. If not passed in will use `options.height`\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function resizeTexture(gl, tex, options, width, height) {\n\t    width = width || options.width;\n\t    height = height || options.height;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    var internalFormat = options.internalFormat || options.format || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var format = options.format || formatType.format;\n\t    var type;\n\t    var src = options.src;\n\t    if (!src) {\n\t      type = options.type || formatType.type;\n\t    } else if (isArrayBuffer(src) || Array.isArray(src) && typeof src[0] === 'number') {\n\t      type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);\n\t    } else {\n\t      type = options.type || formatType.type;\n\t    }\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      for (var ii = 0; ii < 6; ++ii) {\n\t        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, format, width, height, 0, format, type, null);\n\t      }\n\t    } else {\n\t      gl.texImage2D(target, 0, format, width, height, 0, format, type, null);\n\t    }\n\t  }\n\n\t  /**\n\t   * Check if a src is an async request.\n\t   * if src is a string we're going to download an image\n\t   * if src is an array of strings we're going to download cubemap images\n\t   * @param {*} src The src from a TextureOptions\n\t   * @returns {bool} true if src is async.\n\t   */\n\t  function isAsyncSrc(src) {\n\t    return typeof src === 'string' || Array.isArray(src) && typeof src[0] === 'string';\n\t  }\n\n\t  /**\n\t   * Creates a bunch of textures based on the passed in options.\n\t   *\n\t   * Example:\n\t   *\n\t   *     var textures = twgl.createTextures(gl, {\n\t   *       // a power of 2 image\n\t   *       hftIcon: { src: \"images/hft-icon-16.png\", mag: gl.NEAREST },\n\t   *       // a non-power of 2 image\n\t   *       clover: { src: \"images/clover.jpg\" },\n\t   *       // From a canvas\n\t   *       fromCanvas: { src: ctx.canvas },\n\t   *       // A cubemap from 6 images\n\t   *       yokohama: {\n\t   *         target: gl.TEXTURE_CUBE_MAP,\n\t   *         src: [\n\t   *           'images/yokohama/posx.jpg',\n\t   *           'images/yokohama/negx.jpg',\n\t   *           'images/yokohama/posy.jpg',\n\t   *           'images/yokohama/negy.jpg',\n\t   *           'images/yokohama/posz.jpg',\n\t   *           'images/yokohama/negz.jpg',\n\t   *         ],\n\t   *       },\n\t   *       // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)\n\t   *       goldengate: {\n\t   *         target: gl.TEXTURE_CUBE_MAP,\n\t   *         src: 'images/goldengate.jpg',\n\t   *       },\n\t   *       // A 2x2 pixel texture from a JavaScript array\n\t   *       checker: {\n\t   *         mag: gl.NEAREST,\n\t   *         min: gl.LINEAR,\n\t   *         src: [\n\t   *           255,255,255,255,\n\t   *           192,192,192,255,\n\t   *           192,192,192,255,\n\t   *           255,255,255,255,\n\t   *         ],\n\t   *       },\n\t   *       // a 1x2 pixel texture from a typed array.\n\t   *       stripe: {\n\t   *         mag: gl.NEAREST,\n\t   *         min: gl.LINEAR,\n\t   *         format: gl.LUMINANCE,\n\t   *         src: new Uint8Array([\n\t   *           255,\n\t   *           128,\n\t   *           255,\n\t   *           128,\n\t   *           255,\n\t   *           128,\n\t   *           255,\n\t   *           128,\n\t   *         ]),\n\t   *         width: 1,\n\t   *       },\n\t   *     });\n\t   *\n\t   * Now\n\t   *\n\t   * *   `textures.hftIcon` will be a 2d texture\n\t   * *   `textures.clover` will be a 2d texture\n\t   * *   `textures.fromCanvas` will be a 2d texture\n\t   * *   `textures.yohohama` will be a cubemap texture\n\t   * *   `textures.goldengate` will be a cubemap texture\n\t   * *   `textures.checker` will be a 2d texture\n\t   * *   `textures.stripe` will be a 2d texture\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per texture.\n\t   * @param {module:twgl.TexturesReadyCallback} [callback] A callback called when all textures have been downloaded.\n\t   * @return {Object.<string,WebGLTexture>} the created textures by name\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function createTextures(gl, textureOptions, callback) {\n\t    callback = callback || noop;\n\t    var numDownloading = 0;\n\t    var errors = [];\n\t    var textures = {};\n\t    var images = {};\n\n\t    function callCallbackIfReady() {\n\t      if (numDownloading === 0) {\n\t        setTimeout(function () {\n\t          callback(errors.length ? errors : undefined, textures, images);\n\t        }, 0);\n\t      }\n\t    }\n\n\t    Object.keys(textureOptions).forEach(function (name) {\n\t      var options = textureOptions[name];\n\t      var onLoadFn;\n\t      if (isAsyncSrc(options.src)) {\n\t        onLoadFn = function onLoadFn(err, tex, img) {\n\t          images[name] = img;\n\t          --numDownloading;\n\t          if (err) {\n\t            errors.push(err);\n\t          }\n\t          callCallbackIfReady();\n\t        };\n\t        ++numDownloading;\n\t      }\n\t      textures[name] = createTexture(gl, options, onLoadFn);\n\t    });\n\n\t    // queue the callback if there are no images to download.\n\t    // We do this because if your code is structured to wait for\n\t    // images to download but then you comment out all the async\n\t    // images your code would break.\n\t    callCallbackIfReady();\n\n\t    return textures;\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"setDefaults_\": setDefaults,\n\n\t    \"createSampler\": createSampler,\n\t    \"createSamplers\": createSamplers,\n\t    \"setSamplerParameters\": setSamplerParameters,\n\n\t    \"createTexture\": createTexture,\n\t    \"setEmptyTexture\": setEmptyTexture,\n\t    \"setTextureFromArray\": setTextureFromArray,\n\t    \"loadTextureFromUrl\": loadTextureFromUrl,\n\t    \"setTextureFromElement\": setTextureFromElement,\n\t    \"setTextureFilteringForSize\": setTextureFilteringForSize,\n\t    \"setTextureParameters\": setTextureParameters,\n\t    \"setDefaultTextureColor\": setDefaultTextureColor,\n\t    \"createTextures\": createTextures,\n\t    \"resizeTexture\": resizeTexture,\n\t    \"getNumComponentsForFormat\": getNumComponentsForFormat,\n\t    \"getBytesPerElementForInternalFormat\": getBytesPerElementForInternalFormat\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (programs) {\n\t  \"use strict\";\n\n\t  /**\n\t   * vertex array object related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.attributes` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/vertexArrays\n\t   */\n\n\t  /**\n\t   * @typedef {Object} VertexArrayInfo\n\t   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n\t   * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..\n\t   * @property {WebGLVertexArrayObject} [vertexArrayObject] a vertex array object\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a VertexArrayInfo from a BufferInfo and one or more ProgramInfos\n\t   *\n\t   * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to\n\t   * {@link module:twgl:drawBufferInfo}.\n\t   *\n\t   * > **IMPORTANT:** Vertex Array Objects are **not** a direct analog for a BufferInfo. Vertex Array Objects\n\t   *   assign buffers to specific attributes at creation time. That means they can only be used with programs\n\t   *   who's attributes use the same attribute locations for the same purposes.\n\t   *\n\t   * > Bind your attribute locations by passing an array of attribute names to {@link module:twgl.createProgramInfo}\n\t   *   or use WebGL 2's GLSL ES 3's `layout(location = <num>)` to make sure locations match.\n\t   *\n\t   * also\n\t   *\n\t   * > **IMPORTANT:** After calling twgl.setBuffersAndAttribute with a BufferInfo that uses a Vertex Array Object\n\t   *   that Vertex Array Object will be bound. That means **ANY MANIPULATION OF ELEMENT_ARRAY_BUFFER or ATTRIBUTES**\n\t   *   will affect the Vertex Array Object state.\n\t   *\n\t   * > Call `gl.bindVertexArray(null)` to get back manipulating the global attributes and ELEMENT_ARRAY_BUFFER.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {module:twgl.ProgramInfo|module:twgl.ProgramInfo[]} programInfo a programInfo or array of programInfos\n\t   * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...\n\t   *\n\t   *    You need to make sure every attribute that will be used is bound. So for example assume shader 1\n\t   *    uses attributes A, B, C and shader 2 uses attributes A, B, D. If you only pass in the programInfo\n\t   *    for shader 1 then only attributes A, B, and C will have their attributes set because TWGL doesn't\n\t   *    now attribute D's location.\n\t   *\n\t   *    So, you can pass in both shader 1 and shader 2's programInfo\n\t   *\n\t   * @return {module:twgl.VertexArrayInfo} The created VertexArrayInfo\n\t   *\n\t   * @memberOf module:twgl/vertexArrays\n\t   */\n\n\t  function createVertexArrayInfo(gl, programInfos, bufferInfo) {\n\t    var vao = gl.createVertexArray();\n\t    gl.bindVertexArray(vao);\n\t    if (!programInfos.length) {\n\t      programInfos = [programInfos];\n\t    }\n\t    programInfos.forEach(function (programInfo) {\n\t      programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n\t    });\n\t    gl.bindVertexArray(null);\n\t    return {\n\t      numElements: bufferInfo.numElements,\n\t      elementType: bufferInfo.elementType,\n\t      vertexArrayObject: vao\n\t    };\n\t  }\n\n\t  /**\n\t   * Creates a vertex array object and then sets the attributes on it\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters\n\t   * @param {Object.<string, module:twgl.AttribInfo>} attribs AttribInfos mapped by attribute name.\n\t   * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices\n\t   * @memberOf module:twgl/vertexArrays\n\t   */\n\t  function createVAOAndSetAttributes(gl, setters, attribs, indices) {\n\t    var vao = gl.createVertexArray();\n\t    gl.bindVertexArray(vao);\n\t    programs.setAttributes(setters, attribs);\n\t    if (indices) {\n\t      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\t    }\n\t    // We unbind this because otherwise any change to ELEMENT_ARRAY_BUFFER\n\t    // like when creating buffers for other stuff will mess up this VAO's binding\n\t    gl.bindVertexArray(null);\n\t    return vao;\n\t  }\n\n\t  /**\n\t   * Creates a vertex array object and then sets the attributes\n\t   * on it\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {Object.<string, function>| module:twgl.ProgramInfo} programInfo as returned from createProgramInfo or Attribute setters as returned from createAttributeSetters\n\t   * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...\n\t   * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices\n\t   * @memberOf module:twgl/vertexArrays\n\t   */\n\t  function createVAOFromBufferInfo(gl, programInfo, bufferInfo) {\n\t    return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"createVertexArrayInfo\": createVertexArrayInfo,\n\t    \"createVAOAndSetAttributes\": createVAOAndSetAttributes,\n\t    \"createVAOFromBufferInfo\": createVAOFromBufferInfo\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(11)], __WEBPACK_AMD_DEFINE_RESULT__ = function (v3) {\n\t  \"use strict\";\n\n\t  /**\n\t   * 4x4 Matrix math math functions.\n\t   *\n\t   * Almost all functions take an optional `dst` argument. If it is not passed in the\n\t   * functions will create a new matrix. In other words you can do this\n\t   *\n\t   *     var mat = m4.translation([1, 2, 3]);  // Creates a new translation matrix\n\t   *\n\t   * or\n\t   *\n\t   *     var mat = m4.create();\n\t   *     m4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n\t   *\n\t   * The first style is often easier but depending on where it's used it generates garbage where\n\t   * as there is almost never allocation with the second style.\n\t   *\n\t   * It is always save to pass any matrix as the destination. So for example\n\t   *\n\t   *     var mat = m4.identity();\n\t   *     var trans = m4.translation([1, 2, 3]);\n\t   *     m4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n\t   *\n\t   * @module twgl/m4\n\t   */\n\n\t  var MatType = Float32Array;\n\n\t  var tempV3a = v3.create();\n\t  var tempV3b = v3.create();\n\t  var tempV3c = v3.create();\n\n\t  /**\n\t   * A JavaScript array with 16 values or a Float32Array with 16 values.\n\t   * When created by the library will create the default type which is `Float32Array`\n\t   * but can be set by calling {@link module:twgl/m4.setDefaultType}.\n\t   * @typedef {(number[]|Float32Array)} Mat4\n\t   * @memberOf module:twgl/m4\n\t   */\n\n\t  /**\n\t   * Sets the type this library creates for a Mat4\n\t   * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`\n\t   * @return {constructor} previous constructor for Mat4\n\t   */\n\t  function setDefaultType(ctor) {\n\t    var oldType = MatType;\n\t    MatType = ctor;\n\t    return oldType;\n\t  }\n\n\t  /**\n\t   * Negates a matrix.\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} -m.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function negate(m, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    dst[0] = -m[0];\n\t    dst[1] = -m[1];\n\t    dst[2] = -m[2];\n\t    dst[3] = -m[3];\n\t    dst[4] = -m[4];\n\t    dst[5] = -m[5];\n\t    dst[6] = -m[6];\n\t    dst[7] = -m[7];\n\t    dst[8] = -m[8];\n\t    dst[9] = -m[9];\n\t    dst[10] = -m[10];\n\t    dst[11] = -m[11];\n\t    dst[12] = -m[12];\n\t    dst[13] = -m[13];\n\t    dst[14] = -m[14];\n\t    dst[15] = -m[15];\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Copies a matrix.\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {module:twgl/m4.Mat4} [dst] The matrix.\n\t   * @return {module:twgl/m4.Mat4} A copy of m.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function copy(m, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    dst[0] = m[0];\n\t    dst[1] = m[1];\n\t    dst[2] = m[2];\n\t    dst[3] = m[3];\n\t    dst[4] = m[4];\n\t    dst[5] = m[5];\n\t    dst[6] = m[6];\n\t    dst[7] = m[7];\n\t    dst[8] = m[8];\n\t    dst[9] = m[9];\n\t    dst[10] = m[10];\n\t    dst[11] = m[11];\n\t    dst[12] = m[12];\n\t    dst[13] = m[13];\n\t    dst[14] = m[14];\n\t    dst[15] = m[15];\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Creates an n-by-n identity matrix.\n\t   *\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} An n-by-n identity matrix.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function identity(dst) {\n\t    dst = dst || new MatType(16);\n\n\t    dst[0] = 1;\n\t    dst[1] = 0;\n\t    dst[2] = 0;\n\t    dst[3] = 0;\n\t    dst[4] = 0;\n\t    dst[5] = 1;\n\t    dst[6] = 0;\n\t    dst[7] = 0;\n\t    dst[8] = 0;\n\t    dst[9] = 0;\n\t    dst[10] = 1;\n\t    dst[11] = 0;\n\t    dst[12] = 0;\n\t    dst[13] = 0;\n\t    dst[14] = 0;\n\t    dst[15] = 1;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Takes the transpose of a matrix.\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} The transpose of m.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function transpose(m, dst) {\n\t    dst = dst || new MatType(16);\n\t    if (dst === m) {\n\t      var t;\n\n\t      t = m[1];\n\t      m[1] = m[4];\n\t      m[4] = t;\n\n\t      t = m[2];\n\t      m[2] = m[8];\n\t      m[8] = t;\n\n\t      t = m[3];\n\t      m[3] = m[12];\n\t      m[12] = t;\n\n\t      t = m[6];\n\t      m[6] = m[9];\n\t      m[9] = t;\n\n\t      t = m[7];\n\t      m[7] = m[13];\n\t      m[13] = t;\n\n\t      t = m[11];\n\t      m[11] = m[14];\n\t      m[14] = t;\n\t      return dst;\n\t    }\n\n\t    var m00 = m[0 * 4 + 0];\n\t    var m01 = m[0 * 4 + 1];\n\t    var m02 = m[0 * 4 + 2];\n\t    var m03 = m[0 * 4 + 3];\n\t    var m10 = m[1 * 4 + 0];\n\t    var m11 = m[1 * 4 + 1];\n\t    var m12 = m[1 * 4 + 2];\n\t    var m13 = m[1 * 4 + 3];\n\t    var m20 = m[2 * 4 + 0];\n\t    var m21 = m[2 * 4 + 1];\n\t    var m22 = m[2 * 4 + 2];\n\t    var m23 = m[2 * 4 + 3];\n\t    var m30 = m[3 * 4 + 0];\n\t    var m31 = m[3 * 4 + 1];\n\t    var m32 = m[3 * 4 + 2];\n\t    var m33 = m[3 * 4 + 3];\n\n\t    dst[0] = m00;\n\t    dst[1] = m10;\n\t    dst[2] = m20;\n\t    dst[3] = m30;\n\t    dst[4] = m01;\n\t    dst[5] = m11;\n\t    dst[6] = m21;\n\t    dst[7] = m31;\n\t    dst[8] = m02;\n\t    dst[9] = m12;\n\t    dst[10] = m22;\n\t    dst[11] = m32;\n\t    dst[12] = m03;\n\t    dst[13] = m13;\n\t    dst[14] = m23;\n\t    dst[15] = m33;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Computes the inverse of a 4-by-4 matrix.\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} The inverse of m.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function inverse(m, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var m00 = m[0 * 4 + 0];\n\t    var m01 = m[0 * 4 + 1];\n\t    var m02 = m[0 * 4 + 2];\n\t    var m03 = m[0 * 4 + 3];\n\t    var m10 = m[1 * 4 + 0];\n\t    var m11 = m[1 * 4 + 1];\n\t    var m12 = m[1 * 4 + 2];\n\t    var m13 = m[1 * 4 + 3];\n\t    var m20 = m[2 * 4 + 0];\n\t    var m21 = m[2 * 4 + 1];\n\t    var m22 = m[2 * 4 + 2];\n\t    var m23 = m[2 * 4 + 3];\n\t    var m30 = m[3 * 4 + 0];\n\t    var m31 = m[3 * 4 + 1];\n\t    var m32 = m[3 * 4 + 2];\n\t    var m33 = m[3 * 4 + 3];\n\t    var tmp_0 = m22 * m33;\n\t    var tmp_1 = m32 * m23;\n\t    var tmp_2 = m12 * m33;\n\t    var tmp_3 = m32 * m13;\n\t    var tmp_4 = m12 * m23;\n\t    var tmp_5 = m22 * m13;\n\t    var tmp_6 = m02 * m33;\n\t    var tmp_7 = m32 * m03;\n\t    var tmp_8 = m02 * m23;\n\t    var tmp_9 = m22 * m03;\n\t    var tmp_10 = m02 * m13;\n\t    var tmp_11 = m12 * m03;\n\t    var tmp_12 = m20 * m31;\n\t    var tmp_13 = m30 * m21;\n\t    var tmp_14 = m10 * m31;\n\t    var tmp_15 = m30 * m11;\n\t    var tmp_16 = m10 * m21;\n\t    var tmp_17 = m20 * m11;\n\t    var tmp_18 = m00 * m31;\n\t    var tmp_19 = m30 * m01;\n\t    var tmp_20 = m00 * m21;\n\t    var tmp_21 = m20 * m01;\n\t    var tmp_22 = m00 * m11;\n\t    var tmp_23 = m10 * m01;\n\n\t    var t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\n\t    var t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\n\t    var t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\n\t    var t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\n\n\t    var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n\n\t    dst[0] = d * t0;\n\t    dst[1] = d * t1;\n\t    dst[2] = d * t2;\n\t    dst[3] = d * t3;\n\t    dst[4] = d * (tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30 - (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));\n\t    dst[5] = d * (tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30 - (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));\n\t    dst[6] = d * (tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30 - (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));\n\t    dst[7] = d * (tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20 - (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));\n\t    dst[8] = d * (tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33 - (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));\n\t    dst[9] = d * (tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33 - (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));\n\t    dst[10] = d * (tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33 - (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));\n\t    dst[11] = d * (tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23 - (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));\n\t    dst[12] = d * (tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12 - (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));\n\t    dst[13] = d * (tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22 - (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));\n\t    dst[14] = d * (tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02 - (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));\n\t    dst[15] = d * (tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12 - (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Multiplies two 4-by-4 matrices with a on the left and b on the right\n\t   * @param {module:twgl/m4.Mat4} a The matrix on the left.\n\t   * @param {module:twgl/m4.Mat4} b The matrix on the right.\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} The matrix product of a and b.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function multiply(a, b, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var a00 = a[0];\n\t    var a01 = a[1];\n\t    var a02 = a[2];\n\t    var a03 = a[3];\n\t    var a10 = a[4 + 0];\n\t    var a11 = a[4 + 1];\n\t    var a12 = a[4 + 2];\n\t    var a13 = a[4 + 3];\n\t    var a20 = a[8 + 0];\n\t    var a21 = a[8 + 1];\n\t    var a22 = a[8 + 2];\n\t    var a23 = a[8 + 3];\n\t    var a30 = a[12 + 0];\n\t    var a31 = a[12 + 1];\n\t    var a32 = a[12 + 2];\n\t    var a33 = a[12 + 3];\n\t    var b00 = b[0];\n\t    var b01 = b[1];\n\t    var b02 = b[2];\n\t    var b03 = b[3];\n\t    var b10 = b[4 + 0];\n\t    var b11 = b[4 + 1];\n\t    var b12 = b[4 + 2];\n\t    var b13 = b[4 + 3];\n\t    var b20 = b[8 + 0];\n\t    var b21 = b[8 + 1];\n\t    var b22 = b[8 + 2];\n\t    var b23 = b[8 + 3];\n\t    var b30 = b[12 + 0];\n\t    var b31 = b[12 + 1];\n\t    var b32 = b[12 + 2];\n\t    var b33 = b[12 + 3];\n\n\t    dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n\t    dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n\t    dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;\n\t    dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;\n\t    dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n\t    dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n\t    dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;\n\t    dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;\n\t    dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;\n\t    dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;\n\t    dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;\n\t    dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;\n\t    dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;\n\t    dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;\n\t    dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;\n\t    dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Sets the translation component of a 4-by-4 matrix to the given\n\t   * vector.\n\t   * @param {module:twgl/m4.Mat4} a The matrix.\n\t   * @param {Vec3} v The vector.\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} a once modified.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function setTranslation(a, v, dst) {\n\t    dst = dst || identity();\n\t    if (a !== dst) {\n\t      dst[0] = a[0];\n\t      dst[1] = a[1];\n\t      dst[2] = a[2];\n\t      dst[3] = a[3];\n\t      dst[4] = a[4];\n\t      dst[5] = a[5];\n\t      dst[6] = a[6];\n\t      dst[7] = a[7];\n\t      dst[8] = a[8];\n\t      dst[9] = a[9];\n\t      dst[10] = a[10];\n\t      dst[11] = a[11];\n\t    }\n\t    dst[12] = v[0];\n\t    dst[13] = v[1];\n\t    dst[14] = v[2];\n\t    dst[15] = 1;\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Returns the translation component of a 4-by-4 matrix as a vector with 3\n\t   * entries.\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {Vec3} [dst] vector..\n\t   * @return {Vec3} The translation component of m.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function getTranslation(m, dst) {\n\t    dst = dst || v3.create();\n\t    dst[0] = m[12];\n\t    dst[1] = m[13];\n\t    dst[2] = m[14];\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Returns an axis of a 4x4 matrix as a vector with 3 entries\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {number} axis The axis 0 = x, 1 = y, 2 = z;\n\t   * @return {Vec3} [dst] vector.\n\t   * @return {Vec3} The axis component of m.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function getAxis(m, axis, dst) {\n\t    dst = dst || v3.create();\n\t    var off = axis * 4;\n\t    dst[0] = m[off + 0];\n\t    dst[1] = m[off + 1];\n\t    dst[2] = m[off + 2];\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Sets an axis of a 4x4 matrix as a vector with 3 entries\n\t   * @param {Vec3} v the axis vector\n\t   * @param {number} axis The axis  0 = x, 1 = y, 2 = z;\n\t   * @param {module:twgl/m4.Mat4} [dst] The matrix to set. If none a new one is created\n\t   * @return {module:twgl/m4.Mat4} dst\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function setAxis(a, v, axis, dst) {\n\t    if (dst !== a) {\n\t      dst = copy(a, dst);\n\t    }\n\t    var off = axis * 4;\n\t    dst[off + 0] = v[0];\n\t    dst[off + 1] = v[1];\n\t    dst[off + 2] = v[2];\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Computes a 4-by-4 perspective transformation matrix given the angular height\n\t   * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n\t   * arguments define a frustum extending in the negative z direction.  The given\n\t   * angle is the vertical angle of the frustum, and the horizontal angle is\n\t   * determined to produce the given aspect ratio.  The arguments near and far are\n\t   * the distances to the near and far clipping planes.  Note that near and far\n\t   * are not z coordinates, but rather they are distances along the negative\n\t   * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n\t   * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n\t   * from 0 to 1 in the z dimension.\n\t   * @param {number} fieldOfViewYInRadians The camera angle from top to bottom (in radians).\n\t   * @param {number} aspect The aspect ratio width / height.\n\t   * @param {number} zNear The depth (negative z coordinate)\n\t   *     of the near clipping plane.\n\t   * @param {number} zFar The depth (negative z coordinate)\n\t   *     of the far clipping plane.\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} The perspective matrix.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);\n\t    var rangeInv = 1.0 / (zNear - zFar);\n\n\t    dst[0] = f / aspect;\n\t    dst[1] = 0;\n\t    dst[2] = 0;\n\t    dst[3] = 0;\n\n\t    dst[4] = 0;\n\t    dst[5] = f;\n\t    dst[6] = 0;\n\t    dst[7] = 0;\n\n\t    dst[8] = 0;\n\t    dst[9] = 0;\n\t    dst[10] = (zNear + zFar) * rangeInv;\n\t    dst[11] = -1;\n\n\t    dst[12] = 0;\n\t    dst[13] = 0;\n\t    dst[14] = zNear * zFar * rangeInv * 2;\n\t    dst[15] = 0;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Computes a 4-by-4 othogonal transformation matrix given the left, right,\n\t   * bottom, and top dimensions of the near clipping plane as well as the\n\t   * near and far clipping plane distances.\n\t   * @param {number} left Left side of the near clipping plane viewport.\n\t   * @param {number} right Right side of the near clipping plane viewport.\n\t   * @param {number} top Top of the near clipping plane viewport.\n\t   * @param {number} bottom Bottom of the near clipping plane viewport.\n\t   * @param {number} near The depth (negative z coordinate)\n\t   *     of the near clipping plane.\n\t   * @param {number} far The depth (negative z coordinate)\n\t   *     of the far clipping plane.\n\t   * @param {module:twgl/m4.Mat4} [dst] Output matrix.\n\t   * @return {module:twgl/m4.Mat4} The perspective matrix.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function ortho(left, right, bottom, top, near, far, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    dst[0] = 2 / (right - left);\n\t    dst[1] = 0;\n\t    dst[2] = 0;\n\t    dst[3] = 0;\n\n\t    dst[4] = 0;\n\t    dst[5] = 2 / (top - bottom);\n\t    dst[6] = 0;\n\t    dst[7] = 0;\n\n\t    dst[8] = 0;\n\t    dst[9] = 0;\n\t    dst[10] = -1 / (far - near);\n\t    dst[11] = 0;\n\n\t    dst[12] = (right + left) / (left - right);\n\t    dst[13] = (top + bottom) / (bottom - top);\n\t    dst[14] = -near / (near - far);\n\t    dst[15] = 1;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Computes a 4-by-4 perspective transformation matrix given the left, right,\n\t   * top, bottom, near and far clipping planes. The arguments define a frustum\n\t   * extending in the negative z direction. The arguments near and far are the\n\t   * distances to the near and far clipping planes. Note that near and far are not\n\t   * z coordinates, but rather they are distances along the negative z-axis. The\n\t   * matrix generated sends the viewing frustum to the unit box. We assume a unit\n\t   * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z\n\t   * dimension.\n\t   * @param {number} left The x coordinate of the left plane of the box.\n\t   * @param {number} right The x coordinate of the right plane of the box.\n\t   * @param {number} bottom The y coordinate of the bottom plane of the box.\n\t   * @param {number} top The y coordinate of the right plane of the box.\n\t   * @param {number} near The negative z coordinate of the near plane of the box.\n\t   * @param {number} far The negative z coordinate of the far plane of the box.\n\t   * @param {module:twgl/m4.Mat4} [dst] Output matrix.\n\t   * @return {module:twgl/m4.Mat4} The perspective projection matrix.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function frustum(left, right, bottom, top, near, far, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var dx = right - left;\n\t    var dy = top - bottom;\n\t    var dz = near - far;\n\n\t    dst[0] = 2 * near / dx;\n\t    dst[1] = 0;\n\t    dst[2] = 0;\n\t    dst[3] = 0;\n\t    dst[4] = 0;\n\t    dst[5] = 2 * near / dy;\n\t    dst[6] = 0;\n\t    dst[7] = 0;\n\t    dst[8] = (left + right) / dx;\n\t    dst[9] = (top + bottom) / dy;\n\t    dst[10] = far / dz;\n\t    dst[11] = -1;\n\t    dst[12] = 0;\n\t    dst[13] = 0;\n\t    dst[14] = near * far / dz;\n\t    dst[15] = 0;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Computes a 4-by-4 look-at transformation.\n\t   *\n\t   * This is a matrix which positions the camera itself. If you want\n\t   * a view matrix (a matrix which moves things in front of the camera)\n\t   * take the inverse of this.\n\t   *\n\t   * @param {Vec3} eye The position of the eye.\n\t   * @param {Vec3} target The position meant to be viewed.\n\t   * @param {Vec3} up A vector pointing up.\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} The look-at matrix.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function lookAt(eye, target, up, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var xAxis = tempV3a;\n\t    var yAxis = tempV3b;\n\t    var zAxis = tempV3c;\n\n\t    v3.normalize(v3.subtract(eye, target, zAxis), zAxis);\n\t    v3.normalize(v3.cross(up, zAxis, xAxis), xAxis);\n\t    v3.normalize(v3.cross(zAxis, xAxis, yAxis), yAxis);\n\n\t    dst[0] = xAxis[0];\n\t    dst[1] = xAxis[1];\n\t    dst[2] = xAxis[2];\n\t    dst[3] = 0;\n\t    dst[4] = yAxis[0];\n\t    dst[5] = yAxis[1];\n\t    dst[6] = yAxis[2];\n\t    dst[7] = 0;\n\t    dst[8] = zAxis[0];\n\t    dst[9] = zAxis[1];\n\t    dst[10] = zAxis[2];\n\t    dst[11] = 0;\n\t    dst[12] = eye[0];\n\t    dst[13] = eye[1];\n\t    dst[14] = eye[2];\n\t    dst[15] = 1;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Creates a 4-by-4 matrix which translates by the given vector v.\n\t   * @param {Vec3} v The vector by\n\t   *     which to translate.\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} The translation matrix.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function translation(v, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    dst[0] = 1;\n\t    dst[1] = 0;\n\t    dst[2] = 0;\n\t    dst[3] = 0;\n\t    dst[4] = 0;\n\t    dst[5] = 1;\n\t    dst[6] = 0;\n\t    dst[7] = 0;\n\t    dst[8] = 0;\n\t    dst[9] = 0;\n\t    dst[10] = 1;\n\t    dst[11] = 0;\n\t    dst[12] = v[0];\n\t    dst[13] = v[1];\n\t    dst[14] = v[2];\n\t    dst[15] = 1;\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Modifies the given 4-by-4 matrix by translation by the given vector v.\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {Vec3} v The vector by\n\t   *     which to translate.\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} m once modified.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function translate(m, v, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var v0 = v[0];\n\t    var v1 = v[1];\n\t    var v2 = v[2];\n\t    var m00 = m[0];\n\t    var m01 = m[1];\n\t    var m02 = m[2];\n\t    var m03 = m[3];\n\t    var m10 = m[1 * 4 + 0];\n\t    var m11 = m[1 * 4 + 1];\n\t    var m12 = m[1 * 4 + 2];\n\t    var m13 = m[1 * 4 + 3];\n\t    var m20 = m[2 * 4 + 0];\n\t    var m21 = m[2 * 4 + 1];\n\t    var m22 = m[2 * 4 + 2];\n\t    var m23 = m[2 * 4 + 3];\n\t    var m30 = m[3 * 4 + 0];\n\t    var m31 = m[3 * 4 + 1];\n\t    var m32 = m[3 * 4 + 2];\n\t    var m33 = m[3 * 4 + 3];\n\n\t    if (m !== dst) {\n\t      dst[0] = m00;\n\t      dst[1] = m01;\n\t      dst[2] = m02;\n\t      dst[3] = m03;\n\t      dst[4] = m10;\n\t      dst[5] = m11;\n\t      dst[6] = m12;\n\t      dst[7] = m13;\n\t      dst[8] = m20;\n\t      dst[9] = m21;\n\t      dst[10] = m22;\n\t      dst[11] = m23;\n\t    }\n\n\t    dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;\n\t    dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;\n\t    dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;\n\t    dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.\n\t   * @param {number} angleInRadians The angle by which to rotate (in radians).\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} The rotation matrix.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function rotationX(angleInRadians, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var c = Math.cos(angleInRadians);\n\t    var s = Math.sin(angleInRadians);\n\n\t    dst[0] = 1;\n\t    dst[1] = 0;\n\t    dst[2] = 0;\n\t    dst[3] = 0;\n\t    dst[4] = 0;\n\t    dst[5] = c;\n\t    dst[6] = s;\n\t    dst[7] = 0;\n\t    dst[8] = 0;\n\t    dst[9] = -s;\n\t    dst[10] = c;\n\t    dst[11] = 0;\n\t    dst[12] = 0;\n\t    dst[13] = 0;\n\t    dst[14] = 0;\n\t    dst[15] = 1;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Modifies the given 4-by-4 matrix by a rotation around the x-axis by the given\n\t   * angle.\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {number} angleInRadians The angle by which to rotate (in radians).\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} m once modified.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function rotateX(m, angleInRadians, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var m10 = m[4];\n\t    var m11 = m[5];\n\t    var m12 = m[6];\n\t    var m13 = m[7];\n\t    var m20 = m[8];\n\t    var m21 = m[9];\n\t    var m22 = m[10];\n\t    var m23 = m[11];\n\t    var c = Math.cos(angleInRadians);\n\t    var s = Math.sin(angleInRadians);\n\n\t    dst[4] = c * m10 + s * m20;\n\t    dst[5] = c * m11 + s * m21;\n\t    dst[6] = c * m12 + s * m22;\n\t    dst[7] = c * m13 + s * m23;\n\t    dst[8] = c * m20 - s * m10;\n\t    dst[9] = c * m21 - s * m11;\n\t    dst[10] = c * m22 - s * m12;\n\t    dst[11] = c * m23 - s * m13;\n\n\t    if (m !== dst) {\n\t      dst[0] = m[0];\n\t      dst[1] = m[1];\n\t      dst[2] = m[2];\n\t      dst[3] = m[3];\n\t      dst[12] = m[12];\n\t      dst[13] = m[13];\n\t      dst[14] = m[14];\n\t      dst[15] = m[15];\n\t    }\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.\n\t   * @param {number} angleInRadians The angle by which to rotate (in radians).\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} The rotation matrix.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function rotationY(angleInRadians, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var c = Math.cos(angleInRadians);\n\t    var s = Math.sin(angleInRadians);\n\n\t    dst[0] = c;\n\t    dst[1] = 0;\n\t    dst[2] = -s;\n\t    dst[3] = 0;\n\t    dst[4] = 0;\n\t    dst[5] = 1;\n\t    dst[6] = 0;\n\t    dst[7] = 0;\n\t    dst[8] = s;\n\t    dst[9] = 0;\n\t    dst[10] = c;\n\t    dst[11] = 0;\n\t    dst[12] = 0;\n\t    dst[13] = 0;\n\t    dst[14] = 0;\n\t    dst[15] = 1;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Modifies the given 4-by-4 matrix by a rotation around the y-axis by the given\n\t   * angle.\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {number} angleInRadians The angle by which to rotate (in radians).\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} m once modified.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function rotateY(m, angleInRadians, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var m00 = m[0 * 4 + 0];\n\t    var m01 = m[0 * 4 + 1];\n\t    var m02 = m[0 * 4 + 2];\n\t    var m03 = m[0 * 4 + 3];\n\t    var m20 = m[2 * 4 + 0];\n\t    var m21 = m[2 * 4 + 1];\n\t    var m22 = m[2 * 4 + 2];\n\t    var m23 = m[2 * 4 + 3];\n\t    var c = Math.cos(angleInRadians);\n\t    var s = Math.sin(angleInRadians);\n\n\t    dst[0] = c * m00 - s * m20;\n\t    dst[1] = c * m01 - s * m21;\n\t    dst[2] = c * m02 - s * m22;\n\t    dst[3] = c * m03 - s * m23;\n\t    dst[8] = c * m20 + s * m00;\n\t    dst[9] = c * m21 + s * m01;\n\t    dst[10] = c * m22 + s * m02;\n\t    dst[11] = c * m23 + s * m03;\n\n\t    if (m !== dst) {\n\t      dst[4] = m[4];\n\t      dst[5] = m[5];\n\t      dst[6] = m[6];\n\t      dst[7] = m[7];\n\t      dst[12] = m[12];\n\t      dst[13] = m[13];\n\t      dst[14] = m[14];\n\t      dst[15] = m[15];\n\t    }\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.\n\t   * @param {number} angleInRadians The angle by which to rotate (in radians).\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} The rotation matrix.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function rotationZ(angleInRadians, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var c = Math.cos(angleInRadians);\n\t    var s = Math.sin(angleInRadians);\n\n\t    dst[0] = c;\n\t    dst[1] = s;\n\t    dst[2] = 0;\n\t    dst[3] = 0;\n\t    dst[4] = -s;\n\t    dst[5] = c;\n\t    dst[6] = 0;\n\t    dst[7] = 0;\n\t    dst[8] = 0;\n\t    dst[9] = 0;\n\t    dst[10] = 1;\n\t    dst[11] = 0;\n\t    dst[12] = 0;\n\t    dst[13] = 0;\n\t    dst[14] = 0;\n\t    dst[15] = 1;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Modifies the given 4-by-4 matrix by a rotation around the z-axis by the given\n\t   * angle.\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {number} angleInRadians The angle by which to rotate (in radians).\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} m once modified.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function rotateZ(m, angleInRadians, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var m00 = m[0 * 4 + 0];\n\t    var m01 = m[0 * 4 + 1];\n\t    var m02 = m[0 * 4 + 2];\n\t    var m03 = m[0 * 4 + 3];\n\t    var m10 = m[1 * 4 + 0];\n\t    var m11 = m[1 * 4 + 1];\n\t    var m12 = m[1 * 4 + 2];\n\t    var m13 = m[1 * 4 + 3];\n\t    var c = Math.cos(angleInRadians);\n\t    var s = Math.sin(angleInRadians);\n\n\t    dst[0] = c * m00 + s * m10;\n\t    dst[1] = c * m01 + s * m11;\n\t    dst[2] = c * m02 + s * m12;\n\t    dst[3] = c * m03 + s * m13;\n\t    dst[4] = c * m10 - s * m00;\n\t    dst[5] = c * m11 - s * m01;\n\t    dst[6] = c * m12 - s * m02;\n\t    dst[7] = c * m13 - s * m03;\n\n\t    if (m !== dst) {\n\t      dst[8] = m[8];\n\t      dst[9] = m[9];\n\t      dst[10] = m[10];\n\t      dst[11] = m[11];\n\t      dst[12] = m[12];\n\t      dst[13] = m[13];\n\t      dst[14] = m[14];\n\t      dst[15] = m[15];\n\t    }\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Creates a 4-by-4 matrix which rotates around the given axis by the given\n\t   * angle.\n\t   * @param {Vec3} axis The axis\n\t   *     about which to rotate.\n\t   * @param {number} angleInRadians The angle by which to rotate (in radians).\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} A matrix which rotates angle radians\n\t   *     around the axis.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function axisRotation(axis, angleInRadians, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var x = axis[0];\n\t    var y = axis[1];\n\t    var z = axis[2];\n\t    var n = Math.sqrt(x * x + y * y + z * z);\n\t    x /= n;\n\t    y /= n;\n\t    z /= n;\n\t    var xx = x * x;\n\t    var yy = y * y;\n\t    var zz = z * z;\n\t    var c = Math.cos(angleInRadians);\n\t    var s = Math.sin(angleInRadians);\n\t    var oneMinusCosine = 1 - c;\n\n\t    dst[0] = xx + (1 - xx) * c;\n\t    dst[1] = x * y * oneMinusCosine + z * s;\n\t    dst[2] = x * z * oneMinusCosine - y * s;\n\t    dst[3] = 0;\n\t    dst[4] = x * y * oneMinusCosine - z * s;\n\t    dst[5] = yy + (1 - yy) * c;\n\t    dst[6] = y * z * oneMinusCosine + x * s;\n\t    dst[7] = 0;\n\t    dst[8] = x * z * oneMinusCosine + y * s;\n\t    dst[9] = y * z * oneMinusCosine - x * s;\n\t    dst[10] = zz + (1 - zz) * c;\n\t    dst[11] = 0;\n\t    dst[12] = 0;\n\t    dst[13] = 0;\n\t    dst[14] = 0;\n\t    dst[15] = 1;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Modifies the given 4-by-4 matrix by rotation around the given axis by the\n\t   * given angle.\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {Vec3} axis The axis\n\t   *     about which to rotate.\n\t   * @param {number} angleInRadians The angle by which to rotate (in radians).\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} m once modified.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function axisRotate(m, axis, angleInRadians, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var x = axis[0];\n\t    var y = axis[1];\n\t    var z = axis[2];\n\t    var n = Math.sqrt(x * x + y * y + z * z);\n\t    x /= n;\n\t    y /= n;\n\t    z /= n;\n\t    var xx = x * x;\n\t    var yy = y * y;\n\t    var zz = z * z;\n\t    var c = Math.cos(angleInRadians);\n\t    var s = Math.sin(angleInRadians);\n\t    var oneMinusCosine = 1 - c;\n\n\t    var r00 = xx + (1 - xx) * c;\n\t    var r01 = x * y * oneMinusCosine + z * s;\n\t    var r02 = x * z * oneMinusCosine - y * s;\n\t    var r10 = x * y * oneMinusCosine - z * s;\n\t    var r11 = yy + (1 - yy) * c;\n\t    var r12 = y * z * oneMinusCosine + x * s;\n\t    var r20 = x * z * oneMinusCosine + y * s;\n\t    var r21 = y * z * oneMinusCosine - x * s;\n\t    var r22 = zz + (1 - zz) * c;\n\n\t    var m00 = m[0];\n\t    var m01 = m[1];\n\t    var m02 = m[2];\n\t    var m03 = m[3];\n\t    var m10 = m[4];\n\t    var m11 = m[5];\n\t    var m12 = m[6];\n\t    var m13 = m[7];\n\t    var m20 = m[8];\n\t    var m21 = m[9];\n\t    var m22 = m[10];\n\t    var m23 = m[11];\n\n\t    dst[0] = r00 * m00 + r01 * m10 + r02 * m20;\n\t    dst[1] = r00 * m01 + r01 * m11 + r02 * m21;\n\t    dst[2] = r00 * m02 + r01 * m12 + r02 * m22;\n\t    dst[3] = r00 * m03 + r01 * m13 + r02 * m23;\n\t    dst[4] = r10 * m00 + r11 * m10 + r12 * m20;\n\t    dst[5] = r10 * m01 + r11 * m11 + r12 * m21;\n\t    dst[6] = r10 * m02 + r11 * m12 + r12 * m22;\n\t    dst[7] = r10 * m03 + r11 * m13 + r12 * m23;\n\t    dst[8] = r20 * m00 + r21 * m10 + r22 * m20;\n\t    dst[9] = r20 * m01 + r21 * m11 + r22 * m21;\n\t    dst[10] = r20 * m02 + r21 * m12 + r22 * m22;\n\t    dst[11] = r20 * m03 + r21 * m13 + r22 * m23;\n\n\t    if (m !== dst) {\n\t      dst[12] = m[12];\n\t      dst[13] = m[13];\n\t      dst[14] = m[14];\n\t      dst[15] = m[15];\n\t    }\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Creates a 4-by-4 matrix which scales in each dimension by an amount given by\n\t   * the corresponding entry in the given vector; assumes the vector has three\n\t   * entries.\n\t   * @param {Vec3} v A vector of\n\t   *     three entries specifying the factor by which to scale in each dimension.\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} The scaling matrix.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function scaling(v, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    dst[0] = v[0];\n\t    dst[1] = 0;\n\t    dst[2] = 0;\n\t    dst[3] = 0;\n\t    dst[4] = 0;\n\t    dst[5] = v[1];\n\t    dst[6] = 0;\n\t    dst[7] = 0;\n\t    dst[8] = 0;\n\t    dst[9] = 0;\n\t    dst[10] = v[2];\n\t    dst[11] = 0;\n\t    dst[12] = 0;\n\t    dst[13] = 0;\n\t    dst[14] = 0;\n\t    dst[15] = 1;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Modifies the given 4-by-4 matrix, scaling in each dimension by an amount\n\t   * given by the corresponding entry in the given vector; assumes the vector has\n\t   * three entries.\n\t   * @param {module:twgl/m4.Mat4} m The matrix to be modified.\n\t   * @param {Vec3} v A vector of three entries specifying the\n\t   *     factor by which to scale in each dimension.\n\t   * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..\n\t   * @return {module:twgl/m4.Mat4} m once modified.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function scale(m, v, dst) {\n\t    dst = dst || new MatType(16);\n\n\t    var v0 = v[0];\n\t    var v1 = v[1];\n\t    var v2 = v[2];\n\n\t    dst[0] = v0 * m[0 * 4 + 0];\n\t    dst[1] = v0 * m[0 * 4 + 1];\n\t    dst[2] = v0 * m[0 * 4 + 2];\n\t    dst[3] = v0 * m[0 * 4 + 3];\n\t    dst[4] = v1 * m[1 * 4 + 0];\n\t    dst[5] = v1 * m[1 * 4 + 1];\n\t    dst[6] = v1 * m[1 * 4 + 2];\n\t    dst[7] = v1 * m[1 * 4 + 3];\n\t    dst[8] = v2 * m[2 * 4 + 0];\n\t    dst[9] = v2 * m[2 * 4 + 1];\n\t    dst[10] = v2 * m[2 * 4 + 2];\n\t    dst[11] = v2 * m[2 * 4 + 3];\n\n\t    if (m !== dst) {\n\t      dst[12] = m[12];\n\t      dst[13] = m[13];\n\t      dst[14] = m[14];\n\t      dst[15] = m[15];\n\t    }\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Takes a 4-by-4 matrix and a vector with 3 entries,\n\t   * interprets the vector as a point, transforms that point by the matrix, and\n\t   * returns the result as a vector with 3 entries.\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {Vec3} v The point.\n\t   * @param {Vec3} dst optional vec3 to store result\n\t   * @return {Vec3} dst or new vec3 if not provided\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function transformPoint(m, v, dst) {\n\t    dst = dst || v3.create();\n\t    var v0 = v[0];\n\t    var v1 = v[1];\n\t    var v2 = v[2];\n\t    var d = v0 * m[0 * 4 + 3] + v1 * m[1 * 4 + 3] + v2 * m[2 * 4 + 3] + m[3 * 4 + 3];\n\n\t    dst[0] = (v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0] + m[3 * 4 + 0]) / d;\n\t    dst[1] = (v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1] + m[3 * 4 + 1]) / d;\n\t    dst[2] = (v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2] + m[3 * 4 + 2]) / d;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Takes a 4-by-4 matrix and a vector with 3 entries, interprets the vector as a\n\t   * direction, transforms that direction by the matrix, and returns the result;\n\t   * assumes the transformation of 3-dimensional space represented by the matrix\n\t   * is parallel-preserving, i.e. any combination of rotation, scaling and\n\t   * translation, but not a perspective distortion. Returns a vector with 3\n\t   * entries.\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {Vec3} v The direction.\n\t   * @param {Vec3} dst optional Vec3 to store result\n\t   * @return {Vec3} dst or new Vec3 if not provided\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function transformDirection(m, v, dst) {\n\t    dst = dst || v3.create();\n\n\t    var v0 = v[0];\n\t    var v1 = v[1];\n\t    var v2 = v[2];\n\n\t    dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];\n\t    dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];\n\t    dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Takes a 4-by-4 matrix m and a vector v with 3 entries, interprets the vector\n\t   * as a normal to a surface, and computes a vector which is normal upon\n\t   * transforming that surface by the matrix. The effect of this function is the\n\t   * same as transforming v (as a direction) by the inverse-transpose of m.  This\n\t   * function assumes the transformation of 3-dimensional space represented by the\n\t   * matrix is parallel-preserving, i.e. any combination of rotation, scaling and\n\t   * translation, but not a perspective distortion.  Returns a vector with 3\n\t   * entries.\n\t   * @param {module:twgl/m4.Mat4} m The matrix.\n\t   * @param {Vec3} v The normal.\n\t   * @param {Vec3} [dst] The direction.\n\t   * @return {Vec3} The transformed direction.\n\t   * @memberOf module:twgl/m4\n\t   */\n\t  function transformNormal(m, v, dst) {\n\t    dst = dst || v3.create();\n\t    var mi = inverse(m);\n\t    var v0 = v[0];\n\t    var v1 = v[1];\n\t    var v2 = v[2];\n\n\t    dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];\n\t    dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];\n\t    dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];\n\n\t    return dst;\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"axisRotate\": axisRotate,\n\t    \"axisRotation\": axisRotation,\n\t    \"create\": identity,\n\t    \"copy\": copy,\n\t    \"frustum\": frustum,\n\t    \"getAxis\": getAxis,\n\t    \"getTranslation\": getTranslation,\n\t    \"identity\": identity,\n\t    \"inverse\": inverse,\n\t    \"lookAt\": lookAt,\n\t    \"multiply\": multiply,\n\t    \"negate\": negate,\n\t    \"ortho\": ortho,\n\t    \"perspective\": perspective,\n\t    \"rotateX\": rotateX,\n\t    \"rotateY\": rotateY,\n\t    \"rotateZ\": rotateZ,\n\t    \"rotateAxis\": axisRotate,\n\t    \"rotationX\": rotationX,\n\t    \"rotationY\": rotationY,\n\t    \"rotationZ\": rotationZ,\n\t    \"scale\": scale,\n\t    \"scaling\": scaling,\n\t    \"setAxis\": setAxis,\n\t    \"setDefaultType\": setDefaultType,\n\t    \"setTranslation\": setTranslation,\n\t    \"transformDirection\": transformDirection,\n\t    \"transformNormal\": transformNormal,\n\t    \"transformPoint\": transformPoint,\n\t    \"translate\": translate,\n\t    \"translation\": translation,\n\t    \"transpose\": transpose\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t  \"use strict\";\n\n\t  /**\n\t   *\n\t   * Vec3 math math functions.\n\t   *\n\t   * Almost all functions take an optional `dst` argument. If it is not passed in the\n\t   * functions will create a new Vec3. In other words you can do this\n\t   *\n\t   *     var v = v3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.\n\t   *\n\t   * or\n\t   *\n\t   *     var v3 = v3.create();\n\t   *     v3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n\t   *\n\t   * The first style is often easier but depending on where it's used it generates garbage where\n\t   * as there is almost never allocation with the second style.\n\t   *\n\t   * It is always save to pass any vector as the destination. So for example\n\t   *\n\t   *     v3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n\t   *\n\t   * @module twgl/v3\n\t   */\n\n\t  var VecType = Float32Array;\n\n\t  /**\n\t   * A JavaScript array with 3 values or a Float32Array with 3 values.\n\t   * When created by the library will create the default type which is `Float32Array`\n\t   * but can be set by calling {@link module:twgl/v3.setDefaultType}.\n\t   * @typedef {(number[]|Float32Array)} Vec3\n\t   * @memberOf module:twgl/v3\n\t   */\n\n\t  /**\n\t   * Sets the type this library creates for a Vec3\n\t   * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`\n\t   * @return {constructor} previous constructor for Vec3\n\t   */\n\t  function setDefaultType(ctor) {\n\t    var oldType = VecType;\n\t    VecType = ctor;\n\t    return oldType;\n\t  }\n\n\t  /**\n\t   * Creates a vec3; may be called with x, y, z to set initial values.\n\t   * @return {Vec3} the created vector\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function create(x, y, z) {\n\t    var dst = new VecType(3);\n\t    if (x) {\n\t      dst[0] = x;\n\t    }\n\t    if (y) {\n\t      dst[1] = y;\n\t    }\n\t    if (z) {\n\t      dst[2] = z;\n\t    }\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Adds two vectors; assumes a and b have the same dimension.\n\t   * @param {module:twgl/v3.Vec3} a Operand vector.\n\t   * @param {module:twgl/v3.Vec3} b Operand vector.\n\t   * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function add(a, b, dst) {\n\t    dst = dst || new VecType(3);\n\n\t    dst[0] = a[0] + b[0];\n\t    dst[1] = a[1] + b[1];\n\t    dst[2] = a[2] + b[2];\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Subtracts two vectors.\n\t   * @param {module:twgl/v3.Vec3} a Operand vector.\n\t   * @param {module:twgl/v3.Vec3} b Operand vector.\n\t   * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function subtract(a, b, dst) {\n\t    dst = dst || new VecType(3);\n\n\t    dst[0] = a[0] - b[0];\n\t    dst[1] = a[1] - b[1];\n\t    dst[2] = a[2] - b[2];\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Performs linear interpolation on two vectors.\n\t   * Given vectors a and b and interpolation coefficient t, returns\n\t   * (1 - t) * a + t * b.\n\t   * @param {module:twgl/v3.Vec3} a Operand vector.\n\t   * @param {module:twgl/v3.Vec3} b Operand vector.\n\t   * @param {number} t Interpolation coefficient.\n\t   * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function lerp(a, b, t, dst) {\n\t    dst = dst || new VecType(3);\n\n\t    dst[0] = (1 - t) * a[0] + t * b[0];\n\t    dst[1] = (1 - t) * a[1] + t * b[1];\n\t    dst[2] = (1 - t) * a[2] + t * b[2];\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Mutiplies a vector by a scalar.\n\t   * @param {module:twgl/v3.Vec3} v The vector.\n\t   * @param {number} k The scalar.\n\t   * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..\n\t   * @return {module:twgl/v3.Vec3} dst.\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function mulScalar(v, k, dst) {\n\t    dst = dst || new VecType(3);\n\n\t    dst[0] = v[0] * k;\n\t    dst[1] = v[1] * k;\n\t    dst[2] = v[2] * k;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Divides a vector by a scalar.\n\t   * @param {module:twgl/v3.Vec3} v The vector.\n\t   * @param {number} k The scalar.\n\t   * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..\n\t   * @return {module:twgl/v3.Vec3} dst.\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function divScalar(v, k, dst) {\n\t    dst = dst || new VecType(3);\n\n\t    dst[0] = v[0] / k;\n\t    dst[1] = v[1] / k;\n\t    dst[2] = v[2] / k;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Computes the cross product of two vectors; assumes both vectors have\n\t   * three entries.\n\t   * @param {module:twgl/v3.Vec3} a Operand vector.\n\t   * @param {module:twgl/v3.Vec3} b Operand vector.\n\t   * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..\n\t   * @return {module:twgl/v3.Vec3} The vector a cross b.\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function cross(a, b, dst) {\n\t    dst = dst || new VecType(3);\n\n\t    var t1 = a[2] * b[0] - a[0] * b[2];\n\t    var t2 = a[0] * b[1] - a[1] * b[0];\n\t    dst[0] = a[1] * b[2] - a[2] * b[1];\n\t    dst[1] = t1;\n\t    dst[2] = t2;\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Computes the dot product of two vectors; assumes both vectors have\n\t   * three entries.\n\t   * @param {module:twgl/v3.Vec3} a Operand vector.\n\t   * @param {module:twgl/v3.Vec3} b Operand vector.\n\t   * @return {number} dot product\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function dot(a, b) {\n\t    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n\t  }\n\n\t  /**\n\t   * Computes the length of vector\n\t   * @param {module:twgl/v3.Vec3} v vector.\n\t   * @return {number} length of vector.\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function length(v) {\n\t    return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n\t  }\n\n\t  /**\n\t   * Computes the square of the length of vector\n\t   * @param {module:twgl/v3.Vec3} v vector.\n\t   * @return {number} square of the length of vector.\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function lengthSq(v) {\n\t    return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];\n\t  }\n\n\t  /**\n\t   * Computes the distance between 2 points\n\t   * @param {module:twgl/v3.Vec3} a vector.\n\t   * @param {module:twgl/v3.Vec3} b vector.\n\t   * @return {number} distance between a and b\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function distance(a, b) {\n\t    var dx = a[0] - b[0];\n\t    var dy = a[1] - b[1];\n\t    var dz = a[2] - b[2];\n\t    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n\t  }\n\n\t  /**\n\t   * Computes the square of the distance between 2 points\n\t   * @param {module:twgl/v3.Vec3} a vector.\n\t   * @param {module:twgl/v3.Vec3} b vector.\n\t   * @return {number} square of the distance between a and b\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function distanceSq(a, b) {\n\t    var dx = a[0] - b[0];\n\t    var dy = a[1] - b[1];\n\t    var dz = a[2] - b[2];\n\t    return dx * dx + dy * dy + dz * dz;\n\t  }\n\n\t  /**\n\t   * Divides a vector by its Euclidean length and returns the quotient.\n\t   * @param {module:twgl/v3.Vec3} a The vector.\n\t   * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..\n\t   * @return {module:twgl/v3.Vec3} The normalized vector.\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function normalize(a, dst) {\n\t    dst = dst || new VecType(3);\n\n\t    var lenSq = a[0] * a[0] + a[1] * a[1] + a[2] * a[2];\n\t    var len = Math.sqrt(lenSq);\n\t    if (len > 0.00001) {\n\t      dst[0] = a[0] / len;\n\t      dst[1] = a[1] / len;\n\t      dst[2] = a[2] / len;\n\t    } else {\n\t      dst[0] = 0;\n\t      dst[1] = 0;\n\t      dst[2] = 0;\n\t    }\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Negates a vector.\n\t   * @param {module:twgl/v3.Vec3} v The vector.\n\t   * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..\n\t   * @return {module:twgl/v3.Vec3} -v.\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function negate(v, dst) {\n\t    dst = dst || new VecType(3);\n\n\t    dst[0] = -v[0];\n\t    dst[1] = -v[1];\n\t    dst[2] = -v[2];\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Copies a vector.\n\t   * @param {module:twgl/v3.Vec3} v The vector.\n\t   * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..\n\t   * @return {module:twgl/v3.Vec3} A copy of v.\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function copy(v, dst) {\n\t    dst = dst || new VecType(3);\n\n\t    dst[0] = v[0];\n\t    dst[1] = v[1];\n\t    dst[2] = v[2];\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Multiplies a vector by another vector (component-wise); assumes a and\n\t   * b have the same length.\n\t   * @param {module:twgl/v3.Vec3} a Operand vector.\n\t   * @param {module:twgl/v3.Vec3} b Operand vector.\n\t   * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..\n\t   * @return {module:twgl/v3.Vec3} The vector of products of entries of a and\n\t   *     b.\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function multiply(a, b, dst) {\n\t    dst = dst || new VecType(3);\n\n\t    dst[0] = a[0] * b[0];\n\t    dst[1] = a[1] * b[1];\n\t    dst[2] = a[2] * b[2];\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Divides a vector by another vector (component-wise); assumes a and\n\t   * b have the same length.\n\t   * @param {module:twgl/v3.Vec3} a Operand vector.\n\t   * @param {module:twgl/v3.Vec3} b Operand vector.\n\t   * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..\n\t   * @return {module:twgl/v3.Vec3} The vector of quotients of entries of a and\n\t   *     b.\n\t   * @memberOf module:twgl/v3\n\t   */\n\t  function divide(a, b, dst) {\n\t    dst = dst || new VecType(3);\n\n\t    dst[0] = a[0] / b[0];\n\t    dst[1] = a[1] / b[1];\n\t    dst[2] = a[2] / b[2];\n\n\t    return dst;\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"add\": add,\n\t    \"copy\": copy,\n\t    \"create\": create,\n\t    \"cross\": cross,\n\t    \"distance\": distance,\n\t    \"distanceSq\": distanceSq,\n\t    \"divide\": divide,\n\t    \"divScalar\": divScalar,\n\t    \"dot\": dot,\n\t    \"lerp\": lerp,\n\t    \"length\": length,\n\t    \"lengthSq\": lengthSq,\n\t    \"mulScalar\": mulScalar,\n\t    \"multiply\": multiply,\n\t    \"negate\": negate,\n\t    \"normalize\": normalize,\n\t    \"setDefaultType\": setDefaultType,\n\t    \"subtract\": subtract\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t/**\n\t * Various functions to make simple primitives\n\t *\n\t * note: Most primitive functions come in 3 styles\n\t *\n\t * *  `createSomeShapeBufferInfo`\n\t *\n\t *    These functions are almost always the functions you want to call. They\n\t *    create vertices then make WebGLBuffers and create {@link module:twgl.AttribInfo}s\n\t *    returing a {@link module:twgl.BufferInfo} you can pass to {@link module:twgl.setBuffersAndAttributes}\n\t *    and {@link module:twgl.drawBufferInfo} etc...\n\t *\n\t * *  `createSomeShapeBuffers`\n\t *\n\t *    These create WebGLBuffers and put your data in them but nothing else.\n\t *    It's a shortcut to doing it yourself if you don't want to use\n\t *    the higher level functions.\n\t *\n\t * *  `createSomeShapeVertices`\n\t *\n\t *    These just create vertices, no buffers. This allows you to manipulate the vertices\n\t *    or add more data before generating a {@link module:twgl.BufferInfo}. Once you're finished\n\t *    manipulating the vertices call {@link module:twgl.createBufferInfoFromArrays}.\n\t *\n\t *    example:\n\t *\n\t *        var arrays = twgl.primitives.createPlaneArrays(1);\n\t *        twgl.primitives.reorientVertices(arrays, m4.rotationX(Math.PI * 0.5));\n\t *        var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\n\t *\n\t * @module twgl/primitives\n\t */\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4), __webpack_require__(10), __webpack_require__(11)], __WEBPACK_AMD_DEFINE_RESULT__ = function (attributes, utils, m4, v3) {\n\t  \"use strict\";\n\n\t  var getArray = attributes.getArray_; // eslint-disable-line\n\t  var getNumComponents = attributes.getNumComponents_; // eslint-disable-line\n\n\t  /**\n\t   * Add `push` to a typed array. It just keeps a 'cursor'\n\t   * and allows use to `push` values into the array so we\n\t   * don't have to manually compute offsets\n\t   * @param {TypedArray} typedArray TypedArray to augment\n\t   * @param {number} numComponents number of components.\n\t   */\n\t  function augmentTypedArray(typedArray, numComponents) {\n\t    var cursor = 0;\n\t    typedArray.push = function () {\n\t      for (var ii = 0; ii < arguments.length; ++ii) {\n\t        var value = arguments[ii];\n\t        if (value instanceof Array || value.buffer && value.buffer instanceof ArrayBuffer) {\n\t          for (var jj = 0; jj < value.length; ++jj) {\n\t            typedArray[cursor++] = value[jj];\n\t          }\n\t        } else {\n\t          typedArray[cursor++] = value;\n\t        }\n\t      }\n\t    };\n\t    typedArray.reset = function (opt_index) {\n\t      cursor = opt_index || 0;\n\t    };\n\t    typedArray.numComponents = numComponents;\n\t    Object.defineProperty(typedArray, 'numElements', {\n\t      get: function get() {\n\t        return this.length / this.numComponents | 0;\n\t      }\n\t    });\n\t    return typedArray;\n\t  }\n\n\t  /**\n\t   * creates a typed array with a `push` function attached\n\t   * so that you can easily *push* values.\n\t   *\n\t   * `push` can take multiple arguments. If an argument is an array each element\n\t   * of the array will be added to the typed array.\n\t   *\n\t   * Example:\n\t   *\n\t   *     var array = createAugmentedTypedArray(3, 2);  // creates a Float32Array with 6 values\n\t   *     array.push(1, 2, 3);\n\t   *     array.push([4, 5, 6]);\n\t   *     // array now contains [1, 2, 3, 4, 5, 6]\n\t   *\n\t   * Also has `numComponents` and `numElements` properties.\n\t   *\n\t   * @param {number} numComponents number of components\n\t   * @param {number} numElements number of elements. The total size of the array will be `numComponents * numElements`.\n\t   * @param {constructor} opt_type A constructor for the type. Default = `Float32Array`.\n\t   * @return {ArrayBuffer} A typed array.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function createAugmentedTypedArray(numComponents, numElements, opt_type) {\n\t    var Type = opt_type || Float32Array;\n\t    return augmentTypedArray(new Type(numComponents * numElements), numComponents);\n\t  }\n\n\t  function allButIndices(name) {\n\t    return name !== \"indices\";\n\t  }\n\n\t  /**\n\t   * Given indexed vertices creates a new set of vertices unindexed by expanding the indexed vertices.\n\t   * @param {Object.<string, TypedArray>} vertices The indexed vertices to deindex\n\t   * @return {Object.<string, TypedArray>} The deindexed vertices\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function deindexVertices(vertices) {\n\t    var indices = vertices.indices;\n\t    var newVertices = {};\n\t    var numElements = indices.length;\n\n\t    function expandToUnindexed(channel) {\n\t      var srcBuffer = vertices[channel];\n\t      var numComponents = srcBuffer.numComponents;\n\t      var dstBuffer = createAugmentedTypedArray(numComponents, numElements, srcBuffer.constructor);\n\t      for (var ii = 0; ii < numElements; ++ii) {\n\t        var ndx = indices[ii];\n\t        var offset = ndx * numComponents;\n\t        for (var jj = 0; jj < numComponents; ++jj) {\n\t          dstBuffer.push(srcBuffer[offset + jj]);\n\t        }\n\t      }\n\t      newVertices[channel] = dstBuffer;\n\t    }\n\n\t    Object.keys(vertices).filter(allButIndices).forEach(expandToUnindexed);\n\n\t    return newVertices;\n\t  }\n\n\t  /**\n\t   * flattens the normals of deindexed vertices in place.\n\t   * @param {Object.<string, TypedArray>} vertices The deindexed vertices who's normals to flatten\n\t   * @return {Object.<string, TypedArray>} The flattened vertices (same as was passed in)\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function flattenNormals(vertices) {\n\t    if (vertices.indices) {\n\t      throw \"can't flatten normals of indexed vertices. deindex them first\";\n\t    }\n\n\t    var normals = vertices.normal;\n\t    var numNormals = normals.length;\n\t    for (var ii = 0; ii < numNormals; ii += 9) {\n\t      // pull out the 3 normals for this triangle\n\t      var nax = normals[ii + 0];\n\t      var nay = normals[ii + 1];\n\t      var naz = normals[ii + 2];\n\n\t      var nbx = normals[ii + 3];\n\t      var nby = normals[ii + 4];\n\t      var nbz = normals[ii + 5];\n\n\t      var ncx = normals[ii + 6];\n\t      var ncy = normals[ii + 7];\n\t      var ncz = normals[ii + 8];\n\n\t      // add them\n\t      var nx = nax + nbx + ncx;\n\t      var ny = nay + nby + ncy;\n\t      var nz = naz + nbz + ncz;\n\n\t      // normalize them\n\t      var length = Math.sqrt(nx * nx + ny * ny + nz * nz);\n\n\t      nx /= length;\n\t      ny /= length;\n\t      nz /= length;\n\n\t      // copy them back in\n\t      normals[ii + 0] = nx;\n\t      normals[ii + 1] = ny;\n\t      normals[ii + 2] = nz;\n\n\t      normals[ii + 3] = nx;\n\t      normals[ii + 4] = ny;\n\t      normals[ii + 5] = nz;\n\n\t      normals[ii + 6] = nx;\n\t      normals[ii + 7] = ny;\n\t      normals[ii + 8] = nz;\n\t    }\n\n\t    return vertices;\n\t  }\n\n\t  function applyFuncToV3Array(array, matrix, fn) {\n\t    var len = array.length;\n\t    var tmp = new Float32Array(3);\n\t    for (var ii = 0; ii < len; ii += 3) {\n\t      fn(matrix, [array[ii], array[ii + 1], array[ii + 2]], tmp);\n\t      array[ii] = tmp[0];\n\t      array[ii + 1] = tmp[1];\n\t      array[ii + 2] = tmp[2];\n\t    }\n\t  }\n\n\t  function transformNormal(mi, v, dst) {\n\t    dst = dst || v3.create();\n\t    var v0 = v[0];\n\t    var v1 = v[1];\n\t    var v2 = v[2];\n\n\t    dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];\n\t    dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];\n\t    dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];\n\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Reorients directions by the given matrix..\n\t   * @param {number[]|TypedArray} array The array. Assumes value floats per element.\n\t   * @param {Matrix} matrix A matrix to multiply by.\n\t   * @return {number[]|TypedArray} the same array that was passed in\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function reorientDirections(array, matrix) {\n\t    applyFuncToV3Array(array, matrix, m4.transformDirection);\n\t    return array;\n\t  }\n\n\t  /**\n\t   * Reorients normals by the inverse-transpose of the given\n\t   * matrix..\n\t   * @param {number[]|TypedArray} array The array. Assumes value floats per element.\n\t   * @param {Matrix} matrix A matrix to multiply by.\n\t   * @return {number[]|TypedArray} the same array that was passed in\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function reorientNormals(array, matrix) {\n\t    applyFuncToV3Array(array, m4.inverse(matrix), transformNormal);\n\t    return array;\n\t  }\n\n\t  /**\n\t   * Reorients positions by the given matrix. In other words, it\n\t   * multiplies each vertex by the given matrix.\n\t   * @param {number[]|TypedArray} array The array. Assumes value floats per element.\n\t   * @param {Matrix} matrix A matrix to multiply by.\n\t   * @return {number[]|TypedArray} the same array that was passed in\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function reorientPositions(array, matrix) {\n\t    applyFuncToV3Array(array, matrix, m4.transformPoint);\n\t    return array;\n\t  }\n\n\t  /**\n\t   * Reorients arrays by the given matrix. Assumes arrays have\n\t   * names that contains 'pos' could be reoriented as positions,\n\t   * 'binorm' or 'tan' as directions, and 'norm' as normals.\n\t   *\n\t   * @param {Object.<string, (number[]|TypedArray)>} arrays The vertices to reorient\n\t   * @param {Matrix} matrix matrix to reorient by.\n\t   * @return {Object.<string, (number[]|TypedArray)>} same arrays that were passed in.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function reorientVertices(arrays, matrix) {\n\t    Object.keys(arrays).forEach(function (name) {\n\t      var array = arrays[name];\n\t      if (name.indexOf(\"pos\") >= 0) {\n\t        reorientPositions(array, matrix);\n\t      } else if (name.indexOf(\"tan\") >= 0 || name.indexOf(\"binorm\") >= 0) {\n\t        reorientDirections(array, matrix);\n\t      } else if (name.indexOf(\"norm\") >= 0) {\n\t        reorientNormals(array, matrix);\n\t      }\n\t    });\n\t    return arrays;\n\t  }\n\n\t  /**\n\t   * Creates XY quad BufferInfo\n\t   *\n\t   * The default with no parameters will return a 2x2 quad with values from -1 to +1.\n\t   * If you want a unit quad with that goes from 0 to 1 you'd call it with\n\t   *\n\t   *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);\n\t   *\n\t   * If you want a unit quad centered above 0,0 you'd call it with\n\t   *\n\t   *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1\n\t   * @param {number} [xOffset] the amount to offset the quad in X\n\t   * @param {number} [yOffset] the amount to offset the quad in Y\n\t   * @return {Object.<string, WebGLBuffer>} the created XY Quad BufferInfo\n\t   * @memberOf module:twgl/primitives\n\t   * @function createXYQuadBufferInfo\n\t   */\n\n\t  /**\n\t   * Creates XY quad Buffers\n\t   *\n\t   * The default with no parameters will return a 2x2 quad with values from -1 to +1.\n\t   * If you want a unit quad with that goes from 0 to 1 you'd call it with\n\t   *\n\t   *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);\n\t   *\n\t   * If you want a unit quad centered above 0,0 you'd call it with\n\t   *\n\t   *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1\n\t   * @param {number} [xOffset] the amount to offset the quad in X\n\t   * @param {number} [yOffset] the amount to offset the quad in Y\n\t   * @return {module:twgl.BufferInfo} the created XY Quad buffers\n\t   * @memberOf module:twgl/primitives\n\t   * @function createXYQuadBuffers\n\t   */\n\n\t  /**\n\t   * Creates XY quad vertices\n\t   *\n\t   * The default with no parameters will return a 2x2 quad with values from -1 to +1.\n\t   * If you want a unit quad with that goes from 0 to 1 you'd call it with\n\t   *\n\t   *     twgl.primitives.createXYQuadVertices(1, 0.5, 0.5);\n\t   *\n\t   * If you want a unit quad centered above 0,0 you'd call it with\n\t   *\n\t   *     twgl.primitives.createXYQuadVertices(1, 0, 0.5);\n\t   *\n\t   * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1\n\t   * @param {number} [xOffset] the amount to offset the quad in X\n\t   * @param {number} [yOffset] the amount to offset the quad in Y\n\t   * @return {Object.<string, TypedArray> the created XY Quad vertices\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function createXYQuadVertices(size, xOffset, yOffset) {\n\t    size = size || 2;\n\t    xOffset = xOffset || 0;\n\t    yOffset = yOffset || 0;\n\t    size *= 0.5;\n\t    return {\n\t      position: {\n\t        numComponents: 2,\n\t        data: [xOffset + -1 * size, yOffset + -1 * size, xOffset + 1 * size, yOffset + -1 * size, xOffset + -1 * size, yOffset + 1 * size, xOffset + 1 * size, yOffset + 1 * size]\n\t      },\n\t      normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],\n\t      texcoord: [0, 0, 1, 0, 0, 1, 1, 1],\n\t      indices: [0, 1, 2, 2, 1, 3]\n\t    };\n\t  }\n\n\t  /**\n\t   * Creates XZ plane BufferInfo.\n\t   *\n\t   * The created plane has position, normal, and texcoord data\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} [width] Width of the plane. Default = 1\n\t   * @param {number} [depth] Depth of the plane. Default = 1\n\t   * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1\n\t   * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1\n\t   * @param {Matrix4} [matrix] A matrix by which to multiply all the vertices.\n\t   * @return {@module:twgl.BufferInfo} The created plane BufferInfo.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createPlaneBufferInfo\n\t   */\n\n\t  /**\n\t   * Creates XZ plane buffers.\n\t   *\n\t   * The created plane has position, normal, and texcoord data\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} [width] Width of the plane. Default = 1\n\t   * @param {number} [depth] Depth of the plane. Default = 1\n\t   * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1\n\t   * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1\n\t   * @param {Matrix4} [matrix] A matrix by which to multiply all the vertices.\n\t   * @return {Object.<string, WebGLBuffer>} The created plane buffers.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createPlaneBuffers\n\t   */\n\n\t  /**\n\t   * Creates XZ plane vertices.\n\t   *\n\t   * The created plane has position, normal, and texcoord data\n\t   *\n\t   * @param {number} [width] Width of the plane. Default = 1\n\t   * @param {number} [depth] Depth of the plane. Default = 1\n\t   * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1\n\t   * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1\n\t   * @param {Matrix4} [matrix] A matrix by which to multiply all the vertices.\n\t   * @return {Object.<string, TypedArray>} The created plane vertices.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function createPlaneVertices(width, depth, subdivisionsWidth, subdivisionsDepth, matrix) {\n\t    width = width || 1;\n\t    depth = depth || 1;\n\t    subdivisionsWidth = subdivisionsWidth || 1;\n\t    subdivisionsDepth = subdivisionsDepth || 1;\n\t    matrix = matrix || m4.identity();\n\n\t    var numVertices = (subdivisionsWidth + 1) * (subdivisionsDepth + 1);\n\t    var positions = createAugmentedTypedArray(3, numVertices);\n\t    var normals = createAugmentedTypedArray(3, numVertices);\n\t    var texcoords = createAugmentedTypedArray(2, numVertices);\n\n\t    for (var z = 0; z <= subdivisionsDepth; z++) {\n\t      for (var x = 0; x <= subdivisionsWidth; x++) {\n\t        var u = x / subdivisionsWidth;\n\t        var v = z / subdivisionsDepth;\n\t        positions.push(width * u - width * 0.5, 0, depth * v - depth * 0.5);\n\t        normals.push(0, 1, 0);\n\t        texcoords.push(u, v);\n\t      }\n\t    }\n\n\t    var numVertsAcross = subdivisionsWidth + 1;\n\t    var indices = createAugmentedTypedArray(3, subdivisionsWidth * subdivisionsDepth * 2, Uint16Array);\n\n\t    for (var z = 0; z < subdivisionsDepth; z++) {\n\t      // eslint-disable-line\n\t      for (var x = 0; x < subdivisionsWidth; x++) {\n\t        // eslint-disable-line\n\t        // Make triangle 1 of quad.\n\t        indices.push((z + 0) * numVertsAcross + x, (z + 1) * numVertsAcross + x, (z + 0) * numVertsAcross + x + 1);\n\n\t        // Make triangle 2 of quad.\n\t        indices.push((z + 1) * numVertsAcross + x, (z + 1) * numVertsAcross + x + 1, (z + 0) * numVertsAcross + x + 1);\n\t      }\n\t    }\n\n\t    var arrays = reorientVertices({\n\t      position: positions,\n\t      normal: normals,\n\t      texcoord: texcoords,\n\t      indices: indices\n\t    }, matrix);\n\t    return arrays;\n\t  }\n\n\t  /**\n\t   * Creates sphere BufferInfo.\n\t   *\n\t   * The created sphere has position, normal, and texcoord data\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} radius radius of the sphere.\n\t   * @param {number} subdivisionsAxis number of steps around the sphere.\n\t   * @param {number} subdivisionsHeight number of vertically on the sphere.\n\t   * @param {number} [opt_startLatitudeInRadians] where to start the\n\t   *     top of the sphere. Default = 0.\n\t   * @param {number} [opt_endLatitudeInRadians] Where to end the\n\t   *     bottom of the sphere. Default = Math.PI.\n\t   * @param {number} [opt_startLongitudeInRadians] where to start\n\t   *     wrapping the sphere. Default = 0.\n\t   * @param {number} [opt_endLongitudeInRadians] where to end\n\t   *     wrapping the sphere. Default = 2 * Math.PI.\n\t   * @return {module:twgl.BufferInfo} The created sphere BufferInfo.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createSphereBufferInfo\n\t   */\n\n\t  /**\n\t   * Creates sphere buffers.\n\t   *\n\t   * The created sphere has position, normal, and texcoord data\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} radius radius of the sphere.\n\t   * @param {number} subdivisionsAxis number of steps around the sphere.\n\t   * @param {number} subdivisionsHeight number of vertically on the sphere.\n\t   * @param {number} [opt_startLatitudeInRadians] where to start the\n\t   *     top of the sphere. Default = 0.\n\t   * @param {number} [opt_endLatitudeInRadians] Where to end the\n\t   *     bottom of the sphere. Default = Math.PI.\n\t   * @param {number} [opt_startLongitudeInRadians] where to start\n\t   *     wrapping the sphere. Default = 0.\n\t   * @param {number} [opt_endLongitudeInRadians] where to end\n\t   *     wrapping the sphere. Default = 2 * Math.PI.\n\t   * @return {Object.<string, WebGLBuffer>} The created sphere buffers.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createSphereBuffers\n\t   */\n\n\t  /**\n\t   * Creates sphere vertices.\n\t   *\n\t   * The created sphere has position, normal, and texcoord data\n\t   *\n\t   * @param {number} radius radius of the sphere.\n\t   * @param {number} subdivisionsAxis number of steps around the sphere.\n\t   * @param {number} subdivisionsHeight number of vertically on the sphere.\n\t   * @param {number} [opt_startLatitudeInRadians] where to start the\n\t   *     top of the sphere. Default = 0.\n\t   * @param {number} [opt_endLatitudeInRadians] Where to end the\n\t   *     bottom of the sphere. Default = Math.PI.\n\t   * @param {number} [opt_startLongitudeInRadians] where to start\n\t   *     wrapping the sphere. Default = 0.\n\t   * @param {number} [opt_endLongitudeInRadians] where to end\n\t   *     wrapping the sphere. Default = 2 * Math.PI.\n\t   * @return {Object.<string, TypedArray>} The created sphere vertices.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function createSphereVertices(radius, subdivisionsAxis, subdivisionsHeight, opt_startLatitudeInRadians, opt_endLatitudeInRadians, opt_startLongitudeInRadians, opt_endLongitudeInRadians) {\n\t    if (subdivisionsAxis <= 0 || subdivisionsHeight <= 0) {\n\t      throw Error('subdivisionAxis and subdivisionHeight must be > 0');\n\t    }\n\n\t    opt_startLatitudeInRadians = opt_startLatitudeInRadians || 0;\n\t    opt_endLatitudeInRadians = opt_endLatitudeInRadians || Math.PI;\n\t    opt_startLongitudeInRadians = opt_startLongitudeInRadians || 0;\n\t    opt_endLongitudeInRadians = opt_endLongitudeInRadians || Math.PI * 2;\n\n\t    var latRange = opt_endLatitudeInRadians - opt_startLatitudeInRadians;\n\t    var longRange = opt_endLongitudeInRadians - opt_startLongitudeInRadians;\n\n\t    // We are going to generate our sphere by iterating through its\n\t    // spherical coordinates and generating 2 triangles for each quad on a\n\t    // ring of the sphere.\n\t    var numVertices = (subdivisionsAxis + 1) * (subdivisionsHeight + 1);\n\t    var positions = createAugmentedTypedArray(3, numVertices);\n\t    var normals = createAugmentedTypedArray(3, numVertices);\n\t    var texcoords = createAugmentedTypedArray(2, numVertices);\n\n\t    // Generate the individual vertices in our vertex buffer.\n\t    for (var y = 0; y <= subdivisionsHeight; y++) {\n\t      for (var x = 0; x <= subdivisionsAxis; x++) {\n\t        // Generate a vertex based on its spherical coordinates\n\t        var u = x / subdivisionsAxis;\n\t        var v = y / subdivisionsHeight;\n\t        var theta = longRange * u;\n\t        var phi = latRange * v;\n\t        var sinTheta = Math.sin(theta);\n\t        var cosTheta = Math.cos(theta);\n\t        var sinPhi = Math.sin(phi);\n\t        var cosPhi = Math.cos(phi);\n\t        var ux = cosTheta * sinPhi;\n\t        var uy = cosPhi;\n\t        var uz = sinTheta * sinPhi;\n\t        positions.push(radius * ux, radius * uy, radius * uz);\n\t        normals.push(ux, uy, uz);\n\t        texcoords.push(1 - u, v);\n\t      }\n\t    }\n\n\t    var numVertsAround = subdivisionsAxis + 1;\n\t    var indices = createAugmentedTypedArray(3, subdivisionsAxis * subdivisionsHeight * 2, Uint16Array);\n\t    for (var x = 0; x < subdivisionsAxis; x++) {\n\t      // eslint-disable-line\n\t      for (var y = 0; y < subdivisionsHeight; y++) {\n\t        // eslint-disable-line\n\t        // Make triangle 1 of quad.\n\t        indices.push((y + 0) * numVertsAround + x, (y + 0) * numVertsAround + x + 1, (y + 1) * numVertsAround + x);\n\n\t        // Make triangle 2 of quad.\n\t        indices.push((y + 1) * numVertsAround + x, (y + 0) * numVertsAround + x + 1, (y + 1) * numVertsAround + x + 1);\n\t      }\n\t    }\n\n\t    return {\n\t      position: positions,\n\t      normal: normals,\n\t      texcoord: texcoords,\n\t      indices: indices\n\t    };\n\t  }\n\n\t  /**\n\t   * Array of the indices of corners of each face of a cube.\n\t   * @type {Array.<number[]>}\n\t   */\n\t  var CUBE_FACE_INDICES = [[3, 7, 5, 1], // right\n\t  [6, 2, 0, 4], // left\n\t  [6, 7, 3, 2], // ??\n\t  [0, 1, 5, 4], // ??\n\t  [7, 6, 4, 5], // front\n\t  [2, 3, 1, 0]];\n\n\t  /**\n\t   * Creates a BufferInfo for a cube.\n\t   *\n\t   * The cube is created around the origin. (-size / 2, size / 2).\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} [size] width, height and depth of the cube.\n\t   * @return {module:twgl.BufferInfo} The created BufferInfo.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createCubeBufferInfo\n\t   */\n\n\t  /**\n\t   * Creates the buffers and indices for a cube.\n\t   *\n\t   * The cube is created around the origin. (-size / 2, size / 2).\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} [size] width, height and depth of the cube.\n\t   * @return {Object.<string, WebGLBuffer>} The created buffers.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createCubeBuffers\n\t   */\n\n\t  /**\n\t   * Creates the vertices and indices for a cube.\n\t   *\n\t   * The cube is created around the origin. (-size / 2, size / 2).\n\t   *\n\t   * @param {number} [size] width, height and depth of the cube.\n\t   * @return {Object.<string, TypedArray>} The created vertices.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function createCubeVertices(size) {\n\t    size = size || 1;\n\t    var k = size / 2;\n\n\t    var cornerVertices = [[-k, -k, -k], [+k, -k, -k], [-k, +k, -k], [+k, +k, -k], [-k, -k, +k], [+k, -k, +k], [-k, +k, +k], [+k, +k, +k]];\n\n\t    var faceNormals = [[+1, +0, +0], [-1, +0, +0], [+0, +1, +0], [+0, -1, +0], [+0, +0, +1], [+0, +0, -1]];\n\n\t    var uvCoords = [[1, 0], [0, 0], [0, 1], [1, 1]];\n\n\t    var numVertices = 6 * 4;\n\t    var positions = createAugmentedTypedArray(3, numVertices);\n\t    var normals = createAugmentedTypedArray(3, numVertices);\n\t    var texcoords = createAugmentedTypedArray(2, numVertices);\n\t    var indices = createAugmentedTypedArray(3, 6 * 2, Uint16Array);\n\n\t    for (var f = 0; f < 6; ++f) {\n\t      var faceIndices = CUBE_FACE_INDICES[f];\n\t      for (var v = 0; v < 4; ++v) {\n\t        var position = cornerVertices[faceIndices[v]];\n\t        var normal = faceNormals[f];\n\t        var uv = uvCoords[v];\n\n\t        // Each face needs all four vertices because the normals and texture\n\t        // coordinates are not all the same.\n\t        positions.push(position);\n\t        normals.push(normal);\n\t        texcoords.push(uv);\n\t      }\n\t      // Two triangles make a square face.\n\t      var offset = 4 * f;\n\t      indices.push(offset + 0, offset + 1, offset + 2);\n\t      indices.push(offset + 0, offset + 2, offset + 3);\n\t    }\n\n\t    return {\n\t      position: positions,\n\t      normal: normals,\n\t      texcoord: texcoords,\n\t      indices: indices\n\t    };\n\t  }\n\n\t  /**\n\t   * Creates a BufferInfo for a truncated cone, which is like a cylinder\n\t   * except that it has different top and bottom radii. A truncated cone\n\t   * can also be used to create cylinders and regular cones. The\n\t   * truncated cone will be created centered about the origin, with the\n\t   * y axis as its vertical axis.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} bottomRadius Bottom radius of truncated cone.\n\t   * @param {number} topRadius Top radius of truncated cone.\n\t   * @param {number} height Height of truncated cone.\n\t   * @param {number} radialSubdivisions The number of subdivisions around the\n\t   *     truncated cone.\n\t   * @param {number} verticalSubdivisions The number of subdivisions down the\n\t   *     truncated cone.\n\t   * @param {boolean} [opt_topCap] Create top cap. Default = true.\n\t   * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.\n\t   * @return {module:twgl.BufferInfo} The created cone BufferInfo.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createTruncatedConeBufferInfo\n\t   */\n\n\t  /**\n\t   * Creates buffers for a truncated cone, which is like a cylinder\n\t   * except that it has different top and bottom radii. A truncated cone\n\t   * can also be used to create cylinders and regular cones. The\n\t   * truncated cone will be created centered about the origin, with the\n\t   * y axis as its vertical axis.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} bottomRadius Bottom radius of truncated cone.\n\t   * @param {number} topRadius Top radius of truncated cone.\n\t   * @param {number} height Height of truncated cone.\n\t   * @param {number} radialSubdivisions The number of subdivisions around the\n\t   *     truncated cone.\n\t   * @param {number} verticalSubdivisions The number of subdivisions down the\n\t   *     truncated cone.\n\t   * @param {boolean} [opt_topCap] Create top cap. Default = true.\n\t   * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.\n\t   * @return {Object.<string, WebGLBuffer>} The created cone buffers.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createTruncatedConeBuffers\n\t   */\n\n\t  /**\n\t   * Creates vertices for a truncated cone, which is like a cylinder\n\t   * except that it has different top and bottom radii. A truncated cone\n\t   * can also be used to create cylinders and regular cones. The\n\t   * truncated cone will be created centered about the origin, with the\n\t   * y axis as its vertical axis. .\n\t   *\n\t   * @param {number} bottomRadius Bottom radius of truncated cone.\n\t   * @param {number} topRadius Top radius of truncated cone.\n\t   * @param {number} height Height of truncated cone.\n\t   * @param {number} radialSubdivisions The number of subdivisions around the\n\t   *     truncated cone.\n\t   * @param {number} verticalSubdivisions The number of subdivisions down the\n\t   *     truncated cone.\n\t   * @param {boolean} [opt_topCap] Create top cap. Default = true.\n\t   * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.\n\t   * @return {Object.<string, TypedArray>} The created cone vertices.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function createTruncatedConeVertices(bottomRadius, topRadius, height, radialSubdivisions, verticalSubdivisions, opt_topCap, opt_bottomCap) {\n\t    if (radialSubdivisions < 3) {\n\t      throw Error('radialSubdivisions must be 3 or greater');\n\t    }\n\n\t    if (verticalSubdivisions < 1) {\n\t      throw Error('verticalSubdivisions must be 1 or greater');\n\t    }\n\n\t    var topCap = opt_topCap === undefined ? true : opt_topCap;\n\t    var bottomCap = opt_bottomCap === undefined ? true : opt_bottomCap;\n\n\t    var extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);\n\n\t    var numVertices = (radialSubdivisions + 1) * (verticalSubdivisions + 1 + extra);\n\t    var positions = createAugmentedTypedArray(3, numVertices);\n\t    var normals = createAugmentedTypedArray(3, numVertices);\n\t    var texcoords = createAugmentedTypedArray(2, numVertices);\n\t    var indices = createAugmentedTypedArray(3, radialSubdivisions * (verticalSubdivisions + extra) * 2, Uint16Array);\n\n\t    var vertsAroundEdge = radialSubdivisions + 1;\n\n\t    // The slant of the cone is constant across its surface\n\t    var slant = Math.atan2(bottomRadius - topRadius, height);\n\t    var cosSlant = Math.cos(slant);\n\t    var sinSlant = Math.sin(slant);\n\n\t    var start = topCap ? -2 : 0;\n\t    var end = verticalSubdivisions + (bottomCap ? 2 : 0);\n\n\t    for (var yy = start; yy <= end; ++yy) {\n\t      var v = yy / verticalSubdivisions;\n\t      var y = height * v;\n\t      var ringRadius;\n\t      if (yy < 0) {\n\t        y = 0;\n\t        v = 1;\n\t        ringRadius = bottomRadius;\n\t      } else if (yy > verticalSubdivisions) {\n\t        y = height;\n\t        v = 1;\n\t        ringRadius = topRadius;\n\t      } else {\n\t        ringRadius = bottomRadius + (topRadius - bottomRadius) * (yy / verticalSubdivisions);\n\t      }\n\t      if (yy === -2 || yy === verticalSubdivisions + 2) {\n\t        ringRadius = 0;\n\t        v = 0;\n\t      }\n\t      y -= height / 2;\n\t      for (var ii = 0; ii < vertsAroundEdge; ++ii) {\n\t        var sin = Math.sin(ii * Math.PI * 2 / radialSubdivisions);\n\t        var cos = Math.cos(ii * Math.PI * 2 / radialSubdivisions);\n\t        positions.push(sin * ringRadius, y, cos * ringRadius);\n\t        normals.push(yy < 0 || yy > verticalSubdivisions ? 0 : sin * cosSlant, yy < 0 ? -1 : yy > verticalSubdivisions ? 1 : sinSlant, yy < 0 || yy > verticalSubdivisions ? 0 : cos * cosSlant);\n\t        texcoords.push(ii / radialSubdivisions, 1 - v);\n\t      }\n\t    }\n\n\t    for (var yy = 0; yy < verticalSubdivisions + extra; ++yy) {\n\t      // eslint-disable-line\n\t      for (var ii = 0; ii < radialSubdivisions; ++ii) {\n\t        // eslint-disable-line\n\t        indices.push(vertsAroundEdge * (yy + 0) + 0 + ii, vertsAroundEdge * (yy + 0) + 1 + ii, vertsAroundEdge * (yy + 1) + 1 + ii);\n\t        indices.push(vertsAroundEdge * (yy + 0) + 0 + ii, vertsAroundEdge * (yy + 1) + 1 + ii, vertsAroundEdge * (yy + 1) + 0 + ii);\n\t      }\n\t    }\n\n\t    return {\n\t      position: positions,\n\t      normal: normals,\n\t      texcoord: texcoords,\n\t      indices: indices\n\t    };\n\t  }\n\n\t  /**\n\t   * Expands RLE data\n\t   * @param {number[]} rleData data in format of run-length, x, y, z, run-length, x, y, z\n\t   * @param {number[]} [padding] value to add each entry with.\n\t   * @return {number[]} the expanded rleData\n\t   */\n\t  function expandRLEData(rleData, padding) {\n\t    padding = padding || [];\n\t    var data = [];\n\t    for (var ii = 0; ii < rleData.length; ii += 4) {\n\t      var runLength = rleData[ii];\n\t      var element = rleData.slice(ii + 1, ii + 4);\n\t      element.push.apply(element, padding);\n\t      for (var jj = 0; jj < runLength; ++jj) {\n\t        data.push.apply(data, element);\n\t      }\n\t    }\n\t    return data;\n\t  }\n\n\t  /**\n\t   * Creates 3D 'F' BufferInfo.\n\t   * An 'F' is useful because you can easily tell which way it is oriented.\n\t   * The created 'F' has position, normal, texcoord, and color buffers.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @return {module:twgl.BufferInfo} The created BufferInfo.\n\t   * @memberOf module:twgl/primitives\n\t   * @function create3DFBufferInfo\n\t   */\n\n\t  /**\n\t   * Creates 3D 'F' buffers.\n\t   * An 'F' is useful because you can easily tell which way it is oriented.\n\t   * The created 'F' has position, normal, texcoord, and color buffers.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @return {Object.<string, WebGLBuffer>} The created buffers.\n\t   * @memberOf module:twgl/primitives\n\t   * @function create3DFBuffers\n\t   */\n\n\t  /**\n\t   * Creates 3D 'F' vertices.\n\t   * An 'F' is useful because you can easily tell which way it is oriented.\n\t   * The created 'F' has position, normal, texcoord, and color arrays.\n\t   *\n\t   * @return {Object.<string, TypedArray>} The created vertices.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function create3DFVertices() {\n\n\t    var positions = [\n\t    // left column front\n\t    0, 0, 0, 0, 150, 0, 30, 0, 0, 0, 150, 0, 30, 150, 0, 30, 0, 0,\n\n\t    // top rung front\n\t    30, 0, 0, 30, 30, 0, 100, 0, 0, 30, 30, 0, 100, 30, 0, 100, 0, 0,\n\n\t    // middle rung front\n\t    30, 60, 0, 30, 90, 0, 67, 60, 0, 30, 90, 0, 67, 90, 0, 67, 60, 0,\n\n\t    // left column back\n\t    0, 0, 30, 30, 0, 30, 0, 150, 30, 0, 150, 30, 30, 0, 30, 30, 150, 30,\n\n\t    // top rung back\n\t    30, 0, 30, 100, 0, 30, 30, 30, 30, 30, 30, 30, 100, 0, 30, 100, 30, 30,\n\n\t    // middle rung back\n\t    30, 60, 30, 67, 60, 30, 30, 90, 30, 30, 90, 30, 67, 60, 30, 67, 90, 30,\n\n\t    // top\n\t    0, 0, 0, 100, 0, 0, 100, 0, 30, 0, 0, 0, 100, 0, 30, 0, 0, 30,\n\n\t    // top rung front\n\t    100, 0, 0, 100, 30, 0, 100, 30, 30, 100, 0, 0, 100, 30, 30, 100, 0, 30,\n\n\t    // under top rung\n\t    30, 30, 0, 30, 30, 30, 100, 30, 30, 30, 30, 0, 100, 30, 30, 100, 30, 0,\n\n\t    // between top rung and middle\n\t    30, 30, 0, 30, 60, 30, 30, 30, 30, 30, 30, 0, 30, 60, 0, 30, 60, 30,\n\n\t    // top of middle rung\n\t    30, 60, 0, 67, 60, 30, 30, 60, 30, 30, 60, 0, 67, 60, 0, 67, 60, 30,\n\n\t    // front of middle rung\n\t    67, 60, 0, 67, 90, 30, 67, 60, 30, 67, 60, 0, 67, 90, 0, 67, 90, 30,\n\n\t    // bottom of middle rung.\n\t    30, 90, 0, 30, 90, 30, 67, 90, 30, 30, 90, 0, 67, 90, 30, 67, 90, 0,\n\n\t    // front of bottom\n\t    30, 90, 0, 30, 150, 30, 30, 90, 30, 30, 90, 0, 30, 150, 0, 30, 150, 30,\n\n\t    // bottom\n\t    0, 150, 0, 0, 150, 30, 30, 150, 30, 0, 150, 0, 30, 150, 30, 30, 150, 0,\n\n\t    // left side\n\t    0, 0, 0, 0, 0, 30, 0, 150, 30, 0, 0, 0, 0, 150, 30, 0, 150, 0];\n\n\t    var texcoords = [\n\t    // left column front\n\t    0.22, 0.19, 0.22, 0.79, 0.34, 0.19, 0.22, 0.79, 0.34, 0.79, 0.34, 0.19,\n\n\t    // top rung front\n\t    0.34, 0.19, 0.34, 0.31, 0.62, 0.19, 0.34, 0.31, 0.62, 0.31, 0.62, 0.19,\n\n\t    // middle rung front\n\t    0.34, 0.43, 0.34, 0.55, 0.49, 0.43, 0.34, 0.55, 0.49, 0.55, 0.49, 0.43,\n\n\t    // left column back\n\t    0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1,\n\n\t    // top rung back\n\t    0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1,\n\n\t    // middle rung back\n\t    0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1,\n\n\t    // top\n\t    0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1,\n\n\t    // top rung front\n\t    0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1,\n\n\t    // under top rung\n\t    0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,\n\n\t    // between top rung and middle\n\t    0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1,\n\n\t    // top of middle rung\n\t    0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1,\n\n\t    // front of middle rung\n\t    0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1,\n\n\t    // bottom of middle rung.\n\t    0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,\n\n\t    // front of bottom\n\t    0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1,\n\n\t    // bottom\n\t    0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,\n\n\t    // left side\n\t    0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0];\n\n\t    var normals = expandRLEData([\n\t    // left column front\n\t    // top rung front\n\t    // middle rung front\n\t    18, 0, 0, 1,\n\n\t    // left column back\n\t    // top rung back\n\t    // middle rung back\n\t    18, 0, 0, -1,\n\n\t    // top\n\t    6, 0, 1, 0,\n\n\t    // top rung front\n\t    6, 1, 0, 0,\n\n\t    // under top rung\n\t    6, 0, -1, 0,\n\n\t    // between top rung and middle\n\t    6, 1, 0, 0,\n\n\t    // top of middle rung\n\t    6, 0, 1, 0,\n\n\t    // front of middle rung\n\t    6, 1, 0, 0,\n\n\t    // bottom of middle rung.\n\t    6, 0, -1, 0,\n\n\t    // front of bottom\n\t    6, 1, 0, 0,\n\n\t    // bottom\n\t    6, 0, -1, 0,\n\n\t    // left side\n\t    6, -1, 0, 0]);\n\n\t    var colors = expandRLEData([\n\t    // left column front\n\t    // top rung front\n\t    // middle rung front\n\t    18, 200, 70, 120,\n\n\t    // left column back\n\t    // top rung back\n\t    // middle rung back\n\t    18, 80, 70, 200,\n\n\t    // top\n\t    6, 70, 200, 210,\n\n\t    // top rung front\n\t    6, 200, 200, 70,\n\n\t    // under top rung\n\t    6, 210, 100, 70,\n\n\t    // between top rung and middle\n\t    6, 210, 160, 70,\n\n\t    // top of middle rung\n\t    6, 70, 180, 210,\n\n\t    // front of middle rung\n\t    6, 100, 70, 210,\n\n\t    // bottom of middle rung.\n\t    6, 76, 210, 100,\n\n\t    // front of bottom\n\t    6, 140, 210, 80,\n\n\t    // bottom\n\t    6, 90, 130, 110,\n\n\t    // left side\n\t    6, 160, 160, 220], [255]);\n\n\t    var numVerts = positions.length / 3;\n\n\t    var arrays = {\n\t      position: createAugmentedTypedArray(3, numVerts),\n\t      texcoord: createAugmentedTypedArray(2, numVerts),\n\t      normal: createAugmentedTypedArray(3, numVerts),\n\t      color: createAugmentedTypedArray(4, numVerts, Uint8Array),\n\t      indices: createAugmentedTypedArray(3, numVerts / 3, Uint16Array)\n\t    };\n\n\t    arrays.position.push(positions);\n\t    arrays.texcoord.push(texcoords);\n\t    arrays.normal.push(normals);\n\t    arrays.color.push(colors);\n\n\t    for (var ii = 0; ii < numVerts; ++ii) {\n\t      arrays.indices.push(ii);\n\t    }\n\n\t    return arrays;\n\t  }\n\n\t  /**\n\t   * Creates cresent BufferInfo.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} verticalRadius The vertical radius of the cresent.\n\t   * @param {number} outerRadius The outer radius of the cresent.\n\t   * @param {number} innerRadius The inner radius of the cresent.\n\t   * @param {number} thickness The thickness of the cresent.\n\t   * @param {number} subdivisionsDown number of steps around the cresent.\n\t   * @param {number} subdivisionsThick number of vertically on the cresent.\n\t   * @param {number} [startOffset] Where to start arc. Default 0.\n\t   * @param {number} [endOffset] Where to end arg. Default 1.\n\t   * @return {module:twgl.BufferInfo} The created BufferInfo.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createCresentBufferInfo\n\t   */\n\n\t  /**\n\t   * Creates cresent buffers.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} verticalRadius The vertical radius of the cresent.\n\t   * @param {number} outerRadius The outer radius of the cresent.\n\t   * @param {number} innerRadius The inner radius of the cresent.\n\t   * @param {number} thickness The thickness of the cresent.\n\t   * @param {number} subdivisionsDown number of steps around the cresent.\n\t   * @param {number} subdivisionsThick number of vertically on the cresent.\n\t   * @param {number} [startOffset] Where to start arc. Default 0.\n\t   * @param {number} [endOffset] Where to end arg. Default 1.\n\t   * @return {Object.<string, WebGLBuffer>} The created buffers.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createCresentBuffers\n\t   */\n\n\t  /**\n\t   * Creates cresent vertices.\n\t   *\n\t   * @param {number} verticalRadius The vertical radius of the cresent.\n\t   * @param {number} outerRadius The outer radius of the cresent.\n\t   * @param {number} innerRadius The inner radius of the cresent.\n\t   * @param {number} thickness The thickness of the cresent.\n\t   * @param {number} subdivisionsDown number of steps around the cresent.\n\t   * @param {number} subdivisionsThick number of vertically on the cresent.\n\t   * @param {number} [startOffset] Where to start arc. Default 0.\n\t   * @param {number} [endOffset] Where to end arg. Default 1.\n\t   * @return {Object.<string, TypedArray>} The created vertices.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function createCresentVertices(verticalRadius, outerRadius, innerRadius, thickness, subdivisionsDown, startOffset, endOffset) {\n\t    if (subdivisionsDown <= 0) {\n\t      throw Error('subdivisionDown must be > 0');\n\t    }\n\n\t    startOffset = startOffset || 0;\n\t    endOffset = endOffset || 1;\n\n\t    var subdivisionsThick = 2;\n\n\t    var offsetRange = endOffset - startOffset;\n\t    var numVertices = (subdivisionsDown + 1) * 2 * (2 + subdivisionsThick);\n\t    var positions = createAugmentedTypedArray(3, numVertices);\n\t    var normals = createAugmentedTypedArray(3, numVertices);\n\t    var texcoords = createAugmentedTypedArray(2, numVertices);\n\n\t    function lerp(a, b, s) {\n\t      return a + (b - a) * s;\n\t    }\n\n\t    function createArc(arcRadius, x, normalMult, normalAdd, uMult, uAdd) {\n\t      for (var z = 0; z <= subdivisionsDown; z++) {\n\t        var uBack = x / (subdivisionsThick - 1);\n\t        var v = z / subdivisionsDown;\n\t        var xBack = (uBack - 0.5) * 2;\n\t        var angle = (startOffset + v * offsetRange) * Math.PI;\n\t        var s = Math.sin(angle);\n\t        var c = Math.cos(angle);\n\t        var radius = lerp(verticalRadius, arcRadius, s);\n\t        var px = xBack * thickness;\n\t        var py = c * verticalRadius;\n\t        var pz = s * radius;\n\t        positions.push(px, py, pz);\n\t        var n = v3.add(v3.multiply([0, s, c], normalMult), normalAdd);\n\t        normals.push(n);\n\t        texcoords.push(uBack * uMult + uAdd, v);\n\t      }\n\t    }\n\n\t    // Generate the individual vertices in our vertex buffer.\n\t    for (var x = 0; x < subdivisionsThick; x++) {\n\t      var uBack = (x / (subdivisionsThick - 1) - 0.5) * 2;\n\t      createArc(outerRadius, x, [1, 1, 1], [0, 0, 0], 1, 0);\n\t      createArc(outerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 0);\n\t      createArc(innerRadius, x, [1, 1, 1], [0, 0, 0], 1, 0);\n\t      createArc(innerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 1);\n\t    }\n\n\t    // Do outer surface.\n\t    var indices = createAugmentedTypedArray(3, subdivisionsDown * 2 * (2 + subdivisionsThick), Uint16Array);\n\n\t    function createSurface(leftArcOffset, rightArcOffset) {\n\t      for (var z = 0; z < subdivisionsDown; ++z) {\n\t        // Make triangle 1 of quad.\n\t        indices.push(leftArcOffset + z + 0, leftArcOffset + z + 1, rightArcOffset + z + 0);\n\n\t        // Make triangle 2 of quad.\n\t        indices.push(leftArcOffset + z + 1, rightArcOffset + z + 1, rightArcOffset + z + 0);\n\t      }\n\t    }\n\n\t    var numVerticesDown = subdivisionsDown + 1;\n\t    // front\n\t    createSurface(numVerticesDown * 0, numVerticesDown * 4);\n\t    // right\n\t    createSurface(numVerticesDown * 5, numVerticesDown * 7);\n\t    // back\n\t    createSurface(numVerticesDown * 6, numVerticesDown * 2);\n\t    // left\n\t    createSurface(numVerticesDown * 3, numVerticesDown * 1);\n\n\t    return {\n\t      position: positions,\n\t      normal: normals,\n\t      texcoord: texcoords,\n\t      indices: indices\n\t    };\n\t  }\n\n\t  /**\n\t   * Creates cylinder BufferInfo. The cylinder will be created around the origin\n\t   * along the y-axis.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} radius Radius of cylinder.\n\t   * @param {number} height Height of cylinder.\n\t   * @param {number} radialSubdivisions The number of subdivisions around the cylinder.\n\t   * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.\n\t   * @param {boolean} [topCap] Create top cap. Default = true.\n\t   * @param {boolean} [bottomCap] Create bottom cap. Default = true.\n\t   * @return {module:twgl.BufferInfo} The created BufferInfo.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createCylinderBufferInfo\n\t   */\n\n\t  /**\n\t   * Creates cylinder buffers. The cylinder will be created around the origin\n\t   * along the y-axis.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} radius Radius of cylinder.\n\t   * @param {number} height Height of cylinder.\n\t   * @param {number} radialSubdivisions The number of subdivisions around the cylinder.\n\t   * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.\n\t   * @param {boolean} [topCap] Create top cap. Default = true.\n\t   * @param {boolean} [bottomCap] Create bottom cap. Default = true.\n\t   * @return {Object.<string, WebGLBuffer>} The created buffers.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createCylinderBuffers\n\t   */\n\n\t  /**\n\t   * Creates cylinder vertices. The cylinder will be created around the origin\n\t   * along the y-axis.\n\t   *\n\t   * @param {number} radius Radius of cylinder.\n\t   * @param {number} height Height of cylinder.\n\t   * @param {number} radialSubdivisions The number of subdivisions around the cylinder.\n\t   * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.\n\t   * @param {boolean} [topCap] Create top cap. Default = true.\n\t   * @param {boolean} [bottomCap] Create bottom cap. Default = true.\n\t   * @return {Object.<string, TypedArray>} The created vertices.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function createCylinderVertices(radius, height, radialSubdivisions, verticalSubdivisions, topCap, bottomCap) {\n\t    return createTruncatedConeVertices(radius, radius, height, radialSubdivisions, verticalSubdivisions, topCap, bottomCap);\n\t  }\n\n\t  /**\n\t   * Creates BufferInfo for a torus\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} radius radius of center of torus circle.\n\t   * @param {number} thickness radius of torus ring.\n\t   * @param {number} radialSubdivisions The number of subdivisions around the torus.\n\t   * @param {number} bodySubdivisions The number of subdivisions around the body torus.\n\t   * @param {boolean} [startAngle] start angle in radians. Default = 0.\n\t   * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.\n\t   * @return {module:twgl.BufferInfo} The created BufferInfo.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createTorusBufferInfo\n\t   */\n\n\t  /**\n\t   * Creates buffers for a torus\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} radius radius of center of torus circle.\n\t   * @param {number} thickness radius of torus ring.\n\t   * @param {number} radialSubdivisions The number of subdivisions around the torus.\n\t   * @param {number} bodySubdivisions The number of subdivisions around the body torus.\n\t   * @param {boolean} [startAngle] start angle in radians. Default = 0.\n\t   * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.\n\t   * @return {Object.<string, WebGLBuffer>} The created buffers.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createTorusBuffers\n\t   */\n\n\t  /**\n\t   * Creates vertices for a torus\n\t   *\n\t   * @param {number} radius radius of center of torus circle.\n\t   * @param {number} thickness radius of torus ring.\n\t   * @param {number} radialSubdivisions The number of subdivisions around the torus.\n\t   * @param {number} bodySubdivisions The number of subdivisions around the body torus.\n\t   * @param {boolean} [startAngle] start angle in radians. Default = 0.\n\t   * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.\n\t   * @return {Object.<string, TypedArray>} The created vertices.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function createTorusVertices(radius, thickness, radialSubdivisions, bodySubdivisions, startAngle, endAngle) {\n\t    if (radialSubdivisions < 3) {\n\t      throw Error('radialSubdivisions must be 3 or greater');\n\t    }\n\n\t    if (bodySubdivisions < 3) {\n\t      throw Error('verticalSubdivisions must be 3 or greater');\n\t    }\n\n\t    startAngle = startAngle || 0;\n\t    endAngle = endAngle || Math.PI * 2;\n\t    var range = endAngle - startAngle;\n\n\t    var radialParts = radialSubdivisions + 1;\n\t    var bodyParts = bodySubdivisions + 1;\n\t    var numVertices = radialParts * bodyParts;\n\t    var positions = createAugmentedTypedArray(3, numVertices);\n\t    var normals = createAugmentedTypedArray(3, numVertices);\n\t    var texcoords = createAugmentedTypedArray(2, numVertices);\n\t    var indices = createAugmentedTypedArray(3, radialSubdivisions * bodySubdivisions * 2, Uint16Array);\n\n\t    for (var slice = 0; slice < bodyParts; ++slice) {\n\t      var v = slice / bodySubdivisions;\n\t      var sliceAngle = v * Math.PI * 2;\n\t      var sliceSin = Math.sin(sliceAngle);\n\t      var ringRadius = radius + sliceSin * thickness;\n\t      var ny = Math.cos(sliceAngle);\n\t      var y = ny * thickness;\n\t      for (var ring = 0; ring < radialParts; ++ring) {\n\t        var u = ring / radialSubdivisions;\n\t        var ringAngle = startAngle + u * range;\n\t        var xSin = Math.sin(ringAngle);\n\t        var zCos = Math.cos(ringAngle);\n\t        var x = xSin * ringRadius;\n\t        var z = zCos * ringRadius;\n\t        var nx = xSin * sliceSin;\n\t        var nz = zCos * sliceSin;\n\t        positions.push(x, y, z);\n\t        normals.push(nx, ny, nz);\n\t        texcoords.push(u, 1 - v);\n\t      }\n\t    }\n\n\t    for (var slice = 0; slice < bodySubdivisions; ++slice) {\n\t      // eslint-disable-line\n\t      for (var ring = 0; ring < radialSubdivisions; ++ring) {\n\t        // eslint-disable-line\n\t        var nextRingIndex = 1 + ring;\n\t        var nextSliceIndex = 1 + slice;\n\t        indices.push(radialParts * slice + ring, radialParts * nextSliceIndex + ring, radialParts * slice + nextRingIndex);\n\t        indices.push(radialParts * nextSliceIndex + ring, radialParts * nextSliceIndex + nextRingIndex, radialParts * slice + nextRingIndex);\n\t      }\n\t    }\n\n\t    return {\n\t      position: positions,\n\t      normal: normals,\n\t      texcoord: texcoords,\n\t      indices: indices\n\t    };\n\t  }\n\n\t  /**\n\t   * Creates a disc BufferInfo. The disc will be in the xz plane, centered at\n\t   * the origin. When creating, at least 3 divisions, or pie\n\t   * pieces, need to be specified, otherwise the triangles making\n\t   * up the disc will be degenerate. You can also specify the\n\t   * number of radial pieces `stacks`. A value of 1 for\n\t   * stacks will give you a simple disc of pie pieces.  If you\n\t   * want to create an annulus you can set `innerRadius` to a\n\t   * value > 0. Finally, `stackPower` allows you to have the widths\n\t   * increase or decrease as you move away from the center. This\n\t   * is particularly useful when using the disc as a ground plane\n\t   * with a fixed camera such that you don't need the resolution\n\t   * of small triangles near the perimeter. For example, a value\n\t   * of 2 will produce stacks whose ouside radius increases with\n\t   * the square of the stack index. A value of 1 will give uniform\n\t   * stacks.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} radius Radius of the ground plane.\n\t   * @param {number} divisions Number of triangles in the ground plane (at least 3).\n\t   * @param {number} [stacks] Number of radial divisions (default=1).\n\t   * @param {number} [innerRadius] Default 0.\n\t   * @param {number} [stackPower] Power to raise stack size to for decreasing width.\n\t   * @return {module:twgl.BufferInfo} The created BufferInfo.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createDiscBufferInfo\n\t   */\n\n\t  /**\n\t   * Creates disc buffers. The disc will be in the xz plane, centered at\n\t   * the origin. When creating, at least 3 divisions, or pie\n\t   * pieces, need to be specified, otherwise the triangles making\n\t   * up the disc will be degenerate. You can also specify the\n\t   * number of radial pieces `stacks`. A value of 1 for\n\t   * stacks will give you a simple disc of pie pieces.  If you\n\t   * want to create an annulus you can set `innerRadius` to a\n\t   * value > 0. Finally, `stackPower` allows you to have the widths\n\t   * increase or decrease as you move away from the center. This\n\t   * is particularly useful when using the disc as a ground plane\n\t   * with a fixed camera such that you don't need the resolution\n\t   * of small triangles near the perimeter. For example, a value\n\t   * of 2 will produce stacks whose ouside radius increases with\n\t   * the square of the stack index. A value of 1 will give uniform\n\t   * stacks.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext.\n\t   * @param {number} radius Radius of the ground plane.\n\t   * @param {number} divisions Number of triangles in the ground plane (at least 3).\n\t   * @param {number} [stacks] Number of radial divisions (default=1).\n\t   * @param {number} [innerRadius] Default 0.\n\t   * @param {number} [stackPower] Power to raise stack size to for decreasing width.\n\t   * @return {Object.<string, WebGLBuffer>} The created buffers.\n\t   * @memberOf module:twgl/primitives\n\t   * @function createDiscBuffers\n\t   */\n\n\t  /**\n\t   * Creates disc vertices. The disc will be in the xz plane, centered at\n\t   * the origin. When creating, at least 3 divisions, or pie\n\t   * pieces, need to be specified, otherwise the triangles making\n\t   * up the disc will be degenerate. You can also specify the\n\t   * number of radial pieces `stacks`. A value of 1 for\n\t   * stacks will give you a simple disc of pie pieces.  If you\n\t   * want to create an annulus you can set `innerRadius` to a\n\t   * value > 0. Finally, `stackPower` allows you to have the widths\n\t   * increase or decrease as you move away from the center. This\n\t   * is particularly useful when using the disc as a ground plane\n\t   * with a fixed camera such that you don't need the resolution\n\t   * of small triangles near the perimeter. For example, a value\n\t   * of 2 will produce stacks whose ouside radius increases with\n\t   * the square of the stack index. A value of 1 will give uniform\n\t   * stacks.\n\t   *\n\t   * @param {number} radius Radius of the ground plane.\n\t   * @param {number} divisions Number of triangles in the ground plane (at least 3).\n\t   * @param {number} [stacks] Number of radial divisions (default=1).\n\t   * @param {number} [innerRadius] Default 0.\n\t   * @param {number} [stackPower] Power to raise stack size to for decreasing width.\n\t   * @return {Object.<string, TypedArray>} The created vertices.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function createDiscVertices(radius, divisions, stacks, innerRadius, stackPower) {\n\t    if (divisions < 3) {\n\t      throw Error('divisions must be at least 3');\n\t    }\n\n\t    stacks = stacks ? stacks : 1;\n\t    stackPower = stackPower ? stackPower : 1;\n\t    innerRadius = innerRadius ? innerRadius : 0;\n\n\t    // Note: We don't share the center vertex because that would\n\t    // mess up texture coordinates.\n\t    var numVertices = (divisions + 1) * (stacks + 1);\n\n\t    var positions = createAugmentedTypedArray(3, numVertices);\n\t    var normals = createAugmentedTypedArray(3, numVertices);\n\t    var texcoords = createAugmentedTypedArray(2, numVertices);\n\t    var indices = createAugmentedTypedArray(3, stacks * divisions * 2, Uint16Array);\n\n\t    var firstIndex = 0;\n\t    var radiusSpan = radius - innerRadius;\n\t    var pointsPerStack = divisions + 1;\n\n\t    // Build the disk one stack at a time.\n\t    for (var stack = 0; stack <= stacks; ++stack) {\n\t      var stackRadius = innerRadius + radiusSpan * Math.pow(stack / stacks, stackPower);\n\n\t      for (var i = 0; i <= divisions; ++i) {\n\t        var theta = 2.0 * Math.PI * i / divisions;\n\t        var x = stackRadius * Math.cos(theta);\n\t        var z = stackRadius * Math.sin(theta);\n\n\t        positions.push(x, 0, z);\n\t        normals.push(0, 1, 0);\n\t        texcoords.push(1 - i / divisions, stack / stacks);\n\t        if (stack > 0 && i !== divisions) {\n\t          // a, b, c and d are the indices of the vertices of a quad.  unless\n\t          // the current stack is the one closest to the center, in which case\n\t          // the vertices a and b connect to the center vertex.\n\t          var a = firstIndex + (i + 1);\n\t          var b = firstIndex + i;\n\t          var c = firstIndex + i - pointsPerStack;\n\t          var d = firstIndex + (i + 1) - pointsPerStack;\n\n\t          // Make a quad of the vertices a, b, c, d.\n\t          indices.push(a, b, c);\n\t          indices.push(a, c, d);\n\t        }\n\t      }\n\n\t      firstIndex += divisions + 1;\n\t    }\n\n\t    return {\n\t      position: positions,\n\t      normal: normals,\n\t      texcoord: texcoords,\n\t      indices: indices\n\t    };\n\t  }\n\n\t  /**\n\t   * creates a random integer between 0 and range - 1 inclusive.\n\t   * @param {number} range\n\t   * @return {number} random value between 0 and range - 1 inclusive.\n\t   */\n\t  function randInt(range) {\n\t    return Math.random() * range | 0;\n\t  }\n\n\t  /**\n\t   * Used to supply random colors\n\t   * @callback RandomColorFunc\n\t   * @param {number} ndx index of triangle/quad if unindexed or index of vertex if indexed\n\t   * @param {number} channel 0 = red, 1 = green, 2 = blue, 3 = alpha\n\t   * @return {number} a number from 0 to 255\n\t   * @memberOf module:twgl/primitives\n\t   */\n\n\t  /**\n\t   * @typedef {Object} RandomVerticesOptions\n\t   * @property {number} [vertsPerColor] Defaults to 3 for non-indexed vertices\n\t   * @property {module:twgl/primitives.RandomColorFunc} [rand] A function to generate random numbers\n\t   * @memberOf module:twgl/primitives\n\t   */\n\n\t  /**\n\t   * Creates an augmentedTypedArray of random vertex colors.\n\t   * If the vertices are indexed (have an indices array) then will\n\t   * just make random colors. Otherwise assumes they are triangles\n\t   * and makes one random color for every 3 vertices.\n\t   * @param {Object.<string, augmentedTypedArray>} vertices Vertices as returned from one of the createXXXVertices functions.\n\t   * @param {module:twgl/primitives.RandomVerticesOptions} [options] options.\n\t   * @return {Object.<string, augmentedTypedArray>} same vertices as passed in with `color` added.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function makeRandomVertexColors(vertices, options) {\n\t    options = options || {};\n\t    var numElements = vertices.position.numElements;\n\t    var vcolors = createAugmentedTypedArray(4, numElements, Uint8Array);\n\t    var rand = options.rand || function (ndx, channel) {\n\t      return channel < 3 ? randInt(256) : 255;\n\t    };\n\t    vertices.color = vcolors;\n\t    if (vertices.indices) {\n\t      // just make random colors if index\n\t      for (var ii = 0; ii < numElements; ++ii) {\n\t        vcolors.push(rand(ii, 0), rand(ii, 1), rand(ii, 2), rand(ii, 3));\n\t      }\n\t    } else {\n\t      // make random colors per triangle\n\t      var numVertsPerColor = options.vertsPerColor || 3;\n\t      var numSets = numElements / numVertsPerColor;\n\t      for (var ii = 0; ii < numSets; ++ii) {\n\t        // eslint-disable-line\n\t        var color = [rand(ii, 0), rand(ii, 1), rand(ii, 2), rand(ii, 3)];\n\t        for (var jj = 0; jj < numVertsPerColor; ++jj) {\n\t          vcolors.push(color);\n\t        }\n\t      }\n\t    }\n\t    return vertices;\n\t  }\n\n\t  /**\n\t   * creates a function that calls fn to create vertices and then\n\t   * creates a buffers for them\n\t   */\n\t  function createBufferFunc(fn) {\n\t    return function (gl) {\n\t      var arrays = fn.apply(this, Array.prototype.slice.call(arguments, 1));\n\t      return attributes.createBuffersFromArrays(gl, arrays);\n\t    };\n\t  }\n\n\t  /**\n\t   * creates a function that calls fn to create vertices and then\n\t   * creates a bufferInfo object for them\n\t   */\n\t  function createBufferInfoFunc(fn) {\n\t    return function (gl) {\n\t      var arrays = fn.apply(null, Array.prototype.slice.call(arguments, 1));\n\t      return attributes.createBufferInfoFromArrays(gl, arrays);\n\t    };\n\t  }\n\n\t  var arraySpecPropertyNames = [\"numComponents\", \"size\", \"type\", \"normalize\", \"stride\", \"offset\", \"attrib\", \"name\", \"attribName\"];\n\n\t  /**\n\t   * Copy elements from one array to another\n\t   *\n\t   * @param {Array|TypedArray} src source array\n\t   * @param {Array|TypedArray} dst dest array\n\t   * @param {number} dstNdx index in dest to copy src\n\t   * @param {number} [offset] offset to add to copied values\n\t   */\n\t  function copyElements(src, dst, dstNdx, offset) {\n\t    offset = offset || 0;\n\t    var length = src.length;\n\t    for (var ii = 0; ii < length; ++ii) {\n\t      dst[dstNdx + ii] = src[ii] + offset;\n\t    }\n\t  }\n\n\t  /**\n\t   * Creates an array of the same time\n\t   *\n\t   * @param {(number[]|ArrayBuffer|module:twgl.FullArraySpec)} srcArray array who's type to copy\n\t   * @param {number} length size of new array\n\t   * @return {(number[]|ArrayBuffer|module:twgl.FullArraySpec)} array with same type as srcArray\n\t   */\n\t  function createArrayOfSameType(srcArray, length) {\n\t    var arraySrc = getArray(srcArray);\n\t    var newArray = new arraySrc.constructor(length);\n\t    var newArraySpec = newArray;\n\t    // If it appears to have been augmented make new one augemented\n\t    if (arraySrc.numComponents && arraySrc.numElements) {\n\t      augmentTypedArray(newArray, arraySrc.numComponents);\n\t    }\n\t    // If it was a fullspec make new one a fullspec\n\t    if (srcArray.data) {\n\t      newArraySpec = {\n\t        data: newArray\n\t      };\n\t      utils.copyNamedProperties(arraySpecPropertyNames, srcArray, newArraySpec);\n\t    }\n\t    return newArraySpec;\n\t  }\n\n\t  /**\n\t   * Concatinates sets of vertices\n\t   *\n\t   * Assumes the vertices match in composition. For example\n\t   * if one set of vertices has positions, normals, and indices\n\t   * all sets of vertices must have positions, normals, and indices\n\t   * and of the same type.\n\t   *\n\t   * Example:\n\t   *\n\t   *      var cubeVertices = twgl.primtiives.createCubeVertices(2);\n\t   *      var sphereVertices = twgl.primitives.createSphereVertices(1, 10, 10);\n\t   *      // move the sphere 2 units up\n\t   *      twgl.primitives.reorientVertices(\n\t   *          sphereVertices, twgl.m4.translation([0, 2, 0]));\n\t   *      // merge the sphere with the cube\n\t   *      var cubeSphereVertices = twgl.primitives.concatVertices(\n\t   *          [cubeVertices, sphereVertices]);\n\t   *      // turn them into WebGL buffers and attrib data\n\t   *      var bufferInfo = twgl.createBufferInfoFromArrays(gl, cubeSphereVertices);\n\t   *\n\t   * @param {module:twgl.Arrays[]} arrays Array of arrays of vertices\n\t   * @return {module:twgl.Arrays} The concatinated vertices.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function concatVertices(arrayOfArrays) {\n\t    var names = {};\n\t    var baseName;\n\t    // get names of all arrays.\n\t    // and numElements for each set of vertices\n\t    for (var ii = 0; ii < arrayOfArrays.length; ++ii) {\n\t      var arrays = arrayOfArrays[ii];\n\t      Object.keys(arrays).forEach(function (name) {\n\t        // eslint-disable-line\n\t        if (!names[name]) {\n\t          names[name] = [];\n\t        }\n\t        if (!baseName && name !== 'indices') {\n\t          baseName = name;\n\t        }\n\t        var arrayInfo = arrays[name];\n\t        var numComponents = getNumComponents(arrayInfo, name);\n\t        var array = getArray(arrayInfo);\n\t        var numElements = array.length / numComponents;\n\t        names[name].push(numElements);\n\t      });\n\t    }\n\n\t    // compute length of combined array\n\t    // and return one for reference\n\t    function getLengthOfCombinedArrays(name) {\n\t      var length = 0;\n\t      var arraySpec;\n\t      for (var ii = 0; ii < arrayOfArrays.length; ++ii) {\n\t        var arrays = arrayOfArrays[ii];\n\t        var arrayInfo = arrays[name];\n\t        var array = getArray(arrayInfo);\n\t        length += array.length;\n\t        if (!arraySpec || arrayInfo.data) {\n\t          arraySpec = arrayInfo;\n\t        }\n\t      }\n\t      return {\n\t        length: length,\n\t        spec: arraySpec\n\t      };\n\t    }\n\n\t    function copyArraysToNewArray(name, base, newArray) {\n\t      var baseIndex = 0;\n\t      var offset = 0;\n\t      for (var ii = 0; ii < arrayOfArrays.length; ++ii) {\n\t        var arrays = arrayOfArrays[ii];\n\t        var arrayInfo = arrays[name];\n\t        var array = getArray(arrayInfo);\n\t        if (name === 'indices') {\n\t          copyElements(array, newArray, offset, baseIndex);\n\t          baseIndex += base[ii];\n\t        } else {\n\t          copyElements(array, newArray, offset);\n\t        }\n\t        offset += array.length;\n\t      }\n\t    }\n\n\t    var base = names[baseName];\n\n\t    var newArrays = {};\n\t    Object.keys(names).forEach(function (name) {\n\t      var info = getLengthOfCombinedArrays(name);\n\t      var newArraySpec = createArrayOfSameType(info.spec, info.length);\n\t      copyArraysToNewArray(name, base, getArray(newArraySpec));\n\t      newArrays[name] = newArraySpec;\n\t    });\n\t    return newArrays;\n\t  }\n\n\t  /**\n\t   * Creates a duplicate set of vertices\n\t   *\n\t   * This is useful for calling reorientVertices when you\n\t   * also want to keep the original available\n\t   *\n\t   * @param {module:twgl.Arrays} arrays of vertices\n\t   * @return {module:twgl.Arrays} The dupilicated vertices.\n\t   * @memberOf module:twgl/primitives\n\t   */\n\t  function duplicateVertices(arrays) {\n\t    var newArrays = {};\n\t    Object.keys(arrays).forEach(function (name) {\n\t      var arraySpec = arrays[name];\n\t      var srcArray = getArray(arraySpec);\n\t      var newArraySpec = createArrayOfSameType(arraySpec, srcArray.length);\n\t      copyElements(srcArray, getArray(newArraySpec), 0);\n\t      newArrays[name] = newArraySpec;\n\t    });\n\t    return newArrays;\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"create3DFBufferInfo\": createBufferInfoFunc(create3DFVertices),\n\t    \"create3DFBuffers\": createBufferFunc(create3DFVertices),\n\t    \"create3DFVertices\": create3DFVertices,\n\t    \"createAugmentedTypedArray\": createAugmentedTypedArray,\n\t    \"createCubeBufferInfo\": createBufferInfoFunc(createCubeVertices),\n\t    \"createCubeBuffers\": createBufferFunc(createCubeVertices),\n\t    \"createCubeVertices\": createCubeVertices,\n\t    \"createPlaneBufferInfo\": createBufferInfoFunc(createPlaneVertices),\n\t    \"createPlaneBuffers\": createBufferFunc(createPlaneVertices),\n\t    \"createPlaneVertices\": createPlaneVertices,\n\t    \"createSphereBufferInfo\": createBufferInfoFunc(createSphereVertices),\n\t    \"createSphereBuffers\": createBufferFunc(createSphereVertices),\n\t    \"createSphereVertices\": createSphereVertices,\n\t    \"createTruncatedConeBufferInfo\": createBufferInfoFunc(createTruncatedConeVertices),\n\t    \"createTruncatedConeBuffers\": createBufferFunc(createTruncatedConeVertices),\n\t    \"createTruncatedConeVertices\": createTruncatedConeVertices,\n\t    \"createXYQuadBufferInfo\": createBufferInfoFunc(createXYQuadVertices),\n\t    \"createXYQuadBuffers\": createBufferFunc(createXYQuadVertices),\n\t    \"createXYQuadVertices\": createXYQuadVertices,\n\t    \"createCresentBufferInfo\": createBufferInfoFunc(createCresentVertices),\n\t    \"createCresentBuffers\": createBufferFunc(createCresentVertices),\n\t    \"createCresentVertices\": createCresentVertices,\n\t    \"createCylinderBufferInfo\": createBufferInfoFunc(createCylinderVertices),\n\t    \"createCylinderBuffers\": createBufferFunc(createCylinderVertices),\n\t    \"createCylinderVertices\": createCylinderVertices,\n\t    \"createTorusBufferInfo\": createBufferInfoFunc(createTorusVertices),\n\t    \"createTorusBuffers\": createBufferFunc(createTorusVertices),\n\t    \"createTorusVertices\": createTorusVertices,\n\t    \"createDiscBufferInfo\": createBufferInfoFunc(createDiscVertices),\n\t    \"createDiscBuffers\": createBufferFunc(createDiscVertices),\n\t    \"createDiscVertices\": createDiscVertices,\n\t    \"deindexVertices\": deindexVertices,\n\t    \"flattenNormals\": flattenNormals,\n\t    \"makeRandomVertexColors\": makeRandomVertexColors,\n\t    \"reorientDirections\": reorientDirections,\n\t    \"reorientNormals\": reorientNormals,\n\t    \"reorientPositions\": reorientPositions,\n\t    \"reorientVertices\": reorientVertices,\n\t    \"concatVertices\": concatVertices,\n\t    \"duplicateVertices\": duplicateVertices\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }\n/******/ ])\n});\n;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/twgl.js/dist/3.x/twgl-full.js\n// module id = 0\n// module chunks = 0","/*!\n * @license twgl.js 3.3.0 Copyright (c) 2015, Gregg Tavares All Rights Reserved.\n * Available via the MIT license.\n * see: http://github.com/greggman/twgl.js for details\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"twgl\"] = factory();\n\telse\n\t\troot[\"twgl\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (twgl) {\n\t  \"use strict\";\n\n\t  return twgl;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(7), __webpack_require__(6), __webpack_require__(8), __webpack_require__(3), __webpack_require__(9), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (attributes, draw, framebuffers, programs, textures, typedArrays, vertexArrays, utils) {\n\t  \"use strict\";\n\n\t  /**\n\t   * The main TWGL module.\n\t   *\n\t   * For most use cases you shouldn't need anything outside this module.\n\t   * Exceptions between the stuff added to twgl-full (v3, m4, primitives)\n\t   *\n\t   * @module twgl\n\t   * @borrows module:twgl/attributes.setAttribInfoBufferFromArray as setAttribInfoBufferFromArray\n\t   * @borrows module:twgl/attributes.createBufferInfoFromArrays as createBufferInfoFromArrays\n\t   * @borrows module:twgl/attributes.createVertexArrayInfo as createVertexArrayInfo\n\t   * @borrows module:twgl/draw.drawBufferInfo as drawBufferInfo\n\t   * @borrows module:twgl/draw.drawObjectList as drawObjectList\n\t   * @borrows module:twgl/framebuffers.createFramebufferInfo as createFramebufferInfo\n\t   * @borrows module:twgl/framebuffers.resizeFramebufferInfo as resizeFramebufferInfo\n\t   * @borrows module:twgl/framebuffers.bindFramebufferInfo as bindFramebufferInfo\n\t   * @borrows module:twgl/programs.createProgramInfo as createProgramInfo\n\t   * @borrows module:twgl/programs.createUniformBlockInfo as createUniformBlockInfo\n\t   * @borrows module:twgl/programs.bindUniformBlock as bindUniformBlock\n\t   * @borrows module:twgl/programs.setUniformBlock as setUniformBlock\n\t   * @borrows module:twgl/programs.setBlockUniforms as setBlockUniforms\n\t   * @borrows module:twgl/programs.setUniforms as setUniforms\n\t   * @borrows module:twgl/programs.setBuffersAndAttributes as setBuffersAndAttributes\n\t   * @borrows module:twgl/textures.setTextureFromArray as setTextureFromArray\n\t   * @borrows module:twgl/textures.createTexture as createTexture\n\t   * @borrows module:twgl/textures.resizeTexture as resizeTexture\n\t   * @borrows module:twgl/textures.createTextures as createTextures\n\t   */\n\n\t  // make sure we don't see a global gl\n\n\t  var gl = undefined; // eslint-disable-line\n\t  var defaults = {\n\t    enableVertexArrayObjects: true\n\t  };\n\n\t  /**\n\t   * Various default settings for twgl.\n\t   *\n\t   * Note: You can call this any number of times. Example:\n\t   *\n\t   *     twgl.setDefaults({ textureColor: [1, 0, 0, 1] });\n\t   *     twgl.setDefaults({ attribPrefix: 'a_' });\n\t   *\n\t   * is equivalent to\n\t   *\n\t   *     twgl.setDefaults({\n\t   *       textureColor: [1, 0, 0, 1],\n\t   *       attribPrefix: 'a_',\n\t   *     });\n\t   *\n\t   * @typedef {Object} Defaults\n\t   * @property {string} attribPrefix The prefix to stick on attributes\n\t   *\n\t   *   When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`\n\t   *   as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.\n\t   *\n\t   *   In otherwords I'll create arrays of geometry like this\n\t   *\n\t   *       var arrays = {\n\t   *         position: ...\n\t   *         normal: ...\n\t   *         texcoord: ...\n\t   *       };\n\t   *\n\t   *   But need those mapped to attributes and my attributes start with `a_`.\n\t   *\n\t   *   Default: `\"\"`\n\t   *\n\t   * @property {number[]} textureColor Array of 4 values in the range 0 to 1\n\t   *\n\t   *   The default texture color is used when loading textures from\n\t   *   urls. Because the URL will be loaded async we'd like to be\n\t   *   able to use the texture immediately. By putting a 1x1 pixel\n\t   *   color in the texture we can start using the texture before\n\t   *   the URL has loaded.\n\t   *\n\t   *   Default: `[0.5, 0.75, 1, 1]`\n\t   *\n\t   * @property {string} crossOrigin\n\t   *\n\t   *   If not undefined sets the crossOrigin attribute on images\n\t   *   that twgl creates when downloading images for textures.\n\t   *\n\t   *   Also see {@link module:twgl.TextureOptions}.\n\t   *\n\t   * @property {bool} enableVertexArrayObjects\n\t   *\n\t   *   If true then in WebGL 1.0 will attempt to get the `OES_vertex_array_object` extension.\n\t   *   If successful it will copy create/bind/delete/isVertexArrayOES from the extension to\n\t   *   the WebGLRenderingContext removing the OES at the end which is the standard entry point\n\t   *   for WebGL 2.\n\t   *\n\t   *   Note: According to webglstats.com 90% of devices support `OES_vertex_array_object`.\n\t   *   If you just want to count on support I suggest using [this polyfill](https://github.com/KhronosGroup/WebGL/blob/master/sdk/demos/google/resources/OESVertexArrayObject.js)\n\t   *   or ignoring devices that don't support them.\n\t   *\n\t   *   Default: `true`\n\t   *\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Sets various defaults for twgl.\n\t   *\n\t   * In the interest of terseness which is kind of the point\n\t   * of twgl I've integrated a few of the older functions here\n\t   *\n\t   * @param {module:twgl.Defaults} newDefaults The default settings.\n\t   * @memberOf module:twgl\n\t   */\n\t  function setDefaults(newDefaults) {\n\t    utils.copyExistingProperties(newDefaults, defaults);\n\t    attributes.setDefaults_(newDefaults); // eslint-disable-line\n\t    textures.setDefaults_(newDefaults); // eslint-disable-line\n\t  }\n\n\t  /**\n\t   * Adds Vertex Array Objects to WebGL 1 GL contexts if available\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   */\n\t  function addVertexArrayObjectSupport(gl) {\n\t    if (!gl || !defaults.enableVertexArrayObjects) {\n\t      return;\n\t    }\n\t    if (utils.isWebGL1(gl)) {\n\t      var ext = gl.getExtension(\"OES_vertex_array_object\");\n\t      if (ext) {\n\t        gl.createVertexArray = function () {\n\t          return ext.createVertexArrayOES();\n\t        };\n\t        gl.deleteVertexArray = function (v) {\n\t          ext.deleteVertexArrayOES(v);\n\t        };\n\t        gl.isVertexArray = function (v) {\n\t          return ext.isVertexArrayOES(v);\n\t        };\n\t        gl.bindVertexArray = function (v) {\n\t          ext.bindVertexArrayOES(v);\n\t        };\n\t        gl.VERTEX_ARRAY_BINDING = ext.VERTEX_ARRAY_BINDING_OES;\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * Creates a webgl context.\n\t   * @param {HTMLCanvasElement} canvas The canvas tag to get\n\t   *     context from. If one is not passed in one will be\n\t   *     created.\n\t   * @return {WebGLRenderingContext} The created context.\n\t   */\n\t  function create3DContext(canvas, opt_attribs) {\n\t    var names = [\"webgl\", \"experimental-webgl\"];\n\t    var context = null;\n\t    for (var ii = 0; ii < names.length; ++ii) {\n\t      context = canvas.getContext(names[ii], opt_attribs);\n\t      if (context) {\n\t        break;\n\t      }\n\t    }\n\t    return context;\n\t  }\n\n\t  /**\n\t   * Gets a WebGL context.\n\t   * @param {HTMLCanvasElement} canvas a canvas element.\n\t   * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes\n\t   * @memberOf module:twgl\n\t   */\n\t  function getWebGLContext(canvas, opt_attribs) {\n\t    var gl = create3DContext(canvas, opt_attribs);\n\t    addVertexArrayObjectSupport(gl);\n\t    return gl;\n\t  }\n\n\t  /**\n\t   * Creates a webgl context.\n\t   *\n\t   * Will return a WebGL2 context if possible.\n\t   *\n\t   * You can check if it's WebGL2 with\n\t   *\n\t   *     twgl.isWebGL2(gl);\n\t   *\n\t   * @param {HTMLCanvasElement} canvas The canvas tag to get\n\t   *     context from. If one is not passed in one will be\n\t   *     created.\n\t   * @return {WebGLRenderingContext} The created context.\n\t   */\n\t  function createContext(canvas, opt_attribs) {\n\t    var names = [\"webgl2\", \"webgl\", \"experimental-webgl\"];\n\t    var context = null;\n\t    for (var ii = 0; ii < names.length; ++ii) {\n\t      context = canvas.getContext(names[ii], opt_attribs);\n\t      if (context) {\n\t        break;\n\t      }\n\t    }\n\t    return context;\n\t  }\n\n\t  /**\n\t   * Gets a WebGL context.  Will create a WebGL2 context if possible.\n\t   *\n\t   * You can check if it's WebGL2 with\n\t   *\n\t   *    function isWebGL2(gl) {\n\t   *      return gl.getParameter(gl.VERSION).indexOf(\"WebGL 2.0 \") == 0;\n\t   *    }\n\t   *\n\t   * @param {HTMLCanvasElement} canvas a canvas element.\n\t   * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes\n\t   * @return {WebGLRenderingContext} The created context.\n\t   * @memberOf module:twgl\n\t   */\n\t  function getContext(canvas, opt_attribs) {\n\t    var gl = createContext(canvas, opt_attribs);\n\t    addVertexArrayObjectSupport(gl);\n\t    return gl;\n\t  }\n\n\t  /**\n\t   * Resize a canvas to match the size it's displayed.\n\t   * @param {HTMLCanvasElement} canvas The canvas to resize.\n\t   * @param {number} [multiplier] So you can pass in `window.devicePixelRatio` if you want to.\n\t   * @return {boolean} true if the canvas was resized.\n\t   * @memberOf module:twgl\n\t   */\n\t  function resizeCanvasToDisplaySize(canvas, multiplier) {\n\t    multiplier = multiplier || 1;\n\t    multiplier = Math.max(1, multiplier);\n\t    var width = canvas.clientWidth * multiplier | 0;\n\t    var height = canvas.clientHeight * multiplier | 0;\n\t    if (canvas.width !== width || canvas.height !== height) {\n\t      canvas.width = width;\n\t      canvas.height = height;\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  var api = {\n\t    \"getContext\": getContext,\n\t    \"getWebGLContext\": getWebGLContext,\n\t    \"isWebGL1\": utils.isWebGL1,\n\t    \"isWebGL2\": utils.isWebGL2,\n\t    \"resizeCanvasToDisplaySize\": resizeCanvasToDisplaySize,\n\t    \"setDefaults\": setDefaults\n\t  };\n\n\t  function notPrivate(name) {\n\t    return name[name.length - 1] !== '_';\n\t  }\n\n\t  function copyPublicProperties(src, dst) {\n\t    Object.keys(src).filter(notPrivate).forEach(function (key) {\n\t      dst[key] = src[key];\n\t    });\n\t    return dst;\n\t  }\n\n\t  var apis = {\n\t    attributes: attributes,\n\t    draw: draw,\n\t    framebuffers: framebuffers,\n\t    programs: programs,\n\t    textures: textures,\n\t    typedArrays: typedArrays,\n\t    vertexArrays: vertexArrays\n\t  };\n\t  Object.keys(apis).forEach(function (name) {\n\t    var srcApi = apis[name];\n\t    copyPublicProperties(srcApi, api);\n\t    api[name] = copyPublicProperties(srcApi, {});\n\t  });\n\n\t  return api;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (typedArrays, utils) {\n\t  \"use strict\";\n\n\t  /**\n\t   * Low level attribute and buffer related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.attributes` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/attributes\n\t   */\n\n\t  // make sure we don't see a global gl\n\n\t  var gl = undefined; // eslint-disable-line\n\t  var defaults = {\n\t    attribPrefix: \"\"\n\t  };\n\n\t  /**\n\t   * Sets the default attrib prefix\n\t   *\n\t   * When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`\n\t   * as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.\n\t   *\n\t   * In otherwords I'll create arrays of geometry like this\n\t   *\n\t   *     var arrays = {\n\t   *       position: ...\n\t   *       normal: ...\n\t   *       texcoord: ...\n\t   *     };\n\t   *\n\t   * But need those mapped to attributes and my attributes start with `a_`.\n\t   *\n\t   * @deprecated see {@link module:twgl.setDefaults}\n\t   * @param {string} prefix prefix for attribs\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function setAttributePrefix(prefix) {\n\t    defaults.attribPrefix = prefix;\n\t  }\n\n\t  function setDefaults(newDefaults) {\n\t    utils.copyExistingProperties(newDefaults, defaults);\n\t  }\n\n\t  function setBufferFromTypedArray(gl, type, buffer, array, drawType) {\n\t    gl.bindBuffer(type, buffer);\n\t    gl.bufferData(type, array, drawType || gl.STATIC_DRAW);\n\t  }\n\n\t  /**\n\t   * Given typed array creates a WebGLBuffer and copies the typed array\n\t   * into it.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {ArrayBuffer|ArrayBufferView|WebGLBuffer} typedArray the typed array. Note: If a WebGLBuffer is passed in it will just be returned. No action will be taken\n\t   * @param {number} [type] the GL bind type for the buffer. Default = `gl.ARRAY_BUFFER`.\n\t   * @param {number} [drawType] the GL draw type for the buffer. Default = 'gl.STATIC_DRAW`.\n\t   * @return {WebGLBuffer} the created WebGLBuffer\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBufferFromTypedArray(gl, typedArray, type, drawType) {\n\t    if (typedArray instanceof WebGLBuffer) {\n\t      return typedArray;\n\t    }\n\t    type = type || gl.ARRAY_BUFFER;\n\t    var buffer = gl.createBuffer();\n\t    setBufferFromTypedArray(gl, type, buffer, typedArray, drawType);\n\t    return buffer;\n\t  }\n\n\t  function isIndices(name) {\n\t    return name === \"indices\";\n\t  }\n\n\t  // This is really just a guess. Though I can't really imagine using\n\t  // anything else? Maybe for some compression?\n\t  function getNormalizationForTypedArray(typedArray) {\n\t    if (typedArray instanceof Int8Array) {\n\t      return true;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Uint8Array) {\n\t      return true;\n\t    } // eslint-disable-line\n\t    return false;\n\t  }\n\n\t  // This is really just a guess. Though I can't really imagine using\n\t  // anything else? Maybe for some compression?\n\t  function getNormalizationForTypedArrayType(typedArrayType) {\n\t    if (typedArrayType === Int8Array) {\n\t      return true;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Uint8Array) {\n\t      return true;\n\t    } // eslint-disable-line\n\t    return false;\n\t  }\n\n\t  function getArray(array) {\n\t    return array.length ? array : array.data;\n\t  }\n\n\t  var texcoordRE = /coord|texture/i;\n\t  var colorRE = /color|colour/i;\n\n\t  function guessNumComponentsFromName(name, length) {\n\t    var numComponents;\n\t    if (texcoordRE.test(name)) {\n\t      numComponents = 2;\n\t    } else if (colorRE.test(name)) {\n\t      numComponents = 4;\n\t    } else {\n\t      numComponents = 3; // position, normals, indices ...\n\t    }\n\n\t    if (length % numComponents > 0) {\n\t      throw \"Can not guess numComponents for attribute '\" + name + \"'. Tried \" + numComponents + \" but \" + length + \" values is not evenly divisible by \" + numComponents + \". You should specify it.\";\n\t    }\n\n\t    return numComponents;\n\t  }\n\n\t  function getNumComponents(array, arrayName) {\n\t    return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);\n\t  }\n\n\t  function makeTypedArray(array, name) {\n\t    if (typedArrays.isArrayBuffer(array)) {\n\t      return array;\n\t    }\n\n\t    if (typedArrays.isArrayBuffer(array.data)) {\n\t      return array.data;\n\t    }\n\n\t    if (Array.isArray(array)) {\n\t      array = {\n\t        data: array\n\t      };\n\t    }\n\n\t    var Type = array.type;\n\t    if (!Type) {\n\t      if (isIndices(name)) {\n\t        Type = Uint16Array;\n\t      } else {\n\t        Type = Float32Array;\n\t      }\n\t    }\n\t    return new Type(array.data);\n\t  }\n\n\t  /**\n\t   * The info for an attribute. This is effectively just the arguments to `gl.vertexAttribPointer` plus the WebGLBuffer\n\t   * for the attribute.\n\t   *\n\t   * @typedef {Object} AttribInfo\n\t   * @property {number} [numComponents] the number of components for this attribute.\n\t   * @property {number} [size] synonym for `numComponents`.\n\t   * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`\n\t   * @property {boolean} [normalize] whether or not to normalize the data. Default = false\n\t   * @property {number} [offset] offset into buffer in bytes. Default = 0\n\t   * @property {number} [stride] the stride in bytes per element. Default = 0\n\t   * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute\n\t   * @property {number} [drawType] the draw type passed to gl.bufferData. Default = gl.STATIC_DRAW\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Use this type of array spec when TWGL can't guess the type or number of compoments of an array\n\t   * @typedef {Object} FullArraySpec\n\t   * @property {(number|number[]|ArrayBuffer)} data The data of the array. A number alone becomes the number of elements of type.\n\t   * @property {number} [numComponents] number of components for `vertexAttribPointer`. Default is based on the name of the array.\n\t   *    If `coord` is in the name assumes `numComponents = 2`.\n\t   *    If `color` is in the name assumes `numComponents = 4`.\n\t   *    otherwise assumes `numComponents = 3`\n\t   * @property {constructor} type The type. This is only used if `data` is a JavaScript array. It is the constructor for the typedarray. (eg. `Uint8Array`).\n\t   * For example if you want colors in a `Uint8Array` you might have a `FullArraySpec` like `{ type: Uint8Array, data: [255,0,255,255, ...], }`.\n\t   * @property {number} [size] synonym for `numComponents`.\n\t   * @property {boolean} [normalize] normalize for `vertexAttribPointer`. Default is true if type is `Int8Array` or `Uint8Array` otherwise false.\n\t   * @property {number} [stride] stride for `vertexAttribPointer`. Default = 0\n\t   * @property {number} [offset] offset for `vertexAttribPointer`. Default = 0\n\t   * @property {string} [attrib] name of attribute this array maps to. Defaults to same name as array prefixed by the default attribPrefix.\n\t   * @property {string} [name] synonym for `attrib`.\n\t   * @property {string} [attribName] synonym for `attrib`.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * An individual array in {@link module:twgl.Arrays}\n\t   *\n\t   * When passed to {@link module:twgl.createBufferInfoFromArrays} if an ArraySpec is `number[]` or `ArrayBuffer`\n\t   * the types will be guessed based on the name. `indices` will be `Uint16Array`, everything else will\n\t   * be `Float32Array`. If an ArraySpec is a number it's the number of floats for an empty (zeroed) buffer.\n\t   *\n\t   * @typedef {(number|number[]|ArrayBuffer|module:twgl.FullArraySpec)} ArraySpec\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * This is a JavaScript object of arrays by name. The names should match your shader's attributes. If your\n\t   * attributes have a common prefix you can specify it by calling {@link module:twgl.setAttributePrefix}.\n\t   *\n\t   *     Bare JavaScript Arrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: [-1, 1, 0],\n\t   *            normal: [0, 1, 0],\n\t   *            ...\n\t   *         }\n\t   *\n\t   *     Bare TypedArrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: new Float32Array([-1, 1, 0]),\n\t   *            color: new Uint8Array([255, 128, 64, 255]),\n\t   *            ...\n\t   *         }\n\t   *\n\t   * *   Will guess at `numComponents` if not specified based on name.\n\t   *\n\t   *     If `coord` is in the name assumes `numComponents = 2`\n\t   *\n\t   *     If `color` is in the name assumes `numComponents = 4`\n\t   *\n\t   *     otherwise assumes `numComponents = 3`\n\t   *\n\t   * Objects with various fields. See {@link module:twgl.FullArraySpec}.\n\t   *\n\t   *     var arrays = {\n\t   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n\t   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n\t   *     };\n\t   *\n\t   * @typedef {Object.<string, module:twgl.ArraySpec>} Arrays\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a set of attribute data and WebGLBuffers from set of arrays\n\t   *\n\t   * Given\n\t   *\n\t   *      var arrays = {\n\t   *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n\t   *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },\n\t   *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n\t   *      };\n\t   *\n\t   * returns something like\n\t   *\n\t   *      var attribs = {\n\t   *        position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n\t   *        texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n\t   *        normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n\t   *        color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },\n\t   *      };\n\t   *\n\t   * notes:\n\t   *\n\t   * *   Arrays can take various forms\n\t   *\n\t   *     Bare JavaScript Arrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: [-1, 1, 0],\n\t   *            normal: [0, 1, 0],\n\t   *            ...\n\t   *         }\n\t   *\n\t   *     Bare TypedArrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: new Float32Array([-1, 1, 0]),\n\t   *            color: new Uint8Array([255, 128, 64, 255]),\n\t   *            ...\n\t   *         }\n\t   *\n\t   * *   Will guess at `numComponents` if not specified based on name.\n\t   *\n\t   *     If `coord` is in the name assumes `numComponents = 2`\n\t   *\n\t   *     If `color` is in the name assumes `numComponents = 4`\n\t   *\n\t   *     otherwise assumes `numComponents = 3`\n\t   *\n\t   * @param {WebGLRenderingContext} gl The webgl rendering context.\n\t   * @param {module:twgl.Arrays} arrays The arrays\n\t   * @return {Object.<string, module:twgl.AttribInfo>} the attribs\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createAttribsFromArrays(gl, arrays) {\n\t    var attribs = {};\n\t    Object.keys(arrays).forEach(function (arrayName) {\n\t      if (!isIndices(arrayName)) {\n\t        var array = arrays[arrayName];\n\t        var attribName = array.attrib || array.name || array.attribName || defaults.attribPrefix + arrayName;\n\t        var buffer;\n\t        var type;\n\t        var normalization;\n\t        var numComponents;\n\t        var numValues;\n\t        if (typeof array === \"number\" || typeof array.data === \"number\") {\n\t          numValues = array.data || array;\n\t          var arrayType = array.type || Float32Array;\n\t          var numBytes = numValues * arrayType.BYTES_PER_ELEMENT;\n\t          type = typedArrays.getGLTypeForTypedArrayType(arrayType);\n\t          normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArrayType(arrayType);\n\t          numComponents = array.numComponents || array.size || guessNumComponentsFromName(arrayName, numValues);\n\t          buffer = gl.createBuffer();\n\t          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t          gl.bufferData(gl.ARRAY_BUFFER, numBytes, array.drawType || gl.STATIC_DRAW);\n\t        } else {\n\t          var typedArray = makeTypedArray(array, arrayName);\n\t          buffer = createBufferFromTypedArray(gl, typedArray, undefined, array.drawType);\n\t          type = typedArrays.getGLTypeForTypedArray(typedArray);\n\t          normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArray(typedArray);\n\t          numComponents = getNumComponents(array, arrayName);\n\t          numValues = typedArray.length;\n\t        }\n\t        attribs[attribName] = {\n\t          buffer: buffer,\n\t          numComponents: numComponents,\n\t          type: type,\n\t          normalize: normalization,\n\t          stride: array.stride || 0,\n\t          offset: array.offset || 0,\n\t          drawType: array.drawType\n\t        };\n\t      }\n\t    });\n\t    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\t    return attribs;\n\t  }\n\n\t  /**\n\t   * Sets the contents of a buffer attached to an attribInfo\n\t   *\n\t   * This is helper function to dynamically update a buffer.\n\t   *\n\t   * Let's say you make a bufferInfo\n\t   *\n\t   *     var arrays = {\n\t   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n\t   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n\t   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n\t   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n\t   *     };\n\t   *     var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\n\t   *\n\t   *  And you want to dynamically upate the positions. You could do this\n\t   *\n\t   *     // assuming arrays.position has already been updated with new data.\n\t   *     twgl.setAttribInfoBufferFromArray(gl, bufferInfo.attribs.position, arrays.position);\n\t   *\n\t   * @param {WebGLRenderingContext} gl\n\t   * @param {AttribInfo} attribInfo The attribInfo who's buffer contents to set. NOTE: If you have an attribute prefix\n\t   *   the name of the attribute will include the prefix.\n\t   * @param {ArraySpec} array Note: it is arguably ineffient to pass in anything but a typed array because anything\n\t   *    else will have to be converted to a typed array before it can be used by WebGL. During init time that\n\t   *    inefficiency is usually not important but if you're updating data dynamically best to be efficient.\n\t   * @param {number} [offset] an optional offset into the buffer. This is only an offset into the WebGL buffer\n\t   *    not the array. To pass in an offset into the array itself use a typed array and create an `ArrayBufferView`\n\t   *    for the portion of the array you want to use.\n\t   *\n\t   *        var someArray = new Float32Array(1000); // an array with 1000 floats\n\t   *        var someSubArray = new Float32Array(someArray.buffer, offsetInBytes, sizeInUnits); // a view into someArray\n\t   *\n\t   *    Now you can pass `someSubArray` into setAttribInfoBufferFromArray`\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function setAttribInfoBufferFromArray(gl, attribInfo, array, offset) {\n\t    array = makeTypedArray(array);\n\t    if (offset !== undefined) {\n\t      gl.bindBuffer(gl.ARRAY_BUFFER, attribInfo.buffer);\n\t      gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);\n\t    } else {\n\t      setBufferFromTypedArray(gl, gl.ARRAY_BUFFER, attribInfo.buffer, array, attribInfo.drawType);\n\t    }\n\t  }\n\n\t  function getBytesPerValueForGLType(gl, type) {\n\t    if (type === gl.BYTE) return 1; // eslint-disable-line\n\t    if (type === gl.UNSIGNED_BYTE) return 1; // eslint-disable-line\n\t    if (type === gl.SHORT) return 2; // eslint-disable-line\n\t    if (type === gl.UNSIGNED_SHORT) return 2; // eslint-disable-line\n\t    if (type === gl.INT) return 4; // eslint-disable-line\n\t    if (type === gl.UNSIGNED_INT) return 4; // eslint-disable-line\n\t    if (type === gl.FLOAT) return 4; // eslint-disable-line\n\t    return 0;\n\t  }\n\n\t  /**\n\t   * tries to get the number of elements from a set of arrays.\n\t   */\n\t  var positionKeys = ['position', 'positions', 'a_position'];\n\t  function getNumElementsFromNonIndexedArrays(arrays) {\n\t    var key;\n\t    for (var ii = 0; ii < positionKeys.length; ++ii) {\n\t      key = positionKeys[ii];\n\t      if (key in arrays) {\n\t        break;\n\t      }\n\t    }\n\t    if (ii === positionKeys.length) {\n\t      key = Object.keys(arrays)[0];\n\t    }\n\t    var array = arrays[key];\n\t    var length = getArray(array).length;\n\t    var numComponents = getNumComponents(array, key);\n\t    var numElements = length / numComponents;\n\t    if (length % numComponents > 0) {\n\t      throw \"numComponents \" + numComponents + \" not correct for length \" + length;\n\t    }\n\t    return numElements;\n\t  }\n\n\t  function getNumElementsFromAttributes(gl, attribs) {\n\t    var key;\n\t    for (var ii = 0; ii < positionKeys.length; ++ii) {\n\t      key = positionKeys[ii];\n\t      if (key in attribs) {\n\t        break;\n\t      }\n\t      key = defaults.attribPrefix + key;\n\t      if (key in attribs) {\n\t        break;\n\t      }\n\t    }\n\t    if (ii === positionKeys.length) {\n\t      key = Object.keys(attribs)[0];\n\t    }\n\t    var attrib = attribs[key];\n\t    gl.bindBuffer(gl.ARRAY_BUFFER, attrib.buffer);\n\t    var numBytes = gl.getBufferParameter(gl.ARRAY_BUFFER, gl.BUFFER_SIZE);\n\t    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n\t    var bytesPerValue = getBytesPerValueForGLType(gl, attrib.type);\n\t    var totalElements = numBytes / bytesPerValue;\n\t    var numComponents = attrib.numComponents || attrib.size;\n\t    // TODO: check stride\n\t    var numElements = totalElements / numComponents;\n\t    if (numElements % 1 !== 0) {\n\t      throw \"numComponents \" + numComponents + \" not correct for length \" + length;\n\t    }\n\t    return numElements;\n\t  }\n\n\t  /**\n\t   * @typedef {Object} BufferInfo\n\t   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n\t   * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..\n\t   * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.\n\t   * @property {Object.<string, module:twgl.AttribInfo>} [attribs] The attribs approriate to call `setAttributes`\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a BufferInfo from an object of arrays.\n\t   *\n\t   * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to\n\t   * {@link module:twgl:drawBufferInfo}.\n\t   *\n\t   * Given an object like\n\t   *\n\t   *     var arrays = {\n\t   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n\t   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n\t   *     };\n\t   *\n\t   *  Creates an BufferInfo like this\n\t   *\n\t   *     bufferInfo = {\n\t   *       numElements: 4,        // or whatever the number of elements is\n\t   *       indices: WebGLBuffer,  // this property will not exist if there are no indices\n\t   *       attribs: {\n\t   *         a_position: { buffer: WebGLBuffer, numComponents: 3, },\n\t   *         a_normal:   { buffer: WebGLBuffer, numComponents: 3, },\n\t   *         a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },\n\t   *       },\n\t   *     };\n\t   *\n\t   *  The properties of arrays can be JavaScript arrays in which case the number of components\n\t   *  will be guessed.\n\t   *\n\t   *     var arrays = {\n\t   *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],\n\t   *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],\n\t   *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],\n\t   *        indices:  [0, 1, 2, 1, 2, 3],\n\t   *     };\n\t   *\n\t   *  They can also by TypedArrays\n\t   *\n\t   *     var arrays = {\n\t   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n\t   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n\t   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n\t   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n\t   *     };\n\t   *\n\t   *  Or augmentedTypedArrays\n\t   *\n\t   *     var positions = createAugmentedTypedArray(3, 4);\n\t   *     var texcoords = createAugmentedTypedArray(2, 4);\n\t   *     var normals   = createAugmentedTypedArray(3, 4);\n\t   *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);\n\t   *\n\t   *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);\n\t   *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);\n\t   *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);\n\t   *     indices.push([0, 1, 2, 1, 2, 3]);\n\t   *\n\t   *     var arrays = {\n\t   *        position: positions,\n\t   *        texcoord: texcoords,\n\t   *        normal:   normals,\n\t   *        indices:  indices,\n\t   *     };\n\t   *\n\t   * For the last example it is equivalent to\n\t   *\n\t   *     var bufferInfo = {\n\t   *       attribs: {\n\t   *         a_position: { numComponents: 3, buffer: gl.createBuffer(), },\n\t   *         a_texcoods: { numComponents: 2, buffer: gl.createBuffer(), },\n\t   *         a_normals: { numComponents: 3, buffer: gl.createBuffer(), },\n\t   *       },\n\t   *       indices: gl.createBuffer(),\n\t   *       numElements: 6,\n\t   *     };\n\t   *\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_position.buffer);\n\t   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_texcoord.buffer);\n\t   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_normal.buffer);\n\t   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);\n\t   *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);\n\t   *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {module:twgl.Arrays} arrays Your data\n\t   * @return {module:twgl.BufferInfo} A BufferInfo\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBufferInfoFromArrays(gl, arrays) {\n\t    var bufferInfo = {\n\t      attribs: createAttribsFromArrays(gl, arrays)\n\t    };\n\t    var indices = arrays.indices;\n\t    if (indices) {\n\t      indices = makeTypedArray(indices, \"indices\");\n\t      bufferInfo.indices = createBufferFromTypedArray(gl, indices, gl.ELEMENT_ARRAY_BUFFER);\n\t      bufferInfo.numElements = indices.length;\n\t      bufferInfo.elementType = typedArrays.getGLTypeForTypedArray(indices);\n\t    } else {\n\t      bufferInfo.numElements = getNumElementsFromAttributes(gl, bufferInfo.attribs);\n\t    }\n\n\t    return bufferInfo;\n\t  }\n\n\t  /**\n\t   * Creates a buffer from an array, typed array, or array spec\n\t   *\n\t   * Given something like this\n\t   *\n\t   *     [1, 2, 3],\n\t   *\n\t   * or\n\t   *\n\t   *     new Uint16Array([1,2,3]);\n\t   *\n\t   * or\n\t   *\n\t   *     {\n\t   *        data: [1, 2, 3],\n\t   *        type: Uint8Array,\n\t   *     }\n\t   *\n\t   * returns a WebGLBuffer that constains the given data.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n\t   * @param {module:twgl.ArraySpec} array an array, typed array, or array spec.\n\t   * @param {string} arrayName name of array. Used to guess the type if type can not be dervied other wise.\n\t   * @return {WebGLBuffer} a WebGLBuffer containing the data in array.\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBufferFromArray(gl, array, arrayName) {\n\t    var type = arrayName === \"indices\" ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n\t    var typedArray = makeTypedArray(array, arrayName);\n\t    return createBufferFromTypedArray(gl, typedArray, type);\n\t  }\n\n\t  /**\n\t   * Creates buffers from arrays or typed arrays\n\t   *\n\t   * Given something like this\n\t   *\n\t   *     var arrays = {\n\t   *        positions: [1, 2, 3],\n\t   *        normals: [0, 0, 1],\n\t   *     }\n\t   *\n\t   * returns something like\n\t   *\n\t   *     buffers = {\n\t   *       positions: WebGLBuffer,\n\t   *       normals: WebGLBuffer,\n\t   *     }\n\t   *\n\t   * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n\t   * @param {module:twgl.Arrays} arrays\n\t   * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBuffersFromArrays(gl, arrays) {\n\t    var buffers = {};\n\t    Object.keys(arrays).forEach(function (key) {\n\t      buffers[key] = createBufferFromArray(gl, arrays[key], key);\n\t    });\n\n\t    // Ugh!\n\t    if (arrays.indices) {\n\t      buffers.numElements = arrays.indices.length;\n\t      buffers.elementType = typedArrays.getGLTypeForTypedArray(makeTypedArray(arrays.indices), 'indices');\n\t    } else {\n\t      buffers.numElements = getNumElementsFromNonIndexedArrays(arrays);\n\t    }\n\n\t    return buffers;\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"createAttribsFromArrays\": createAttribsFromArrays,\n\t    \"createBuffersFromArrays\": createBuffersFromArrays,\n\t    \"createBufferFromArray\": createBufferFromArray,\n\t    \"createBufferFromTypedArray\": createBufferFromTypedArray,\n\t    \"createBufferInfoFromArrays\": createBufferInfoFromArrays,\n\t    \"setAttribInfoBufferFromArray\": setAttribInfoBufferFromArray,\n\n\t    \"setAttributePrefix\": setAttributePrefix,\n\n\t    \"setDefaults_\": setDefaults,\n\t    \"getNumComponents_\": getNumComponents,\n\t    \"getArray_\": getArray\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t  \"use strict\";\n\n\t  /**\n\t   * Low level shader typed array related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.typedArray` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/typedArray\n\t   */\n\n\t  // make sure we don't see a global gl\n\n\t  var gl = undefined; // eslint-disable-line\n\n\t  /* DataType */\n\t  var BYTE = 0x1400;\n\t  var UNSIGNED_BYTE = 0x1401;\n\t  var SHORT = 0x1402;\n\t  var UNSIGNED_SHORT = 0x1403;\n\t  var INT = 0x1404;\n\t  var UNSIGNED_INT = 0x1405;\n\t  var FLOAT = 0x1406;\n\t  var UNSIGNED_SHORT_4_4_4_4 = 0x8033;\n\t  var UNSIGNED_SHORT_5_5_5_1 = 0x8034;\n\t  var UNSIGNED_SHORT_5_6_5 = 0x8363;\n\t  var HALF_FLOAT = 0x140B;\n\t  var UNSIGNED_INT_2_10_10_10_REV = 0x8368;\n\t  var UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;\n\t  var UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;\n\t  var FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;\n\t  var UNSIGNED_INT_24_8 = 0x84FA;\n\n\t  var glTypeToTypedArray = {};\n\t  {\n\t    var tt = glTypeToTypedArray;\n\t    tt[BYTE] = Int8Array;\n\t    tt[UNSIGNED_BYTE] = Uint8Array;\n\t    tt[SHORT] = Int16Array;\n\t    tt[UNSIGNED_SHORT] = Uint16Array;\n\t    tt[INT] = Int32Array;\n\t    tt[UNSIGNED_INT] = Uint32Array;\n\t    tt[FLOAT] = Float32Array;\n\t    tt[UNSIGNED_SHORT_4_4_4_4] = Uint16Array;\n\t    tt[UNSIGNED_SHORT_5_5_5_1] = Uint16Array;\n\t    tt[UNSIGNED_SHORT_5_6_5] = Uint16Array;\n\t    tt[HALF_FLOAT] = Uint16Array;\n\t    tt[UNSIGNED_INT_2_10_10_10_REV] = Uint32Array;\n\t    tt[UNSIGNED_INT_10F_11F_11F_REV] = Uint32Array;\n\t    tt[UNSIGNED_INT_5_9_9_9_REV] = Uint32Array;\n\t    tt[FLOAT_32_UNSIGNED_INT_24_8_REV] = Uint32Array;\n\t    tt[UNSIGNED_INT_24_8] = Uint32Array;\n\t  }\n\n\t  /**\n\t   * Get the GL type for a typedArray\n\t   * @param {ArrayBuffer|ArrayBufferView} typedArray a typedArray\n\t   * @return {number} the GL type for array. For example pass in an `Int8Array` and `gl.BYTE` will\n\t   *   be returned. Pass in a `Uint32Array` and `gl.UNSIGNED_INT` will be returned\n\t   * @memberOf module:twgl/typedArray\n\t   */\n\t  function getGLTypeForTypedArray(typedArray) {\n\t    if (typedArray instanceof Int8Array) {\n\t      return BYTE;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Uint8Array) {\n\t      return UNSIGNED_BYTE;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Uint8ClampedArray) {\n\t      return UNSIGNED_BYTE;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Int16Array) {\n\t      return SHORT;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Uint16Array) {\n\t      return UNSIGNED_SHORT;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Int32Array) {\n\t      return INT;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Uint32Array) {\n\t      return UNSIGNED_INT;\n\t    } // eslint-disable-line\n\t    if (typedArray instanceof Float32Array) {\n\t      return FLOAT;\n\t    } // eslint-disable-line\n\t    throw \"unsupported typed array type\";\n\t  }\n\n\t  /**\n\t   * Get the GL type for a typedArray type\n\t   * @param {ArrayBufferViewType} typedArrayType a typedArray constructor\n\t   * @return {number} the GL type for type. For example pass in `Int8Array` and `gl.BYTE` will\n\t   *   be returned. Pass in `Uint32Array` and `gl.UNSIGNED_INT` will be returned\n\t   * @memberOf module:twgl/typedArray\n\t   */\n\t  function getGLTypeForTypedArrayType(typedArrayType) {\n\t    if (typedArrayType === Int8Array) {\n\t      return BYTE;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Uint8Array) {\n\t      return UNSIGNED_BYTE;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Uint8ClampedArray) {\n\t      return UNSIGNED_BYTE;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Int16Array) {\n\t      return SHORT;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Uint16Array) {\n\t      return UNSIGNED_SHORT;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Int32Array) {\n\t      return INT;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Uint32Array) {\n\t      return UNSIGNED_INT;\n\t    } // eslint-disable-line\n\t    if (typedArrayType === Float32Array) {\n\t      return FLOAT;\n\t    } // eslint-disable-line\n\t    throw \"unsupported typed array type\";\n\t  }\n\n\t  /**\n\t   * Get the typed array constructor for a given GL type\n\t   * @param {number} type the GL type. (eg: `gl.UNSIGNED_INT`)\n\t   * @return {function} the constructor for a the corresponding typed array. (eg. `Uint32Array`).\n\t   * @memberOf module:twgl/typedArray\n\t   */\n\t  function getTypedArrayTypeForGLType(type) {\n\t    var CTOR = glTypeToTypedArray[type];\n\t    if (!CTOR) {\n\t      throw \"unknown gl type\";\n\t    }\n\t    return CTOR;\n\t  }\n\n\t  function isArrayBuffer(a) {\n\t    return a && a.buffer && a.buffer instanceof ArrayBuffer;\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  return {\n\t    \"getGLTypeForTypedArray\": getGLTypeForTypedArray,\n\t    \"getGLTypeForTypedArrayType\": getGLTypeForTypedArrayType,\n\t    \"getTypedArrayTypeForGLType\": getTypedArrayTypeForGLType,\n\t    \"isArrayBuffer\": isArrayBuffer\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t  \"use strict\";\n\n\t  /**\n\t   * Copy an object 1 level deep\n\t   * @param {object} src object to copy\n\t   * @return {object} the copy\n\t   */\n\n\t  function shallowCopy(src) {\n\t    var dst = {};\n\t    Object.keys(src).forEach(function (key) {\n\t      dst[key] = src[key];\n\t    });\n\t    return dst;\n\t  }\n\n\t  /**\n\t   * Copy named properties\n\t   *\n\t   * @param {string[]} names names of properties to copy\n\t   * @param {object} src object to copy properties from\n\t   * @param {object} dst object to copy properties to\n\t   */\n\t  function copyNamedProperties(names, src, dst) {\n\t    names.forEach(function (name) {\n\t      var value = src[name];\n\t      if (value !== undefined) {\n\t        dst[name] = value;\n\t      }\n\t    });\n\t  }\n\n\t  /**\n\t   * Copies properties from source to dest only if a matching key is in dest\n\t   *\n\t   * @param {Object.<string, ?>} src the source\n\t   * @param {Object.<string, ?>} dst the dest\n\t   */\n\t  function copyExistingProperties(src, dst) {\n\t    Object.keys(dst).forEach(function (key) {\n\t      if (dst.hasOwnProperty(key) && src.hasOwnProperty(key)) {\n\t        dst[key] = src[key];\n\t      }\n\t    });\n\t  }\n\n\t  /**\n\t   * Gets the gl version as a number\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @return {number} version of gl\n\t   */\n\t  //function getVersionAsNumber(gl) {\n\t  //  return parseFloat(gl.getParameter(gl.VERSION).substr(6));\n\t  //}\n\n\t  /**\n\t   * Check if context is WebGL 2.0\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @return {bool} true if it's WebGL 2.0\n\t   * @memberOf module:twgl\n\t   */\n\t  function isWebGL2(gl) {\n\t    // This is the correct check but it's slow\n\t    //return gl.getParameter(gl.VERSION).indexOf(\"WebGL 2.0\") === 0;\n\t    // This might also be the correct check but I'm assuming it's slow-ish\n\t    // return gl instanceof WebGL2RenderingContext;\n\t    return !!gl.texStorage2D;\n\t  }\n\n\t  /**\n\t   * Check if context is WebGL 1.0\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @return {bool} true if it's WebGL 1.0\n\t   * @memberOf module:twgl\n\t   */\n\t  function isWebGL1(gl) {\n\t    // This is the correct check but it's slow\n\t    //var version = getVersionAsNumber(gl);\n\t    //return version <= 1.0 && version > 0.0;  // because as of 2016/5 Edge returns 0.96\n\t    // This might also be the correct check but I'm assuming it's slow-ish\n\t    // return gl instanceof WebGLRenderingContext;\n\t    return !gl.texStorage2D;\n\t  }\n\n\t  var error = window.console && window.console.error && typeof window.console.error === \"function\" ? window.console.error.bind(window.console) : function () {};\n\n\t  var warn = window.console && window.console.warn && typeof window.console.warn === \"function\" ? window.console.warn.bind(window.console) : function () {};\n\n\t  return {\n\t    copyExistingProperties: copyExistingProperties,\n\t    copyNamedProperties: copyNamedProperties,\n\t    shallowCopy: shallowCopy,\n\t    isWebGL1: isWebGL1,\n\t    isWebGL2: isWebGL2,\n\t    error: error,\n\t    warn: warn\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (programs) {\n\t  \"use strict\";\n\n\t  /**\n\t   * Drawing related functions\n\t   *\n\t   * For backward compatibily they are available at both `twgl.draw` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/draw\n\t   */\n\n\t  /**\n\t   * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate\n\t   *\n\t   * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself\n\t   * but calling this means if you switch from indexed data to non-indexed\n\t   * data you don't have to remember to update your draw call.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} bufferInfo A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays} or\n\t   *   a VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}\n\t   * @param {enum} [type] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...). Defaults to `gl.TRIANGLES`\n\t   * @param {number} [count] An optional count. Defaults to bufferInfo.numElements\n\t   * @param {number} [offset] An optional offset. Defaults to 0.\n\t   * @memberOf module:twgl/draw\n\t   */\n\n\t  function drawBufferInfo(gl, bufferInfo, type, count, offset) {\n\t    type = type === undefined ? gl.TRIANGLES : type;\n\t    var indices = bufferInfo.indices;\n\t    var elementType = bufferInfo.elementType;\n\t    var numElements = count === undefined ? bufferInfo.numElements : count;\n\t    offset = offset === undefined ? 0 : offset;\n\t    if (elementType || indices) {\n\t      gl.drawElements(type, numElements, elementType === undefined ? gl.UNSIGNED_SHORT : bufferInfo.elementType, offset);\n\t    } else {\n\t      gl.drawArrays(type, offset, numElements);\n\t    }\n\t  }\n\n\t  /**\n\t   * A DrawObject is useful for putting objects in to an array and passing them to {@link module:twgl.drawObjectList}.\n\t   *\n\t   * You need either a `BufferInfo` or a `VertexArrayInfo`.\n\t   *\n\t   * @typedef {Object} DrawObject\n\t   * @property {boolean} [active] whether or not to draw. Default = `true` (must be `false` to be not true). In otherwords `undefined` = `true`\n\t   * @property {number} [type] type to draw eg. `gl.TRIANGLES`, `gl.LINES`, etc...\n\t   * @property {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}\n\t   * @property {module:twgl.BufferInfo} [bufferInfo] A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays}\n\t   * @property {module:twgl.VertexArrayInfo} [vertexArrayInfo] A VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}\n\t   * @property {Object<string, ?>} uniforms The values for the uniforms.\n\t   *   You can pass multiple objects by putting them in an array. For example\n\t   *\n\t   *     var sharedUniforms = {\n\t   *       u_fogNear: 10,\n\t   *       u_projection: ...\n\t   *       ...\n\t   *     };\n\t   *\n\t   *     var localUniforms = {\n\t   *       u_world: ...\n\t   *       u_diffuseColor: ...\n\t   *     };\n\t   *\n\t   *     var drawObj = {\n\t   *       ...\n\t   *       uniforms: [sharedUniforms, localUniforms],\n\t   *     };\n\t   *\n\t   * @property {number} [offset] the offset to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to 0.\n\t   * @property {number} [count] the count to pass to `gl.drawArrays` or `gl.drawElemnts`. Defaults to bufferInfo.numElements.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Draws a list of objects\n\t   * @param {DrawObject[]} objectsToDraw an array of objects to draw.\n\t   * @memberOf module:twgl/draw\n\t   */\n\t  function drawObjectList(gl, objectsToDraw) {\n\t    var lastUsedProgramInfo = null;\n\t    var lastUsedBufferInfo = null;\n\n\t    objectsToDraw.forEach(function (object) {\n\t      if (object.active === false) {\n\t        return;\n\t      }\n\n\t      var programInfo = object.programInfo;\n\t      var bufferInfo = object.vertexArrayInfo || object.bufferInfo;\n\t      var bindBuffers = false;\n\t      var type = object.type === undefined ? gl.TRIANGLES : object.type;\n\n\t      if (programInfo !== lastUsedProgramInfo) {\n\t        lastUsedProgramInfo = programInfo;\n\t        gl.useProgram(programInfo.program);\n\n\t        // We have to rebind buffers when changing programs because we\n\t        // only bind buffers the program uses. So if 2 programs use the same\n\t        // bufferInfo but the 1st one uses only positions the when the\n\t        // we switch to the 2nd one some of the attributes will not be on.\n\t        bindBuffers = true;\n\t      }\n\n\t      // Setup all the needed attributes.\n\t      if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {\n\t        if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject && !bufferInfo.vertexArrayObject) {\n\t          gl.bindVertexArray(null);\n\t        }\n\t        lastUsedBufferInfo = bufferInfo;\n\t        programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n\t      }\n\n\t      // Set the uniforms.\n\t      programs.setUniforms(programInfo, object.uniforms);\n\n\t      // Draw\n\t      drawBufferInfo(gl, bufferInfo, type, object.count, object.offset);\n\t    });\n\n\t    if (lastUsedBufferInfo.vertexArrayObject) {\n\t      gl.bindVertexArray(null);\n\t    }\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"drawBufferInfo\": drawBufferInfo,\n\t    \"drawObjectList\": drawObjectList\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (utils) {\n\t  \"use strict\";\n\n\t  /**\n\t   * Low level shader program related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.programs` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/programs\n\t   */\n\n\t  var error = utils.error;\n\t  var warn = utils.warn;\n\n\t  var FLOAT = 0x1406;\n\t  var FLOAT_VEC2 = 0x8B50;\n\t  var FLOAT_VEC3 = 0x8B51;\n\t  var FLOAT_VEC4 = 0x8B52;\n\t  var INT = 0x1404;\n\t  var INT_VEC2 = 0x8B53;\n\t  var INT_VEC3 = 0x8B54;\n\t  var INT_VEC4 = 0x8B55;\n\t  var BOOL = 0x8B56;\n\t  var BOOL_VEC2 = 0x8B57;\n\t  var BOOL_VEC3 = 0x8B58;\n\t  var BOOL_VEC4 = 0x8B59;\n\t  var FLOAT_MAT2 = 0x8B5A;\n\t  var FLOAT_MAT3 = 0x8B5B;\n\t  var FLOAT_MAT4 = 0x8B5C;\n\t  var SAMPLER_2D = 0x8B5E;\n\t  var SAMPLER_CUBE = 0x8B60;\n\t  var SAMPLER_3D = 0x8B5F;\n\t  var SAMPLER_2D_SHADOW = 0x8B62;\n\t  var FLOAT_MAT2x3 = 0x8B65;\n\t  var FLOAT_MAT2x4 = 0x8B66;\n\t  var FLOAT_MAT3x2 = 0x8B67;\n\t  var FLOAT_MAT3x4 = 0x8B68;\n\t  var FLOAT_MAT4x2 = 0x8B69;\n\t  var FLOAT_MAT4x3 = 0x8B6A;\n\t  var SAMPLER_2D_ARRAY = 0x8DC1;\n\t  var SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;\n\t  var SAMPLER_CUBE_SHADOW = 0x8DC5;\n\t  var UNSIGNED_INT = 0x1405;\n\t  var UNSIGNED_INT_VEC2 = 0x8DC6;\n\t  var UNSIGNED_INT_VEC3 = 0x8DC7;\n\t  var UNSIGNED_INT_VEC4 = 0x8DC8;\n\t  var INT_SAMPLER_2D = 0x8DCA;\n\t  var INT_SAMPLER_3D = 0x8DCB;\n\t  var INT_SAMPLER_CUBE = 0x8DCC;\n\t  var INT_SAMPLER_2D_ARRAY = 0x8DCF;\n\t  var UNSIGNED_INT_SAMPLER_2D = 0x8DD2;\n\t  var UNSIGNED_INT_SAMPLER_3D = 0x8DD3;\n\t  var UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;\n\t  var UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;\n\n\t  var TEXTURE_2D = 0x0DE1;\n\t  var TEXTURE_CUBE_MAP = 0x8513;\n\t  var TEXTURE_3D = 0x806F;\n\t  var TEXTURE_2D_ARRAY = 0x8C1A;\n\n\t  var typeMap = {};\n\n\t  /**\n\t   * Returns the corresponding bind point for a given sampler type\n\t   */\n\t  function getBindPointForSamplerType(gl, type) {\n\t    return typeMap[type].bindPoint;\n\t  }\n\n\t  // This kind of sucks! If you could compose functions as in `var fn = gl[name];`\n\t  // this code could be a lot smaller but that is sadly really slow (T_T)\n\n\t  function floatSetter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform1f(location, v);\n\t    };\n\t  }\n\n\t  function floatArraySetter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform1fv(location, v);\n\t    };\n\t  }\n\n\t  function floatVec2Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform2fv(location, v);\n\t    };\n\t  }\n\n\t  function floatVec3Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform3fv(location, v);\n\t    };\n\t  }\n\n\t  function floatVec4Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform4fv(location, v);\n\t    };\n\t  }\n\n\t  function intSetter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform1i(location, v);\n\t    };\n\t  }\n\n\t  function intArraySetter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform1iv(location, v);\n\t    };\n\t  }\n\n\t  function intVec2Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform2iv(location, v);\n\t    };\n\t  }\n\n\t  function intVec3Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform3iv(location, v);\n\t    };\n\t  }\n\n\t  function intVec4Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform4iv(location, v);\n\t    };\n\t  }\n\n\t  function uintSetter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform1ui(location, v);\n\t    };\n\t  }\n\n\t  function uintArraySetter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform1uiv(location, v);\n\t    };\n\t  }\n\n\t  function uintVec2Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform2uiv(location, v);\n\t    };\n\t  }\n\n\t  function uintVec3Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform3uiv(location, v);\n\t    };\n\t  }\n\n\t  function uintVec4Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniform4uiv(location, v);\n\t    };\n\t  }\n\n\t  function floatMat2Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix2fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat3Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix3fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat4Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix4fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat23Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix2x3fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat32Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix3x2fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat24Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix2x4fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat42Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix4x2fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat34Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix3x4fv(location, false, v);\n\t    };\n\t  }\n\n\t  function floatMat43Setter(gl, location) {\n\t    return function (v) {\n\t      gl.uniformMatrix4x3fv(location, false, v);\n\t    };\n\t  }\n\n\t  function samplerSetter(gl, type, unit, location) {\n\t    var bindPoint = getBindPointForSamplerType(gl, type);\n\t    return utils.isWebGL2(gl) ? function (textureOrPair) {\n\t      var texture = void 0;\n\t      var sampler = void 0;\n\t      if (textureOrPair instanceof WebGLTexture) {\n\t        texture = textureOrPair;\n\t        sampler = null;\n\t      } else {\n\t        texture = textureOrPair.texture;\n\t        sampler = textureOrPair.sampler;\n\t      }\n\t      gl.uniform1i(location, unit);\n\t      gl.activeTexture(gl.TEXTURE0 + unit);\n\t      gl.bindTexture(bindPoint, texture);\n\t      gl.bindSampler(unit, sampler);\n\t    } : function (texture) {\n\t      gl.uniform1i(location, unit);\n\t      gl.activeTexture(gl.TEXTURE0 + unit);\n\t      gl.bindTexture(bindPoint, texture);\n\t    };\n\t  }\n\n\t  function samplerArraySetter(gl, type, unit, location, size) {\n\t    var bindPoint = getBindPointForSamplerType(gl, type);\n\t    var units = new Int32Array(size);\n\t    for (var ii = 0; ii < size; ++ii) {\n\t      units[ii] = unit + ii;\n\t    }\n\n\t    return utils.isWebGL2(gl) ? function (textures) {\n\t      gl.uniform1iv(location, units);\n\t      textures.forEach(function (textureOrPair, index) {\n\t        gl.activeTexture(gl.TEXTURE0 + units[index]);\n\t        var texture = void 0;\n\t        var sampler = void 0;\n\t        if (textureOrPair instanceof WebGLTexture) {\n\t          texture = textureOrPair;\n\t          sampler = null;\n\t        } else {\n\t          texture = textureOrPair.texture;\n\t          sampler = textureOrPair.sampler;\n\t        }\n\t        gl.bindSampler(unit, sampler);\n\t        gl.bindTexture(bindPoint, texture);\n\t      });\n\t    } : function (textures) {\n\t      gl.uniform1iv(location, units);\n\t      textures.forEach(function (texture, index) {\n\t        gl.activeTexture(gl.TEXTURE0 + units[index]);\n\t        gl.bindTexture(bindPoint, texture);\n\t      });\n\t    };\n\t  }\n\n\t  typeMap[FLOAT] = { Type: Float32Array, size: 4, setter: floatSetter, arraySetter: floatArraySetter };\n\t  typeMap[FLOAT_VEC2] = { Type: Float32Array, size: 8, setter: floatVec2Setter };\n\t  typeMap[FLOAT_VEC3] = { Type: Float32Array, size: 12, setter: floatVec3Setter };\n\t  typeMap[FLOAT_VEC4] = { Type: Float32Array, size: 16, setter: floatVec4Setter };\n\t  typeMap[INT] = { Type: Int32Array, size: 4, setter: intSetter, arraySetter: intArraySetter };\n\t  typeMap[INT_VEC2] = { Type: Int32Array, size: 8, setter: intVec2Setter };\n\t  typeMap[INT_VEC3] = { Type: Int32Array, size: 12, setter: intVec3Setter };\n\t  typeMap[INT_VEC4] = { Type: Int32Array, size: 16, setter: intVec4Setter };\n\t  typeMap[UNSIGNED_INT] = { Type: Uint32Array, size: 4, setter: uintSetter, arraySetter: uintArraySetter };\n\t  typeMap[UNSIGNED_INT_VEC2] = { Type: Uint32Array, size: 8, setter: uintVec2Setter };\n\t  typeMap[UNSIGNED_INT_VEC3] = { Type: Uint32Array, size: 12, setter: uintVec3Setter };\n\t  typeMap[UNSIGNED_INT_VEC4] = { Type: Uint32Array, size: 16, setter: uintVec4Setter };\n\t  typeMap[BOOL] = { Type: Uint32Array, size: 4, setter: intSetter, arraySetter: intArraySetter };\n\t  typeMap[BOOL_VEC2] = { Type: Uint32Array, size: 8, setter: intVec2Setter };\n\t  typeMap[BOOL_VEC3] = { Type: Uint32Array, size: 12, setter: intVec3Setter };\n\t  typeMap[BOOL_VEC4] = { Type: Uint32Array, size: 16, setter: intVec4Setter };\n\t  typeMap[FLOAT_MAT2] = { Type: Float32Array, size: 16, setter: floatMat2Setter };\n\t  typeMap[FLOAT_MAT3] = { Type: Float32Array, size: 36, setter: floatMat3Setter };\n\t  typeMap[FLOAT_MAT4] = { Type: Float32Array, size: 64, setter: floatMat4Setter };\n\t  typeMap[FLOAT_MAT2x3] = { Type: Float32Array, size: 24, setter: floatMat23Setter };\n\t  typeMap[FLOAT_MAT2x4] = { Type: Float32Array, size: 32, setter: floatMat24Setter };\n\t  typeMap[FLOAT_MAT3x2] = { Type: Float32Array, size: 24, setter: floatMat32Setter };\n\t  typeMap[FLOAT_MAT3x4] = { Type: Float32Array, size: 48, setter: floatMat34Setter };\n\t  typeMap[FLOAT_MAT4x2] = { Type: Float32Array, size: 32, setter: floatMat42Setter };\n\t  typeMap[FLOAT_MAT4x3] = { Type: Float32Array, size: 48, setter: floatMat43Setter };\n\t  typeMap[SAMPLER_2D] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D };\n\t  typeMap[SAMPLER_CUBE] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP };\n\t  typeMap[SAMPLER_3D] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D };\n\t  typeMap[SAMPLER_2D_SHADOW] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D };\n\t  typeMap[SAMPLER_2D_ARRAY] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY };\n\t  typeMap[SAMPLER_2D_ARRAY_SHADOW] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY };\n\t  typeMap[SAMPLER_CUBE_SHADOW] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP };\n\t  typeMap[INT_SAMPLER_2D] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D };\n\t  typeMap[INT_SAMPLER_3D] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D };\n\t  typeMap[INT_SAMPLER_CUBE] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP };\n\t  typeMap[INT_SAMPLER_2D_ARRAY] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY };\n\t  typeMap[UNSIGNED_INT_SAMPLER_2D] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D };\n\t  typeMap[UNSIGNED_INT_SAMPLER_3D] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D };\n\t  typeMap[UNSIGNED_INT_SAMPLER_CUBE] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP };\n\t  typeMap[UNSIGNED_INT_SAMPLER_2D_ARRAY] = { Type: null, size: 0, setter: samplerSetter, arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY };\n\n\t  function floatAttribSetter(gl, index) {\n\t    return function (b) {\n\t      gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n\t      gl.enableVertexAttribArray(index);\n\t      gl.vertexAttribPointer(index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);\n\t    };\n\t  }\n\n\t  function intAttribSetter(gl, index) {\n\t    return function (b) {\n\t      gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n\t      gl.enableVertexAttribArray(index);\n\t      gl.vertexAttribIPointer(index, b.numComponents || b.size, b.type || gl.INT, b.stride || 0, b.offset || 0);\n\t    };\n\t  }\n\n\t  function matAttribSetter(gl, index, typeInfo) {\n\t    var defaultSize = typeInfo.size;\n\t    var count = typeInfo.count;\n\n\t    return function (b) {\n\t      gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n\t      var numComponents = b.size || b.numComponents || defaultSize;\n\t      var size = numComponents / count;\n\t      var type = b.type || gl.FLOAT;\n\t      var typeInfo = typeMap[type];\n\t      var stride = typeInfo.size * numComponents;\n\t      var normalize = b.normalize || false;\n\t      var offset = b.offset || 0;\n\t      var rowOffset = stride / count;\n\t      for (var i = 0; i < count; ++i) {\n\t        gl.enableVertexAttribArray(index + i);\n\t        gl.vertexAttribPointer(index + i, size, type, normalize, stride, offset + rowOffset * i);\n\t      }\n\t    };\n\t  }\n\n\t  var attrTypeMap = {};\n\t  attrTypeMap[FLOAT] = { size: 4, setter: floatAttribSetter };\n\t  attrTypeMap[FLOAT_VEC2] = { size: 8, setter: floatAttribSetter };\n\t  attrTypeMap[FLOAT_VEC3] = { size: 12, setter: floatAttribSetter };\n\t  attrTypeMap[FLOAT_VEC4] = { size: 16, setter: floatAttribSetter };\n\t  attrTypeMap[INT] = { size: 4, setter: intAttribSetter };\n\t  attrTypeMap[INT_VEC2] = { size: 8, setter: intAttribSetter };\n\t  attrTypeMap[INT_VEC3] = { size: 12, setter: intAttribSetter };\n\t  attrTypeMap[INT_VEC4] = { size: 16, setter: intAttribSetter };\n\t  attrTypeMap[UNSIGNED_INT] = { size: 4, setter: intAttribSetter };\n\t  attrTypeMap[UNSIGNED_INT_VEC2] = { size: 8, setter: intAttribSetter };\n\t  attrTypeMap[UNSIGNED_INT_VEC3] = { size: 12, setter: intAttribSetter };\n\t  attrTypeMap[UNSIGNED_INT_VEC4] = { size: 16, setter: intAttribSetter };\n\t  attrTypeMap[BOOL] = { size: 4, setter: intAttribSetter };\n\t  attrTypeMap[BOOL_VEC2] = { size: 8, setter: intAttribSetter };\n\t  attrTypeMap[BOOL_VEC3] = { size: 12, setter: intAttribSetter };\n\t  attrTypeMap[BOOL_VEC4] = { size: 16, setter: intAttribSetter };\n\t  attrTypeMap[FLOAT_MAT2] = { size: 4, setter: matAttribSetter, count: 2 };\n\t  attrTypeMap[FLOAT_MAT3] = { size: 9, setter: matAttribSetter, count: 3 };\n\t  attrTypeMap[FLOAT_MAT4] = { size: 16, setter: matAttribSetter, count: 4 };\n\n\t  // make sure we don't see a global gl\n\t  var gl = undefined; // eslint-disable-line\n\n\t  /**\n\t   * Error Callback\n\t   * @callback ErrorCallback\n\t   * @param {string} msg error message.\n\t   * @param {number} [lineOffset] amount to add to line number\n\t   * @memberOf module:twgl\n\t   */\n\n\t  function addLineNumbers(src, lineOffset) {\n\t    lineOffset = lineOffset || 0;\n\t    ++lineOffset;\n\n\t    return src.split(\"\\n\").map(function (line, ndx) {\n\t      return ndx + lineOffset + \": \" + line;\n\t    }).join(\"\\n\");\n\t  }\n\n\t  var spaceRE = /^[ \\t]*\\n/;\n\n\t  /**\n\t   * Loads a shader.\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {string} shaderSource The shader source.\n\t   * @param {number} shaderType The type of shader.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors.\n\t   * @return {WebGLShader} The created shader.\n\t   */\n\t  function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\n\t    var errFn = opt_errorCallback || error;\n\t    // Create the shader object\n\t    var shader = gl.createShader(shaderType);\n\n\t    // Remove the first end of line because WebGL 2.0 requires\n\t    // #version 300 es\n\t    // as the first line. No whitespace allowed before that line\n\t    // so\n\t    //\n\t    // <script>\n\t    // #version 300 es\n\t    // </script>\n\t    //\n\t    // Has one line before it which is invalid according to GLSL ES 3.00\n\t    //\n\t    var lineOffset = 0;\n\t    if (spaceRE.test(shaderSource)) {\n\t      lineOffset = 1;\n\t      shaderSource = shaderSource.replace(spaceRE, '');\n\t    }\n\n\t    // Load the shader source\n\t    gl.shaderSource(shader, shaderSource);\n\n\t    // Compile the shader\n\t    gl.compileShader(shader);\n\n\t    // Check the compile status\n\t    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\t    if (!compiled) {\n\t      // Something went wrong during compilation; get the error\n\t      var lastError = gl.getShaderInfoLog(shader);\n\t      errFn(addLineNumbers(shaderSource, lineOffset) + \"\\n*** Error compiling shader: \" + lastError);\n\t      gl.deleteShader(shader);\n\t      return null;\n\t    }\n\n\t    return shader;\n\t  }\n\n\t  /**\n\t   * @typedef {Object} ProgramOptions\n\t   * @property {function(string)} [errorCallback] callback for errors\n\t   * @property {Object.<string,number>} [attribLocations] a attribute name to location map\n\t   * @property {(module:twgl.BufferInfo|Object.<string,module:twgl.AttribInfo>|string[])} [transformFeedbackVaryings] If passed\n\t   *   a BufferInfo will use the attribs names inside. If passed an object of AttribInfos will use the names from that object. Otherwise\n\t   *   you can pass an array of names.\n\t   * @property {number} [transformFeedbackMode] the mode to pass `gl.transformFeedbackVaryings`. Defaults to `SEPARATE_ATTRIBS`.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Gets the program options based on all these optional arguments\n\t   * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {module:twgl.ProgramOptions} an instance of ProgramOptions based on the arguments pased on\n\t   */\n\t  function getProgramOptions(opt_attribs, opt_locations, opt_errorCallback) {\n\t    if (typeof opt_locations === 'function') {\n\t      opt_errorCallback = opt_locations;\n\t      opt_locations = undefined;\n\t    }\n\t    if (typeof opt_attribs === 'function') {\n\t      opt_errorCallback = opt_attribs;\n\t      opt_attribs = undefined;\n\t    } else if (opt_attribs && !Array.isArray(opt_attribs)) {\n\t      // If we have an errorCallback we can just return this object\n\t      // Otherwise we need to construct one with default errorCallback\n\t      if (opt_attribs.errorCallback) {\n\t        return opt_attribs;\n\t      }\n\t      var opt = opt_attribs;\n\t      opt_errorCallback = opt.errorCallback;\n\t      opt_attribs = opt.attribLocations;\n\t      var transformFeedbackVaryings = opt.transformFeedbackVaryings;\n\t    }\n\n\t    var options = {\n\t      errorCallback: opt_errorCallback || error,\n\t      transformFeedbackVaryings: transformFeedbackVaryings\n\t    };\n\n\t    if (opt_attribs) {\n\t      var attribLocations = {};\n\t      if (Array.isArray(opt_attribs)) {\n\t        opt_attribs.forEach(function (attrib, ndx) {\n\t          attribLocations[attrib] = opt_locations ? opt_locations[ndx] : ndx;\n\t        });\n\t      } else {\n\t        attribLocations = opt_attribs;\n\t      }\n\t      options.attribLocations = attribLocations;\n\t    }\n\n\t    return options;\n\t  }\n\n\t  var defaultShaderType = [\"VERTEX_SHADER\", \"FRAGMENT_SHADER\"];\n\n\t  function getShaderTypeFromScriptType(scriptType) {\n\t    if (scriptType.indexOf(\"frag\") >= 0) {\n\t      return gl.FRAGMENT_SHADER;\n\t    } else if (scriptType.indexOf(\"vert\") >= 0) {\n\t      return gl.VERTEX_SHADER;\n\t    }\n\t    return undefined;\n\t  }\n\n\t  /**\n\t   * Creates a program, attaches (and/or compiles) shaders, binds attrib locations, links the\n\t   * program and calls useProgram.\n\t   *\n\t   * NOTE: There are 4 signatures for this function\n\t   *\n\t   *     twgl.createProgram(gl, [vs, fs], options);\n\t   *     twgl.createProgram(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLShader[]|string[]} shaders The shaders to attach, or element ids for their source, or strings that contain their source\n\t   * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {WebGLProgram?} the created program or null if error.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {\n\t    var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);\n\t    var program = gl.createProgram();\n\t    shaders.forEach(function (shader, ndx) {\n\t      if (typeof shader === 'string') {\n\t        var elem = document.getElementById(shader);\n\t        var src = elem ? elem.text : shader;\n\t        var type = defaultShaderType[ndx];\n\t        if (elem && elem.type) {\n\t          type = getShaderTypeFromScriptType(elem.type);\n\t        }\n\t        shader = loadShader(gl, src, type, progOptions.errorCallback);\n\t      }\n\t      gl.attachShader(program, shader);\n\t    });\n\t    if (progOptions.attribLocations) {\n\t      Object.keys(progOptions.attribLocations).forEach(function (attrib) {\n\t        gl.bindAttribLocation(program, progOptions.attribLocations[attrib], attrib);\n\t      });\n\t    }\n\t    var varyings = progOptions.transformFeedbackVaryings;\n\t    if (varyings) {\n\t      if (varyings.attribs) {\n\t        varyings = varyings.attribs;\n\t      }\n\t      if (!Array.isArray(varyings)) {\n\t        varyings = Object.keys(varyings);\n\t      }\n\t      gl.transformFeedbackVaryings(program, varyings, progOptions.transformFeedbackMode || gl.SEPARATE_ATTRIBS);\n\t    }\n\t    gl.linkProgram(program);\n\n\t    // Check the link status\n\t    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\t    if (!linked) {\n\t      // something went wrong with the link\n\t      var lastError = gl.getProgramInfoLog(program);\n\t      progOptions.errorCallback(\"Error in program linking:\" + lastError);\n\n\t      gl.deleteProgram(program);\n\t      return null;\n\t    }\n\t    return program;\n\t  }\n\n\t  /**\n\t   * Loads a shader from a script tag.\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {string} scriptId The id of the script tag.\n\t   * @param {number} [opt_shaderType] The type of shader. If not passed in it will\n\t   *     be derived from the type of the script tag.\n\t   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors.\n\t   * @return {WebGLShader?} The created shader or null if error.\n\t   */\n\t  function createShaderFromScript(gl, scriptId, opt_shaderType, opt_errorCallback) {\n\t    var shaderSource = \"\";\n\t    var shaderScript = document.getElementById(scriptId);\n\t    if (!shaderScript) {\n\t      throw \"*** Error: unknown script element\" + scriptId;\n\t    }\n\t    shaderSource = shaderScript.text;\n\n\t    var shaderType = opt_shaderType || getShaderTypeFromScriptType(shaderScript.type);\n\t    if (!shaderType) {\n\t      throw \"*** Error: unknown shader type\";\n\t    }\n\n\t    return loadShader(gl, shaderSource, shaderType, opt_errorCallback);\n\t  }\n\n\t  /**\n\t   * Creates a program from 2 script tags.\n\t   *\n\t   * NOTE: There are 4 signatures for this function\n\t   *\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_options);\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {string[]} shaderScriptIds Array of ids of the script\n\t   *        tags for the shaders. The first is assumed to be the\n\t   *        vertex shader, the second the fragment shader.\n\t   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {WebGLProgram} The created program.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramFromScripts(gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {\n\t    var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);\n\t    var shaders = [];\n\t    for (var ii = 0; ii < shaderScriptIds.length; ++ii) {\n\t      var shader = createShaderFromScript(gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], progOptions.errorCallback);\n\t      if (!shader) {\n\t        return null;\n\t      }\n\t      shaders.push(shader);\n\t    }\n\t    return createProgram(gl, shaders, progOptions);\n\t  }\n\n\t  /**\n\t   * Creates a program from 2 sources.\n\t   *\n\t   * NOTE: There are 4 signatures for this function\n\t   *\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_options);\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {string[]} shaderSources Array of sources for the\n\t   *        shaders. The first is assumed to be the vertex shader,\n\t   *        the second the fragment shader.\n\t   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {WebGLProgram} The created program.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n\t    var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);\n\t    var shaders = [];\n\t    for (var ii = 0; ii < shaderSources.length; ++ii) {\n\t      var shader = loadShader(gl, shaderSources[ii], gl[defaultShaderType[ii]], progOptions.errorCallback);\n\t      if (!shader) {\n\t        return null;\n\t      }\n\t      shaders.push(shader);\n\t    }\n\t    return createProgram(gl, shaders, progOptions);\n\t  }\n\n\t  /**\n\t   * Creates setter functions for all uniforms of a shader\n\t   * program.\n\t   *\n\t   * @see {@link module:twgl.setUniforms}\n\t   *\n\t   * @param {WebGLProgram} program the program to create setters for.\n\t   * @returns {Object.<string, function>} an object with a setter by name for each uniform\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformSetters(gl, program) {\n\t    var textureUnit = 0;\n\n\t    /**\n\t     * Creates a setter for a uniform of the given program with it's\n\t     * location embedded in the setter.\n\t     * @param {WebGLProgram} program\n\t     * @param {WebGLUniformInfo} uniformInfo\n\t     * @returns {function} the created setter.\n\t     */\n\t    function createUniformSetter(program, uniformInfo) {\n\t      var location = gl.getUniformLocation(program, uniformInfo.name);\n\t      var isArray = uniformInfo.size > 1 && uniformInfo.name.substr(-3) === \"[0]\";\n\t      var type = uniformInfo.type;\n\t      var typeInfo = typeMap[type];\n\t      if (!typeInfo) {\n\t        throw \"unknown type: 0x\" + type.toString(16); // we should never get here.\n\t      }\n\t      if (typeInfo.bindPoint) {\n\t        // it's a sampler\n\t        var unit = textureUnit;\n\t        textureUnit += uniformInfo.size;\n\n\t        if (isArray) {\n\t          return typeInfo.arraySetter(gl, type, unit, location, uniformInfo.size);\n\t        } else {\n\t          return typeInfo.setter(gl, type, unit, location, uniformInfo.size);\n\t        }\n\t      } else {\n\t        if (typeInfo.arraySetter && isArray) {\n\t          return typeInfo.arraySetter(gl, location);\n\t        } else {\n\t          return typeInfo.setter(gl, location);\n\t        }\n\t      }\n\t    }\n\n\t    var uniformSetters = {};\n\t    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n\t    for (var ii = 0; ii < numUniforms; ++ii) {\n\t      var uniformInfo = gl.getActiveUniform(program, ii);\n\t      if (!uniformInfo) {\n\t        break;\n\t      }\n\t      var name = uniformInfo.name;\n\t      // remove the array suffix.\n\t      if (name.substr(-3) === \"[0]\") {\n\t        name = name.substr(0, name.length - 3);\n\t      }\n\t      var setter = createUniformSetter(program, uniformInfo);\n\t      uniformSetters[name] = setter;\n\t    }\n\t    return uniformSetters;\n\t  }\n\n\t  /**\n\t   * @typedef {Object} TransformFeedbackInfo\n\t   * @property {number} index index of transform feedback\n\t   * @property {number} type GL type\n\t   * @property {number} size 1 - 4\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Create TransformFeedbackInfo for passing to bind/unbindTransformFeedbackInfo.\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {WebGLProgram} program an existing WebGLProgram.\n\t   * @return {Object<string, module:twgl.TransformFeedbackInfo>}\n\t   * @memberOf module:twgl\n\t   */\n\t  function createTransformFeedbackInfo(gl, program) {\n\t    var info = {};\n\t    var numVaryings = gl.getProgramParameter(program, gl.TRANSFORM_FEEDBACK_VARYINGS);\n\t    for (var ii = 0; ii < numVaryings; ++ii) {\n\t      var varying = gl.getTransformFeedbackVarying(program, ii);\n\t      info[varying.name] = {\n\t        index: ii,\n\t        type: varying.type,\n\t        size: varying.size\n\t      };\n\t    }\n\t    return info;\n\t  }\n\n\t  /**\n\t   * Binds buffers for transform feedback.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {(module:twgl.ProgramInfo|Object<string, module:twgl.TransformFeedbackInfo>)} transformFeedbackInfo A ProgramInfo or TransformFeedbackInfo.\n\t   * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.\n\t   * @memberOf module:twgl\n\t   */\n\t  function bindTransformFeedbackInfo(gl, transformFeedbackInfo, bufferInfo) {\n\t    if (transformFeedbackInfo.transformFeedbackInfo) {\n\t      transformFeedbackInfo = transformFeedbackInfo.transformFeedbackInfo;\n\t    }\n\t    if (bufferInfo.attribs) {\n\t      bufferInfo = bufferInfo.attribs;\n\t    }\n\t    for (var name in bufferInfo) {\n\t      var varying = transformFeedbackInfo[name];\n\t      if (varying) {\n\t        var buf = bufferInfo[name];\n\t        if (buf.offset) {\n\t          gl.bindBufferRange(gl.TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer, buf.offset, buf.size);\n\t        } else {\n\t          gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer);\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * Unbinds buffers afetr transform feedback.\n\t   *\n\t   * Buffers can not be bound to 2 bind points so if you try to bind a buffer used\n\t   * in a transform feedback as an ARRAY_BUFFER for an attribute it will fail.\n\t   *\n\t   * This function unbinds all buffers that were bound with {@link module:twgl.bindTransformFeedbackInfo}.\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {(module:twgl.ProgramInfo|Object<string, module:twgl.TransformFeedbackInfo>)} transformFeedbackInfo A ProgramInfo or TransformFeedbackInfo.\n\t   * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.\n\t   */\n\t  function unbindTransformFeedbackInfo(gl, transformFeedbackInfo, bufferInfo) {\n\t    if (transformFeedbackInfo.transformFeedbackInfo) {\n\t      transformFeedbackInfo = transformFeedbackInfo.transformFeedbackInfo;\n\t    }\n\t    if (bufferInfo.attribs) {\n\t      bufferInfo = bufferInfo.attribs;\n\t    }\n\t    for (var name in bufferInfo) {\n\t      var varying = transformFeedbackInfo[name];\n\t      if (varying) {\n\t        gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, varying.index, null);\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * Creates a transform feedback and sets the buffers\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}\n\t   * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.\n\t   * @return {WebGLTransformFeedback} the created transform feedback\n\t   * @memberOf module:twgl\n\t   */\n\t  function createTransformFeedback(gl, programInfo, bufferInfo) {\n\t    var tf = gl.createTransformFeedback();\n\t    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);\n\t    gl.useProgram(programInfo.program);\n\t    bindTransformFeedbackInfo(gl, programInfo, bufferInfo);\n\t    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n\t    // This is only needed because of a bug in Chrome 56. Will remove\n\t    // when chrome fixes it.\n\t    unbindTransformFeedbackInfo(gl, programInfo, bufferInfo);\n\t    return tf;\n\t  }\n\n\t  /**\n\t   * @typedef {Object} UniformData\n\t   * @property {number} type The WebGL type enum for this uniform\n\t   * @property {number} size The number of elements for this uniform\n\t   * @property {number} blockNdx The block index this uniform appears in\n\t   * @property {number} offset The byte offset in the block for this uniform's value\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * The specification for one UniformBlockObject\n\t   *\n\t   * @typedef {Object} BlockSpec\n\t   * @property {number} index The index of the block.\n\t   * @property {number} size The size in bytes needed for the block\n\t   * @property {number[]} uniformIndices The indices of the uniforms used by the block. These indices\n\t   *    correspond to entries in a UniformData array in the {@link module:twgl.UniformBlockSpec}.\n\t   * @property {bool} usedByVertexShader Self explanitory\n\t   * @property {bool} usedByFragmentShader Self explanitory\n\t   * @property {bool} used Self explanitory\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * A `UniformBlockSpec` represents the data needed to create and bind\n\t   * UniformBlockObjects for a given program\n\t   *\n\t   * @typedef {Object} UniformBlockSpec\n\t   * @property {Object.<string, module:twgl.BlockSpec> blockSpecs The BlockSpec for each block by block name\n\t   * @property {UniformData[]} uniformData An array of data for each uniform by uniform index.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a UniformBlockSpec for the given program.\n\t   *\n\t   * A UniformBlockSpec represents the data needed to create and bind\n\t   * UniformBlockObjects\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL2 Rendering Context\n\t   * @param {WebGLProgram} program A WebGLProgram for a successfully linked program\n\t   * @return {module:twgl.UniformBlockSpec} The created UniformBlockSpec\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformBlockSpecFromProgram(gl, program) {\n\t    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\t    var uniformData = [];\n\t    var uniformIndices = [];\n\n\t    for (var ii = 0; ii < numUniforms; ++ii) {\n\t      uniformIndices.push(ii);\n\t      uniformData.push({});\n\t      var uniformInfo = gl.getActiveUniform(program, ii);\n\t      if (!uniformInfo) {\n\t        break;\n\t      }\n\t      // REMOVE [0]?\n\t      uniformData[ii].name = uniformInfo.name;\n\t    }\n\n\t    [[\"UNIFORM_TYPE\", \"type\"], [\"UNIFORM_SIZE\", \"size\"], // num elements\n\t    [\"UNIFORM_BLOCK_INDEX\", \"blockNdx\"], [\"UNIFORM_OFFSET\", \"offset\"]].forEach(function (pair) {\n\t      var pname = pair[0];\n\t      var key = pair[1];\n\t      gl.getActiveUniforms(program, uniformIndices, gl[pname]).forEach(function (value, ndx) {\n\t        uniformData[ndx][key] = value;\n\t      });\n\t    });\n\n\t    var blockSpecs = {};\n\n\t    var numUniformBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n\t    for (ii = 0; ii < numUniformBlocks; ++ii) {\n\t      var name = gl.getActiveUniformBlockName(program, ii);\n\t      var blockSpec = {\n\t        index: ii,\n\t        usedByVertexShader: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),\n\t        usedByFragmentShader: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),\n\t        size: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_DATA_SIZE),\n\t        uniformIndices: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES)\n\t      };\n\t      blockSpec.used = blockSpec.usedByVertexSahder || blockSpec.usedByFragmentShader;\n\t      blockSpecs[name] = blockSpec;\n\t    }\n\n\t    return {\n\t      blockSpecs: blockSpecs,\n\t      uniformData: uniformData\n\t    };\n\t  }\n\n\t  var arraySuffixRE = /\\[\\d+\\]\\.$/; // better way to check?\n\n\t  /**\n\t   * Represents a UniformBlockObject including an ArrayBuffer with all the uniform values\n\t   * and a corresponding WebGLBuffer to hold those values on the GPU\n\t   *\n\t   * @typedef {Object} UniformBlockInfo\n\t   * @property {string} name The name of the block\n\t   * @property {ArrayBuffer} array The array buffer that contains the uniform values\n\t   * @property {Float32Array} asFloat A float view on the array buffer. This is useful\n\t   *    inspecting the contents of the buffer in the debugger.\n\t   * @property {WebGLBuffer} buffer A WebGL buffer that will hold a copy of the uniform values for rendering.\n\t   * @property {number} [offset] offset into buffer\n\t   * @property {Object.<string, ArrayBufferView>} uniforms A uniform name to ArrayBufferView map.\n\t   *   each Uniform has a correctly typed `ArrayBufferView` into array at the correct offset\n\t   *   and length of that uniform. So for example a float uniform would have a 1 float `Float32Array`\n\t   *   view. A single mat4 would have a 16 element `Float32Array` view. An ivec2 would have an\n\t   *   `Int32Array` view, etc.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a `UniformBlockInfo` for the specified block\n\t   *\n\t   * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy\n\t   * `UniformBlockInfo` is returned**. This is because when debugging GLSL\n\t   * it is common to comment out large portions of a shader or for example set\n\t   * the final output to a constant. When that happens blocks get optimized out.\n\t   * If this function did not create dummy blocks your code would crash when debugging.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext\n\t   * @param {WebGLProgram} program A WebGLProgram\n\t   * @param {module:twgl.UniformBlockSpec} uinformBlockSpec. A UniformBlockSpec as returned\n\t   *     from {@link module:twgl.createUniformBlockSpecFromProgram}.\n\t   * @param {string} blockName The name of the block.\n\t   * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformBlockInfoFromProgram(gl, program, uniformBlockSpec, blockName) {\n\t    var blockSpecs = uniformBlockSpec.blockSpecs;\n\t    var uniformData = uniformBlockSpec.uniformData;\n\t    var blockSpec = blockSpecs[blockName];\n\t    if (!blockSpec) {\n\t      warn(\"no uniform block object named:\", blockName);\n\t      return {\n\t        name: blockName,\n\t        uniforms: {}\n\t      };\n\t    }\n\t    var array = new ArrayBuffer(blockSpec.size);\n\t    var buffer = gl.createBuffer();\n\t    var uniformBufferIndex = blockSpec.index;\n\t    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);\n\t    gl.uniformBlockBinding(program, blockSpec.index, uniformBufferIndex);\n\n\t    var prefix = blockName + \".\";\n\t    if (arraySuffixRE.test(prefix)) {\n\t      prefix = prefix.replace(arraySuffixRE, \".\");\n\t    }\n\t    var uniforms = {};\n\t    blockSpec.uniformIndices.forEach(function (uniformNdx) {\n\t      var data = uniformData[uniformNdx];\n\t      var typeInfo = typeMap[data.type];\n\t      var Type = typeInfo.Type;\n\t      var length = data.size * typeInfo.size;\n\t      var name = data.name;\n\t      if (name.substr(0, prefix.length) === prefix) {\n\t        name = name.substr(prefix.length);\n\t      }\n\t      uniforms[name] = new Type(array, data.offset, length / Type.BYTES_PER_ELEMENT);\n\t    });\n\t    return {\n\t      name: blockName,\n\t      array: array,\n\t      asFloat: new Float32Array(array), // for debugging\n\t      buffer: buffer,\n\t      uniforms: uniforms\n\t    };\n\t  }\n\n\t  /**\n\t   * Creates a `UniformBlockInfo` for the specified block\n\t   *\n\t   * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy\n\t   * `UniformBlockInfo` is returned**. This is because when debugging GLSL\n\t   * it is common to comment out large portions of a shader or for example set\n\t   * the final output to a constant. When that happens blocks get optimized out.\n\t   * If this function did not create dummy blocks your code would crash when debugging.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext\n\t   * @param {module:twgl.ProgramInfo} programInfo a `ProgramInfo`\n\t   *     as returned from {@link module:twgl.createProgramInfo}\n\t   * @param {string} blockName The name of the block.\n\t   * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformBlockInfo(gl, programInfo, blockName) {\n\t    return createUniformBlockInfoFromProgram(gl, programInfo.program, programInfo.uniformBlockSpec, blockName);\n\t  }\n\n\t  /**\n\t   * Binds a unform block to the matching uniform block point.\n\t   * Matches by blocks by name so blocks must have the same name not just the same\n\t   * structure.\n\t   *\n\t   * If you have changed any values and you upload the valus into the corresponding WebGLBuffer\n\t   * call {@link module:twgl.setUniformBlock} instead.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.\n\t   * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`\n\t   *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as\n\t   *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.\n\t   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from\n\t   *     {@link module:twgl.createUniformBlockInfo}.\n\t   * @return {bool} true if buffer was bound. If the programInfo has no block with the same block name\n\t   *     no buffer is bound.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function bindUniformBlock(gl, programInfo, uniformBlockInfo) {\n\t    var uniformBlockSpec = programInfo.uniformBlockSpec || programInfo;\n\t    var blockSpec = uniformBlockSpec.blockSpecs[uniformBlockInfo.name];\n\t    if (blockSpec) {\n\t      var bufferBindIndex = blockSpec.index;\n\t      gl.bindBufferRange(gl.UNIFORM_BUFFER, bufferBindIndex, uniformBlockInfo.buffer, uniformBlockInfo.offset || 0, uniformBlockInfo.array.byteLength);\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\n\t  /**\n\t   * Uploads the current uniform values to the corresponding WebGLBuffer\n\t   * and binds that buffer to the program's corresponding bind point for the uniform block object.\n\t   *\n\t   * If you haven't changed any values and you only need to bind the uniform block object\n\t   * call {@link module:twgl.bindUniformBlock} instead.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.\n\t   * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`\n\t   *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as\n\t   *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.\n\t   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from\n\t   *     {@link module:twgl.createUniformBlockInfo}.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setUniformBlock(gl, programInfo, uniformBlockInfo) {\n\t    if (bindUniformBlock(gl, programInfo, uniformBlockInfo)) {\n\t      gl.bufferData(gl.UNIFORM_BUFFER, uniformBlockInfo.array, gl.DYNAMIC_DRAW);\n\t    }\n\t  }\n\n\t  /**\n\t   * Sets values of a uniform block object\n\t   *\n\t   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo A UniformBlockInfo as returned by {@link module:twgl.createUniformBlockInfo}.\n\t   * @param {Object.<string, ?>} values A uniform name to value map where the value is correct for the given\n\t   *    type of uniform. So for example given a block like\n\t   *\n\t   *       uniform SomeBlock {\n\t   *         float someFloat;\n\t   *         vec2 someVec2;\n\t   *         vec3 someVec3Array[2];\n\t   *         int someInt;\n\t   *       }\n\t   *\n\t   *  You can set the values of the uniform block with\n\t   *\n\t   *       twgl.setBlockUniforms(someBlockInfo, {\n\t   *          someFloat: 12.3,\n\t   *          someVec2: [1, 2],\n\t   *          someVec3Array: [1, 2, 3, 4, 5, 6],\n\t   *          someInt: 5,\n\t   *       }\n\t   *\n\t   *  Arrays can be JavaScript arrays or typed arrays\n\t   *\n\t   *  Any name that doesn't match will be ignored\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setBlockUniforms(uniformBlockInfo, values) {\n\t    var uniforms = uniformBlockInfo.uniforms;\n\t    for (var name in values) {\n\t      var array = uniforms[name];\n\t      if (array) {\n\t        var value = values[name];\n\t        if (value.length) {\n\t          array.set(value);\n\t        } else {\n\t          array[0] = value;\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * Set uniforms and binds related textures.\n\t   *\n\t   * example:\n\t   *\n\t   *     var programInfo = createProgramInfo(\n\t   *         gl, [\"some-vs\", \"some-fs\"]);\n\t   *\n\t   *     var tex1 = gl.createTexture();\n\t   *     var tex2 = gl.createTexture();\n\t   *\n\t   *     ... assume we setup the textures with data ...\n\t   *\n\t   *     var uniforms = {\n\t   *       u_someSampler: tex1,\n\t   *       u_someOtherSampler: tex2,\n\t   *       u_someColor: [1,0,0,1],\n\t   *       u_somePosition: [0,1,1],\n\t   *       u_someMatrix: [\n\t   *         1,0,0,0,\n\t   *         0,1,0,0,\n\t   *         0,0,1,0,\n\t   *         0,0,0,0,\n\t   *       ],\n\t   *     };\n\t   *\n\t   *     gl.useProgram(program);\n\t   *\n\t   * This will automatically bind the textures AND set the\n\t   * uniforms.\n\t   *\n\t   *     twgl.setUniforms(programInfo, uniforms);\n\t   *\n\t   * For the example above it is equivalent to\n\t   *\n\t   *     var texUnit = 0;\n\t   *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n\t   *     gl.bindTexture(gl.TEXTURE_2D, tex1);\n\t   *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n\t   *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n\t   *     gl.bindTexture(gl.TEXTURE_2D, tex2);\n\t   *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n\t   *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);\n\t   *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);\n\t   *     gl.uniformMatrix4fv(u_someMatrix, false, [\n\t   *         1,0,0,0,\n\t   *         0,1,0,0,\n\t   *         0,0,1,0,\n\t   *         0,0,0,0,\n\t   *       ]);\n\t   *\n\t   * Note it is perfectly reasonable to call `setUniforms` multiple times. For example\n\t   *\n\t   *     var uniforms = {\n\t   *       u_someSampler: tex1,\n\t   *       u_someOtherSampler: tex2,\n\t   *     };\n\t   *\n\t   *     var moreUniforms {\n\t   *       u_someColor: [1,0,0,1],\n\t   *       u_somePosition: [0,1,1],\n\t   *       u_someMatrix: [\n\t   *         1,0,0,0,\n\t   *         0,1,0,0,\n\t   *         0,0,1,0,\n\t   *         0,0,0,0,\n\t   *       ],\n\t   *     };\n\t   *\n\t   *     twgl.setUniforms(programInfo, uniforms);\n\t   *     twgl.setUniforms(programInfo, moreUniforms);\n\t   *\n\t   * You can also add WebGLSamplers to uniform samplers as in\n\t   *\n\t   *     var uniforms = {\n\t   *       u_someSampler: {\n\t   *         texture: someWebGLTexture,\n\t   *         sampler: someWebGLSampler,\n\t   *       },\n\t   *     };\n\t   *\n\t   * In which case both the sampler and texture will be bound to the\n\t   * same unit.\n\t   *\n\t   * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from\n\t   *        `createUniformSetters`.\n\t   * @param {Object.<string, ?>} values an object with values for the\n\t   *        uniforms.\n\t   *   You can pass multiple objects by putting them in an array or by calling with more arguments.For example\n\t   *\n\t   *     var sharedUniforms = {\n\t   *       u_fogNear: 10,\n\t   *       u_projection: ...\n\t   *       ...\n\t   *     };\n\t   *\n\t   *     var localUniforms = {\n\t   *       u_world: ...\n\t   *       u_diffuseColor: ...\n\t   *     };\n\t   *\n\t   *     twgl.setUniforms(programInfo, sharedUniforms, localUniforms);\n\t   *\n\t   *     // is the same as\n\t   *\n\t   *     twgl.setUniforms(programInfo, [sharedUniforms, localUniforms]);\n\t   *\n\t   *     // is the same as\n\t   *\n\t   *     twgl.setUniforms(programInfo, sharedUniforms);\n\t   *     twgl.setUniforms(programInfo, localUniforms};\n\t   *\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setUniforms(setters, values) {\n\t    // eslint-disable-line\n\t    var actualSetters = setters.uniformSetters || setters;\n\t    var numArgs = arguments.length;\n\t    for (var andx = 1; andx < numArgs; ++andx) {\n\t      var vals = arguments[andx];\n\t      if (Array.isArray(vals)) {\n\t        var numValues = vals.length;\n\t        for (var ii = 0; ii < numValues; ++ii) {\n\t          setUniforms(actualSetters, vals[ii]);\n\t        }\n\t      } else {\n\t        for (var name in vals) {\n\t          var setter = actualSetters[name];\n\t          if (setter) {\n\t            setter(vals[name]);\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * Creates setter functions for all attributes of a shader\n\t   * program. You can pass this to {@link module:twgl.setBuffersAndAttributes} to set all your buffers and attributes.\n\t   *\n\t   * @see {@link module:twgl.setAttributes} for example\n\t   * @param {WebGLProgram} program the program to create setters for.\n\t   * @return {Object.<string, function>} an object with a setter for each attribute by name.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createAttributeSetters(gl, program) {\n\t    var attribSetters = {};\n\n\t    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\t    for (var ii = 0; ii < numAttribs; ++ii) {\n\t      var attribInfo = gl.getActiveAttrib(program, ii);\n\t      if (!attribInfo) {\n\t        break;\n\t      }\n\t      var index = gl.getAttribLocation(program, attribInfo.name);\n\t      var typeInfo = attrTypeMap[attribInfo.type];\n\t      attribSetters[attribInfo.name] = typeInfo.setter(gl, index, typeInfo);\n\t    }\n\n\t    return attribSetters;\n\t  }\n\n\t  /**\n\t   * Sets attributes and binds buffers (deprecated... use {@link module:twgl.setBuffersAndAttributes})\n\t   *\n\t   * Example:\n\t   *\n\t   *     var program = createProgramFromScripts(\n\t   *         gl, [\"some-vs\", \"some-fs\");\n\t   *\n\t   *     var attribSetters = createAttributeSetters(program);\n\t   *\n\t   *     var positionBuffer = gl.createBuffer();\n\t   *     var texcoordBuffer = gl.createBuffer();\n\t   *\n\t   *     var attribs = {\n\t   *       a_position: {buffer: positionBuffer, numComponents: 3},\n\t   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n\t   *     };\n\t   *\n\t   *     gl.useProgram(program);\n\t   *\n\t   * This will automatically bind the buffers AND set the\n\t   * attributes.\n\t   *\n\t   *     setAttributes(attribSetters, attribs);\n\t   *\n\t   * Properties of attribs. For each attrib you can add\n\t   * properties:\n\t   *\n\t   * *   type: the type of data in the buffer. Default = gl.FLOAT\n\t   * *   normalize: whether or not to normalize the data. Default = false\n\t   * *   stride: the stride. Default = 0\n\t   * *   offset: offset into the buffer. Default = 0\n\t   *\n\t   * For example if you had 3 value float positions, 2 value\n\t   * float texcoord and 4 value uint8 colors you'd setup your\n\t   * attribs like this\n\t   *\n\t   *     var attribs = {\n\t   *       a_position: {buffer: positionBuffer, numComponents: 3},\n\t   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n\t   *       a_color: {\n\t   *         buffer: colorBuffer,\n\t   *         numComponents: 4,\n\t   *         type: gl.UNSIGNED_BYTE,\n\t   *         normalize: true,\n\t   *       },\n\t   *     };\n\t   *\n\t   * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters\n\t   * @param {Object.<string, module:twgl.AttribInfo>} buffers AttribInfos mapped by attribute name.\n\t   * @memberOf module:twgl/programs\n\t   * @deprecated use {@link module:twgl.setBuffersAndAttributes}\n\t   */\n\t  function setAttributes(setters, buffers) {\n\t    for (var name in buffers) {\n\t      var setter = setters[name];\n\t      if (setter) {\n\t        setter(buffers[name]);\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate\n\t   *\n\t   * Example:\n\t   *\n\t   *     var programInfo = createProgramInfo(\n\t   *         gl, [\"some-vs\", \"some-fs\");\n\t   *\n\t   *     var arrays = {\n\t   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *     };\n\t   *\n\t   *     var bufferInfo = createBufferInfoFromArrays(gl, arrays);\n\t   *\n\t   *     gl.useProgram(programInfo.program);\n\t   *\n\t   * This will automatically bind the buffers AND set the\n\t   * attributes.\n\t   *\n\t   *     setBuffersAndAttributes(gl, programInfo, bufferInfo);\n\t   *\n\t   * For the example above it is equivilent to\n\t   *\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\t   *     gl.enableVertexAttribArray(a_positionLocation);\n\t   *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n\t   *     gl.enableVertexAttribArray(a_texcoordLocation);\n\t   *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n\t   * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters A `ProgramInfo` as returned from {@link module:twgl.createProgrmaInfo} or Attribute setters as returned from {@link module:twgl.createAttributeSetters}\n\t   * @param {(module:twgl.BufferInfo|module:twgl.vertexArrayInfo)} buffers a `BufferInfo` as returned from {@link module:twgl.createBufferInfoFromArrays}.\n\t   *   or a `VertexArrayInfo` as returned from {@link module:twgl.createVertexArrayInfo}\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setBuffersAndAttributes(gl, programInfo, buffers) {\n\t    if (buffers.vertexArrayObject) {\n\t      gl.bindVertexArray(buffers.vertexArrayObject);\n\t    } else {\n\t      setAttributes(programInfo.attribSetters || programInfo, buffers.attribs);\n\t      if (buffers.indices) {\n\t        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * @typedef {Object} ProgramInfo\n\t   * @property {WebGLProgram} program A shader program\n\t   * @property {Object<string, function>} uniformSetters object of setters as returned from createUniformSetters,\n\t   * @property {Object<string, function>} attribSetters object of setters as returned from createAttribSetters,\n\t   * @propetty {module:twgl.UniformBlockSpec} [uniformBlockSpace] a uniform block spec for making UniformBlockInfos with createUniformBlockInfo etc..\n\t   * @property {Object<string, module:twgl.TransformFeedbackInfo>} [transformFeedbackInfo] info for transform feedbacks\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a ProgramInfo from an existing program.\n\t   *\n\t   * A ProgramInfo contains\n\t   *\n\t   *     programInfo = {\n\t   *        program: WebGLProgram,\n\t   *        uniformSetters: object of setters as returned from createUniformSetters,\n\t   *        attribSetters: object of setters as returned from createAttribSetters,\n\t   *     }\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {WebGLProgram} program an existing WebGLProgram.\n\t   * @return {module:twgl.ProgramInfo} The created ProgramInfo.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramInfoFromProgram(gl, program) {\n\t    var uniformSetters = createUniformSetters(gl, program);\n\t    var attribSetters = createAttributeSetters(gl, program);\n\t    var programInfo = {\n\t      program: program,\n\t      uniformSetters: uniformSetters,\n\t      attribSetters: attribSetters\n\t    };\n\n\t    if (utils.isWebGL2(gl)) {\n\t      programInfo.uniformBlockSpec = createUniformBlockSpecFromProgram(gl, program);\n\t      programInfo.transformFeedbackInfo = createTransformFeedbackInfo(gl, program);\n\t    }\n\n\t    return programInfo;\n\t  }\n\n\t  /**\n\t   * Creates a ProgramInfo from 2 sources.\n\t   *\n\t   * A ProgramInfo contains\n\t   *\n\t   *     programInfo = {\n\t   *        program: WebGLProgram,\n\t   *        uniformSetters: object of setters as returned from createUniformSetters,\n\t   *        attribSetters: object of setters as returned from createAttribSetters,\n\t   *     }\n\t   *\n\t   * NOTE: There are 4 signatures for this function\n\t   *\n\t   *     twgl.createProgramInfo(gl, [vs, fs], options);\n\t   *     twgl.createProgramInfo(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {string[]} shaderSources Array of sources for the\n\t   *        shaders or ids. The first is assumed to be the vertex shader,\n\t   *        the second the fragment shader.\n\t   * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the attributes. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {module:twgl.ProgramInfo?} The created ProgramInfo or null if it failed to link or compile\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramInfo(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n\t    var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);\n\t    var good = true;\n\t    shaderSources = shaderSources.map(function (source) {\n\t      // Lets assume if there is no \\n it's an id\n\t      if (source.indexOf(\"\\n\") < 0) {\n\t        var script = document.getElementById(source);\n\t        if (!script) {\n\t          progOptions.errorCallback(\"no element with id: \" + source);\n\t          good = false;\n\t        } else {\n\t          source = script.text;\n\t        }\n\t      }\n\t      return source;\n\t    });\n\t    if (!good) {\n\t      return null;\n\t    }\n\t    var program = createProgramFromSources(gl, shaderSources, progOptions);\n\t    if (!program) {\n\t      return null;\n\t    }\n\t    return createProgramInfoFromProgram(gl, program);\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"createAttributeSetters\": createAttributeSetters,\n\n\t    \"createProgram\": createProgram,\n\t    \"createProgramFromScripts\": createProgramFromScripts,\n\t    \"createProgramFromSources\": createProgramFromSources,\n\t    \"createProgramInfo\": createProgramInfo,\n\t    \"createProgramInfoFromProgram\": createProgramInfoFromProgram,\n\t    \"createUniformSetters\": createUniformSetters,\n\t    \"createUniformBlockSpecFromProgram\": createUniformBlockSpecFromProgram,\n\t    \"createUniformBlockInfoFromProgram\": createUniformBlockInfoFromProgram,\n\t    \"createUniformBlockInfo\": createUniformBlockInfo,\n\n\t    \"createTransformFeedback\": createTransformFeedback,\n\t    \"createTransformFeedbackInfo\": createTransformFeedbackInfo,\n\t    \"bindTransformFeedbackInfo\": bindTransformFeedbackInfo,\n\n\t    \"setAttributes\": setAttributes,\n\t    \"setBuffersAndAttributes\": setBuffersAndAttributes,\n\t    \"setUniforms\": setUniforms,\n\t    \"setUniformBlock\": setUniformBlock,\n\t    \"setBlockUniforms\": setBlockUniforms,\n\t    \"bindUniformBlock\": bindUniformBlock\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (textures, utils) {\n\t  \"use strict\";\n\n\t  /**\n\t   * Framebuffer related functions\n\t   *\n\t   * For backward compatibily they are available at both `twgl.framebuffer` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/framebuffers\n\t   */\n\n\t  // make sure we don't see a global gl\n\n\t  var gl = undefined; // eslint-disable-line\n\n\t  var UNSIGNED_BYTE = 0x1401;\n\n\t  /* PixelFormat */\n\t  var DEPTH_COMPONENT = 0x1902;\n\t  var RGBA = 0x1908;\n\n\t  /* Framebuffer Object. */\n\t  var RGBA4 = 0x8056;\n\t  var RGB5_A1 = 0x8057;\n\t  var RGB565 = 0x8D62;\n\t  var DEPTH_COMPONENT16 = 0x81A5;\n\t  var STENCIL_INDEX = 0x1901;\n\t  var STENCIL_INDEX8 = 0x8D48;\n\t  var DEPTH_STENCIL = 0x84F9;\n\t  var COLOR_ATTACHMENT0 = 0x8CE0;\n\t  var DEPTH_ATTACHMENT = 0x8D00;\n\t  var STENCIL_ATTACHMENT = 0x8D20;\n\t  var DEPTH_STENCIL_ATTACHMENT = 0x821A;\n\n\t  /* TextureWrapMode */\n\t  var REPEAT = 0x2901; // eslint-disable-line\n\t  var CLAMP_TO_EDGE = 0x812F;\n\t  var MIRRORED_REPEAT = 0x8370; // eslint-disable-line\n\n\t  /* TextureMagFilter */\n\t  var NEAREST = 0x2600; // eslint-disable-line\n\t  var LINEAR = 0x2601;\n\n\t  /* TextureMinFilter */\n\t  var NEAREST_MIPMAP_NEAREST = 0x2700; // eslint-disable-line\n\t  var LINEAR_MIPMAP_NEAREST = 0x2701; // eslint-disable-line\n\t  var NEAREST_MIPMAP_LINEAR = 0x2702; // eslint-disable-line\n\t  var LINEAR_MIPMAP_LINEAR = 0x2703; // eslint-disable-line\n\n\t  /**\n\t   * The options for a framebuffer attachment.\n\t   *\n\t   * Note: For a `format` that is a texture include all the texture\n\t   * options from {@link module:twgl.TextureOptions} for example\n\t   * `min`, `mag`, `clamp`, etc... Note that unlike {@link module:twgl.TextureOptions}\n\t   * `auto` defaults to `false` for attachment textures but `min` and `mag` default\n\t   * to `gl.LINEAR` and `wrap` defaults to `CLAMP_TO_EDGE`\n\t   *\n\t   * @typedef {Object} AttachmentOptions\n\t   * @property {number} [attach] The attachment point. Defaults\n\t   *   to `gl.COLOR_ATTACTMENT0 + ndx` unless type is a depth or stencil type\n\t   *   then it's gl.DEPTH_ATTACHMENT or `gl.DEPTH_STENCIL_ATTACHMENT` depending\n\t   *   on the format or attachment type.\n\t   * @property {number} [format] The format. If one of `gl.RGBA4`,\n\t   *   `gl.RGB565`, `gl.RGB5_A1`, `gl.DEPTH_COMPONENT16`,\n\t   *   `gl.STENCIL_INDEX8` or `gl.DEPTH_STENCIL` then will create a\n\t   *   renderbuffer. Otherwise will create a texture. Default = `gl.RGBA`\n\t   * @property {number} [type] The type. Used for texture. Default = `gl.UNSIGNED_BYTE`.\n\t   * @property {number} [target] The texture target for `gl.framebufferTexture2D`.\n\t   *   Defaults to `gl.TEXTURE_2D`. Set to appropriate face for cube maps.\n\t   * @property {number} [level] level for `gl.framebufferTexture2D`. Defaults to 0.\n\t   * @property {WebGLObject} [attachment] An existing renderbuffer or texture.\n\t   *    If provided will attach this Object. This allows you to share\n\t   *    attachemnts across framebuffers.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  var defaultAttachments = [{ format: RGBA, type: UNSIGNED_BYTE, min: LINEAR, wrap: CLAMP_TO_EDGE }, { format: DEPTH_STENCIL }];\n\n\t  var attachmentsByFormat = {};\n\t  attachmentsByFormat[DEPTH_STENCIL] = DEPTH_STENCIL_ATTACHMENT;\n\t  attachmentsByFormat[STENCIL_INDEX] = STENCIL_ATTACHMENT;\n\t  attachmentsByFormat[STENCIL_INDEX8] = STENCIL_ATTACHMENT;\n\t  attachmentsByFormat[DEPTH_COMPONENT] = DEPTH_ATTACHMENT;\n\t  attachmentsByFormat[DEPTH_COMPONENT16] = DEPTH_ATTACHMENT;\n\n\t  function getAttachmentPointForFormat(format) {\n\t    return attachmentsByFormat[format];\n\t  }\n\n\t  var renderbufferFormats = {};\n\t  renderbufferFormats[RGBA4] = true;\n\t  renderbufferFormats[RGB5_A1] = true;\n\t  renderbufferFormats[RGB565] = true;\n\t  renderbufferFormats[DEPTH_STENCIL] = true;\n\t  renderbufferFormats[DEPTH_COMPONENT16] = true;\n\t  renderbufferFormats[STENCIL_INDEX] = true;\n\t  renderbufferFormats[STENCIL_INDEX8] = true;\n\n\t  function isRenderbufferFormat(format) {\n\t    return renderbufferFormats[format];\n\t  }\n\n\t  /**\n\t   * @typedef {Object} FramebufferInfo\n\t   * @property {WebGLFramebuffer} framebuffer The WebGLFramebuffer for this framebufferInfo\n\t   * @property {WebGLObject[]} attachments The created attachments in the same order as passed in to {@link module:twgl.createFramebufferInfo}.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a framebuffer and attachments.\n\t   *\n\t   * This returns a {@link module:twgl.FramebufferInfo} because it needs to return the attachments as well as the framebuffer.\n\t   *\n\t   * The simplest usage\n\t   *\n\t   *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer\n\t   *     var fbi = twgl.createFramebufferInfo(gl);\n\t   *\n\t   * More complex usage\n\t   *\n\t   *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer\n\t   *     var attachments = [\n\t   *       { format: RGB565, mag: NEAREST },\n\t   *       { format: STENCIL_INDEX8 },\n\t   *     ]\n\t   *     var fbi = twgl.createFramebufferInfo(gl, attachments);\n\t   *\n\t   * Passing in a specific size\n\t   *\n\t   *     var width = 256;\n\t   *     var height = 256;\n\t   *     var fbi = twgl.createFramebufferInfo(gl, attachments, width, height);\n\t   *\n\t   * **Note!!** It is up to you to check if the framebuffer is renderable by calling `gl.checkFramebufferStatus`.\n\t   * [WebGL only guarantees 3 combinations of attachments work](https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.6).\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.AttachmentOptions[]} [attachments] which attachments to create. If not provided the default is a framebuffer with an\n\t   *    `RGBA`, `UNSIGNED_BYTE` texture `COLOR_ATTACHMENT0` and a `DEPTH_STENCIL` renderbuffer `DEPTH_STENCIL_ATTACHMENT`.\n\t   * @param {number} [width] the width for the attachments. Default = size of drawingBuffer\n\t   * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer\n\t   * @return {module:twgl.FramebufferInfo} the framebuffer and attachments.\n\t   * @memberOf module:twgl/framebuffers\n\t   */\n\t  function createFramebufferInfo(gl, attachments, width, height) {\n\t    var target = gl.FRAMEBUFFER;\n\t    var fb = gl.createFramebuffer();\n\t    gl.bindFramebuffer(target, fb);\n\t    width = width || gl.drawingBufferWidth;\n\t    height = height || gl.drawingBufferHeight;\n\t    attachments = attachments || defaultAttachments;\n\t    var colorAttachmentCount = 0;\n\t    var framebufferInfo = {\n\t      framebuffer: fb,\n\t      attachments: [],\n\t      width: width,\n\t      height: height\n\t    };\n\t    attachments.forEach(function (attachmentOptions) {\n\t      var attachment = attachmentOptions.attachment;\n\t      var format = attachmentOptions.format;\n\t      var attachmentPoint = getAttachmentPointForFormat(format);\n\t      if (!attachmentPoint) {\n\t        attachmentPoint = COLOR_ATTACHMENT0 + colorAttachmentCount++;\n\t      }\n\t      if (!attachment) {\n\t        if (isRenderbufferFormat(format)) {\n\t          attachment = gl.createRenderbuffer();\n\t          gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);\n\t          gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);\n\t        } else {\n\t          var textureOptions = utils.shallowCopy(attachmentOptions);\n\t          textureOptions.width = width;\n\t          textureOptions.height = height;\n\t          if (textureOptions.auto === undefined) {\n\t            textureOptions.auto = false;\n\t            textureOptions.min = textureOptions.min || gl.LINEAR;\n\t            textureOptions.mag = textureOptions.mag || gl.LINEAR;\n\t            textureOptions.wrapS = textureOptions.wrapS || textureOptions.wrap || gl.CLAMP_TO_EDGE;\n\t            textureOptions.wrapT = textureOptions.wrapT || textureOptions.wrap || gl.CLAMP_TO_EDGE;\n\t          }\n\t          attachment = textures.createTexture(gl, textureOptions);\n\t        }\n\t      }\n\t      if (attachment instanceof WebGLRenderbuffer) {\n\t        gl.framebufferRenderbuffer(target, attachmentPoint, gl.RENDERBUFFER, attachment);\n\t      } else if (attachment instanceof WebGLTexture) {\n\t        gl.framebufferTexture2D(target, attachmentPoint, attachmentOptions.texTarget || gl.TEXTURE_2D, attachment, attachmentOptions.level || 0);\n\t      } else {\n\t        throw \"unknown attachment type\";\n\t      }\n\t      framebufferInfo.attachments.push(attachment);\n\t    });\n\t    return framebufferInfo;\n\t  }\n\n\t  /**\n\t   * Resizes the attachments of a framebuffer.\n\t   *\n\t   * You need to pass in the same `attachments` as you passed in {@link module:twgl.createFramebufferInfo}\n\t   * because TWGL has no idea the format/type of each attachment.\n\t   *\n\t   * The simplest usage\n\t   *\n\t   *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer\n\t   *     var fbi = twgl.createFramebufferInfo(gl);\n\t   *\n\t   *     ...\n\t   *\n\t   *     function render() {\n\t   *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {\n\t   *         // resize the attachments\n\t   *         twgl.resizeFramebufferInfo(gl, fbi);\n\t   *       }\n\t   *\n\t   * More complex usage\n\t   *\n\t   *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer\n\t   *     var attachments = [\n\t   *       { format: RGB565, mag: NEAREST },\n\t   *       { format: STENCIL_INDEX8 },\n\t   *     ]\n\t   *     var fbi = twgl.createFramebufferInfo(gl, attachments);\n\t   *\n\t   *     ...\n\t   *\n\t   *     function render() {\n\t   *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {\n\t   *         // resize the attachments to match\n\t   *         twgl.resizeFramebufferInfo(gl, fbi, attachments);\n\t   *       }\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.FramebufferInfo} framebufferInfo a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.\n\t   * @param {module:twgl.AttachmentOptions[]} [attachments] the same attachments options as passed to {@link module:twgl.createFramebufferInfo}.\n\t   * @param {number} [width] the width for the attachments. Default = size of drawingBuffer\n\t   * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer\n\t   * @memberOf module:twgl/framebuffers\n\t   */\n\t  function resizeFramebufferInfo(gl, framebufferInfo, attachments, width, height) {\n\t    width = width || gl.drawingBufferWidth;\n\t    height = height || gl.drawingBufferHeight;\n\t    framebufferInfo.width = width;\n\t    framebufferInfo.height = height;\n\t    attachments = attachments || defaultAttachments;\n\t    attachments.forEach(function (attachmentOptions, ndx) {\n\t      var attachment = framebufferInfo.attachments[ndx];\n\t      var format = attachmentOptions.format;\n\t      if (attachment instanceof WebGLRenderbuffer) {\n\t        gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);\n\t        gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);\n\t      } else if (attachment instanceof WebGLTexture) {\n\t        textures.resizeTexture(gl, attachment, attachmentOptions, width, height);\n\t      } else {\n\t        throw \"unknown attachment type\";\n\t      }\n\t    });\n\t  }\n\n\t  /**\n\t   * Binds a framebuffer\n\t   *\n\t   * This function pretty much soley exists because I spent hours\n\t   * trying to figure out why something I wrote wasn't working only\n\t   * to realize I forget to set the viewport dimensions.\n\t   * My hope is this function will fix that.\n\t   *\n\t   * It is effectively the same as\n\t   *\n\t   *     gl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);\n\t   *     gl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.FramebufferInfo} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.\n\t   *   If not passed will bind the canvas.\n\t   * @param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.\n\t   * @memberOf module:twgl/framebuffers\n\t   */\n\n\t  function bindFramebufferInfo(gl, framebufferInfo, target) {\n\t    target = target || gl.FRAMEBUFFER;\n\t    if (framebufferInfo) {\n\t      gl.bindFramebuffer(target, framebufferInfo.framebuffer);\n\t      gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);\n\t    } else {\n\t      gl.bindFramebuffer(target, null);\n\t      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n\t    }\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"bindFramebufferInfo\": bindFramebufferInfo,\n\t    \"createFramebufferInfo\": createFramebufferInfo,\n\t    \"resizeFramebufferInfo\": resizeFramebufferInfo\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (typedArrays, utils) {\n\t  \"use strict\";\n\n\t  /**\n\t   * Low level texture related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.textures` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/textures\n\t   */\n\n\t  // make sure we don't see a global gl\n\n\t  var gl = undefined; // eslint-disable-line\n\t  var defaults = {\n\t    textureColor: new Uint8Array([128, 192, 255, 255]),\n\t    textureOptions: {},\n\t    crossOrigin: undefined\n\t  };\n\t  var isArrayBuffer = typedArrays.isArrayBuffer;\n\n\t  // Should we make this on demand?\n\t  var ctx = document.createElement(\"canvas\").getContext(\"2d\");\n\n\t  /* PixelFormat */\n\t  var ALPHA = 0x1906;\n\t  var RGB = 0x1907;\n\t  var RGBA = 0x1908;\n\t  var LUMINANCE = 0x1909;\n\t  var LUMINANCE_ALPHA = 0x190A;\n\t  var DEPTH_COMPONENT = 0x1902;\n\t  var DEPTH_STENCIL = 0x84F9;\n\n\t  /* TextureWrapMode */\n\t  var REPEAT = 0x2901; // eslint-disable-line\n\t  var MIRRORED_REPEAT = 0x8370; // eslint-disable-line\n\n\t  /* TextureMagFilter */\n\t  var NEAREST = 0x2600; // eslint-disable-line\n\n\t  /* TextureMinFilter */\n\t  var NEAREST_MIPMAP_NEAREST = 0x2700; // eslint-disable-line\n\t  var LINEAR_MIPMAP_NEAREST = 0x2701; // eslint-disable-line\n\t  var NEAREST_MIPMAP_LINEAR = 0x2702; // eslint-disable-line\n\t  var LINEAR_MIPMAP_LINEAR = 0x2703; // eslint-disable-line\n\n\t  var R8 = 0x8229;\n\t  var R8_SNORM = 0x8F94;\n\t  var R16F = 0x822D;\n\t  var R32F = 0x822E;\n\t  var R8UI = 0x8232;\n\t  var R8I = 0x8231;\n\t  var RG16UI = 0x823A;\n\t  var RG16I = 0x8239;\n\t  var RG32UI = 0x823C;\n\t  var RG32I = 0x823B;\n\t  var RG8 = 0x822B;\n\t  var RG8_SNORM = 0x8F95;\n\t  var RG16F = 0x822F;\n\t  var RG32F = 0x8230;\n\t  var RG8UI = 0x8238;\n\t  var RG8I = 0x8237;\n\t  var R16UI = 0x8234;\n\t  var R16I = 0x8233;\n\t  var R32UI = 0x8236;\n\t  var R32I = 0x8235;\n\t  var RGB8 = 0x8051;\n\t  var SRGB8 = 0x8C41;\n\t  var RGB565 = 0x8D62;\n\t  var RGB8_SNORM = 0x8F96;\n\t  var R11F_G11F_B10F = 0x8C3A;\n\t  var RGB9_E5 = 0x8C3D;\n\t  var RGB16F = 0x881B;\n\t  var RGB32F = 0x8815;\n\t  var RGB8UI = 0x8D7D;\n\t  var RGB8I = 0x8D8F;\n\t  var RGB16UI = 0x8D77;\n\t  var RGB16I = 0x8D89;\n\t  var RGB32UI = 0x8D71;\n\t  var RGB32I = 0x8D83;\n\t  var RGBA8 = 0x8058;\n\t  var SRGB8_ALPHA8 = 0x8C43;\n\t  var RGBA8_SNORM = 0x8F97;\n\t  var RGB5_A1 = 0x8057;\n\t  var RGBA4 = 0x8056;\n\t  var RGB10_A2 = 0x8059;\n\t  var RGBA16F = 0x881A;\n\t  var RGBA32F = 0x8814;\n\t  var RGBA8UI = 0x8D7C;\n\t  var RGBA8I = 0x8D8E;\n\t  var RGB10_A2UI = 0x906F;\n\t  var RGBA16UI = 0x8D76;\n\t  var RGBA16I = 0x8D88;\n\t  var RGBA32I = 0x8D82;\n\t  var RGBA32UI = 0x8D70;\n\n\t  var DEPTH_COMPONENT16 = 0x81A5;\n\t  var DEPTH_COMPONENT24 = 0x81A6;\n\t  var DEPTH_COMPONENT32F = 0x8CAC;\n\t  var DEPTH32F_STENCIL8 = 0x8CAD;\n\t  var DEPTH24_STENCIL8 = 0x88F0;\n\n\t  /* DataType */\n\t  var BYTE = 0x1400;\n\t  var UNSIGNED_BYTE = 0x1401;\n\t  var SHORT = 0x1402;\n\t  var UNSIGNED_SHORT = 0x1403;\n\t  var INT = 0x1404;\n\t  var UNSIGNED_INT = 0x1405;\n\t  var FLOAT = 0x1406;\n\t  var UNSIGNED_SHORT_4_4_4_4 = 0x8033;\n\t  var UNSIGNED_SHORT_5_5_5_1 = 0x8034;\n\t  var UNSIGNED_SHORT_5_6_5 = 0x8363;\n\t  var HALF_FLOAT = 0x140B;\n\t  var HALF_FLOAT_OES = 0x8D61; // Thanks Khronos for making this different >:(\n\t  var UNSIGNED_INT_2_10_10_10_REV = 0x8368;\n\t  var UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;\n\t  var UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;\n\t  var FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;\n\t  var UNSIGNED_INT_24_8 = 0x84FA;\n\n\t  var RG = 0x8227;\n\t  var RG_INTEGER = 0x8228;\n\t  var RED = 0x1903;\n\t  var RED_INTEGER = 0x8D94;\n\t  var RGB_INTEGER = 0x8D98;\n\t  var RGBA_INTEGER = 0x8D99;\n\n\t  var formatInfo = {};\n\t  {\n\t    // NOTE: this is named `numColorComponents` vs `numComponents` so we can let Uglify mangle\n\t    // the name.\n\t    var f = formatInfo;\n\t    f[ALPHA] = { numColorComponents: 1 };\n\t    f[LUMINANCE] = { numColorComponents: 1 };\n\t    f[LUMINANCE_ALPHA] = { numColorComponents: 2 };\n\t    f[RGB] = { numColorComponents: 3 };\n\t    f[RGBA] = { numColorComponents: 4 };\n\t    f[RED] = { numColorComponents: 1 };\n\t    f[RED_INTEGER] = { numColorComponents: 1 };\n\t    f[RG] = { numColorComponents: 2 };\n\t    f[RG_INTEGER] = { numColorComponents: 2 };\n\t    f[RGB] = { numColorComponents: 3 };\n\t    f[RGB_INTEGER] = { numColorComponents: 3 };\n\t    f[RGBA] = { numColorComponents: 4 };\n\t    f[RGBA_INTEGER] = { numColorComponents: 4 };\n\t    f[DEPTH_COMPONENT] = { numColorComponents: 1 };\n\t    f[DEPTH_STENCIL] = { numColorComponents: 2 };\n\t  }\n\n\t  var textureInternalFormatInfo = {};\n\t  {\n\t    (function () {\n\t      // NOTE: these properties need unique names so we can let Uglify mangle the name.\n\t      var t = textureInternalFormatInfo;\n\t      // unsized formats\n\t      t[ALPHA] = { textureFormat: ALPHA, colorRenderable: true, textureFilterable: true, bytesPerElement: [1, 2, 2, 4], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT] };\n\t      t[LUMINANCE] = { textureFormat: LUMINANCE, colorRenderable: true, textureFilterable: true, bytesPerElement: [1, 2, 2, 4], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT] };\n\t      t[LUMINANCE_ALPHA] = { textureFormat: LUMINANCE_ALPHA, colorRenderable: true, textureFilterable: true, bytesPerElement: [2, 4, 4, 8], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT] };\n\t      t[RGB] = { textureFormat: RGB, colorRenderable: true, textureFilterable: true, bytesPerElement: [3, 6, 6, 12, 2], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_5_6_5] };\n\t      t[RGBA] = { textureFormat: RGBA, colorRenderable: true, textureFilterable: true, bytesPerElement: [4, 8, 8, 16, 2, 2], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1] };\n\n\t      // sized formats\n\t      t[R8] = { textureFormat: RED, colorRenderable: true, textureFilterable: true, bytesPerElement: 1, type: UNSIGNED_BYTE };\n\t      t[R8_SNORM] = { textureFormat: RED, colorRenderable: false, textureFilterable: true, bytesPerElement: 1, type: BYTE };\n\t      t[R16F] = { textureFormat: RED, colorRenderable: false, textureFilterable: true, bytesPerElement: [4, 2], type: [FLOAT, HALF_FLOAT] };\n\t      t[R32F] = { textureFormat: RED, colorRenderable: false, textureFilterable: false, bytesPerElement: 4, type: FLOAT };\n\t      t[R8UI] = { textureFormat: RED_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 1, type: UNSIGNED_BYTE };\n\t      t[R8I] = { textureFormat: RED_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 1, type: BYTE };\n\t      t[R16UI] = { textureFormat: RED_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 2, type: UNSIGNED_SHORT };\n\t      t[R16I] = { textureFormat: RED_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 2, type: SHORT };\n\t      t[R32UI] = { textureFormat: RED_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: UNSIGNED_INT };\n\t      t[R32I] = { textureFormat: RED_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: INT };\n\t      t[RG8] = { textureFormat: RG, colorRenderable: true, textureFilterable: true, bytesPerElement: 2, type: UNSIGNED_BYTE };\n\t      t[RG8_SNORM] = { textureFormat: RG, colorRenderable: false, textureFilterable: true, bytesPerElement: 2, type: BYTE };\n\t      t[RG16F] = { textureFormat: RG, colorRenderable: false, textureFilterable: true, bytesPerElement: [8, 4], type: [FLOAT, HALF_FLOAT] };\n\t      t[RG32F] = { textureFormat: RG, colorRenderable: false, textureFilterable: false, bytesPerElement: 8, type: FLOAT };\n\t      t[RG8UI] = { textureFormat: RG_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 2, type: UNSIGNED_BYTE };\n\t      t[RG8I] = { textureFormat: RG_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 2, type: BYTE };\n\t      t[RG16UI] = { textureFormat: RG_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: UNSIGNED_SHORT };\n\t      t[RG16I] = { textureFormat: RG_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: SHORT };\n\t      t[RG32UI] = { textureFormat: RG_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 8, type: UNSIGNED_INT };\n\t      t[RG32I] = { textureFormat: RG_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 8, type: INT };\n\t      t[RGB8] = { textureFormat: RGB, colorRenderable: true, textureFilterable: true, bytesPerElement: 3, type: UNSIGNED_BYTE };\n\t      t[SRGB8] = { textureFormat: RGB, colorRenderable: false, textureFilterable: true, bytesPerElement: 3, type: UNSIGNED_BYTE };\n\t      t[RGB565] = { textureFormat: RGB, colorRenderable: true, textureFilterable: true, bytesPerElement: [3, 2], type: [UNSIGNED_BYTE, UNSIGNED_SHORT_5_6_5] };\n\t      t[RGB8_SNORM] = { textureFormat: RGB, colorRenderable: false, textureFilterable: true, bytesPerElement: 3, type: BYTE };\n\t      t[R11F_G11F_B10F] = { textureFormat: RGB, colorRenderable: false, textureFilterable: true, bytesPerElement: [12, 6, 4], type: [FLOAT, HALF_FLOAT, UNSIGNED_INT_10F_11F_11F_REV] };\n\t      t[RGB9_E5] = { textureFormat: RGB, colorRenderable: false, textureFilterable: true, bytesPerElement: [12, 6, 4], type: [FLOAT, HALF_FLOAT, UNSIGNED_INT_5_9_9_9_REV] };\n\t      t[RGB16F] = { textureFormat: RGB, colorRenderable: false, textureFilterable: true, bytesPerElement: [12, 6], type: [FLOAT, HALF_FLOAT] };\n\t      t[RGB32F] = { textureFormat: RGB, colorRenderable: false, textureFilterable: false, bytesPerElement: 12, type: FLOAT };\n\t      t[RGB8UI] = { textureFormat: RGB_INTEGER, colorRenderable: false, textureFilterable: false, bytesPerElement: 3, type: UNSIGNED_BYTE };\n\t      t[RGB8I] = { textureFormat: RGB_INTEGER, colorRenderable: false, textureFilterable: false, bytesPerElement: 3, type: BYTE };\n\t      t[RGB16UI] = { textureFormat: RGB_INTEGER, colorRenderable: false, textureFilterable: false, bytesPerElement: 6, type: UNSIGNED_SHORT };\n\t      t[RGB16I] = { textureFormat: RGB_INTEGER, colorRenderable: false, textureFilterable: false, bytesPerElement: 6, type: SHORT };\n\t      t[RGB32UI] = { textureFormat: RGB_INTEGER, colorRenderable: false, textureFilterable: false, bytesPerElement: 12, type: UNSIGNED_INT };\n\t      t[RGB32I] = { textureFormat: RGB_INTEGER, colorRenderable: false, textureFilterable: false, bytesPerElement: 12, type: INT };\n\t      t[RGBA8] = { textureFormat: RGBA, colorRenderable: true, textureFilterable: true, bytesPerElement: 4, type: UNSIGNED_BYTE };\n\t      t[SRGB8_ALPHA8] = { textureFormat: RGBA, colorRenderable: true, textureFilterable: true, bytesPerElement: 4, type: UNSIGNED_BYTE };\n\t      t[RGBA8_SNORM] = { textureFormat: RGBA, colorRenderable: false, textureFilterable: true, bytesPerElement: 4, type: BYTE };\n\t      t[RGB5_A1] = { textureFormat: RGBA, colorRenderable: true, textureFilterable: true, bytesPerElement: [4, 2, 4], type: [UNSIGNED_BYTE, UNSIGNED_SHORT_5_5_5_1, UNSIGNED_INT_2_10_10_10_REV] };\n\t      t[RGBA4] = { textureFormat: RGBA, colorRenderable: true, textureFilterable: true, bytesPerElement: [4, 2], type: [UNSIGNED_BYTE, UNSIGNED_SHORT_4_4_4_4] };\n\t      t[RGB10_A2] = { textureFormat: RGBA, colorRenderable: true, textureFilterable: true, bytesPerElement: 4, type: UNSIGNED_INT_2_10_10_10_REV };\n\t      t[RGBA16F] = { textureFormat: RGBA, colorRenderable: false, textureFilterable: true, bytesPerElement: [16, 8], type: [FLOAT, HALF_FLOAT] };\n\t      t[RGBA32F] = { textureFormat: RGBA, colorRenderable: false, textureFilterable: false, bytesPerElement: 16, type: FLOAT };\n\t      t[RGBA8UI] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: UNSIGNED_BYTE };\n\t      t[RGBA8I] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: BYTE };\n\t      t[RGB10_A2UI] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: UNSIGNED_INT_2_10_10_10_REV };\n\t      t[RGBA16UI] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 8, type: UNSIGNED_SHORT };\n\t      t[RGBA16I] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 8, type: SHORT };\n\t      t[RGBA32I] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 16, type: INT };\n\t      t[RGBA32UI] = { textureFormat: RGBA_INTEGER, colorRenderable: true, textureFilterable: false, bytesPerElement: 16, type: UNSIGNED_INT };\n\t      // Sized Internal\n\t      t[DEPTH_COMPONENT16] = { textureFormat: DEPTH_COMPONENT, colorRenderable: true, textureFilterable: false, bytesPerElement: [2, 4], type: [UNSIGNED_SHORT, UNSIGNED_INT] };\n\t      t[DEPTH_COMPONENT24] = { textureFormat: DEPTH_COMPONENT, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: UNSIGNED_INT };\n\t      t[DEPTH_COMPONENT32F] = { textureFormat: DEPTH_COMPONENT, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: FLOAT };\n\t      t[DEPTH24_STENCIL8] = { textureFormat: DEPTH_STENCIL, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: UNSIGNED_INT_24_8 };\n\t      t[DEPTH32F_STENCIL8] = { textureFormat: DEPTH_STENCIL, colorRenderable: true, textureFilterable: false, bytesPerElement: 4, type: FLOAT_32_UNSIGNED_INT_24_8_REV };\n\n\t      Object.keys(t).forEach(function (internalFormat) {\n\t        var info = t[internalFormat];\n\t        info.bytesPerElementMap = {};\n\t        if (Array.isArray(info.bytesPerElement)) {\n\t          info.bytesPerElement.forEach(function (bytesPerElement, ndx) {\n\t            var type = info.type[ndx];\n\t            info.bytesPerElementMap[type] = bytesPerElement;\n\t          });\n\t        } else {\n\t          var type = info.type;\n\t          info.bytesPerElementMap[type] = info.bytesPerElement;\n\t        }\n\t      });\n\t    })();\n\t  }\n\n\t  /**\n\t   * Gets the number of bytes per element for a given internalFormat / type\n\t   * @param {number} internalFormat The internalFormat parameter from texImage2D etc..\n\t   * @param {number} type The type parameter for texImage2D etc..\n\t   * @return {number} the number of bytes per element for the given internalFormat, type combo\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function getBytesPerElementForInternalFormat(internalFormat, type) {\n\t    var info = textureInternalFormatInfo[internalFormat];\n\t    if (!info) {\n\t      throw \"unknown internal format\";\n\t    }\n\t    var bytesPerElement = info.bytesPerElementMap[type];\n\t    if (bytesPerElement === undefined) {\n\t      throw \"unknown internal format\";\n\t    }\n\t    return bytesPerElement;\n\t  }\n\n\t  /**\n\t   * Gets the format for a given internalFormat\n\t   *\n\t   * @param {number} internalFormat The internal format\n\t   * @return {{format:number, type:number}} the corresponding format and type\n\t   */\n\t  function getFormatAndTypeForInternalFormat(internalFormat) {\n\t    var info = textureInternalFormatInfo[internalFormat];\n\t    if (!info) {\n\t      throw \"unknown internal format\";\n\t    }\n\t    return {\n\t      format: info.textureFormat,\n\t      type: Array.isArray(info.type) ? info.type[0] : info.type\n\t    };\n\t  }\n\n\t  /**\n\t   * Returns true if value is power of 2\n\t   * @param {number} value number to check.\n\t   * @return true if value is power of 2\n\t   */\n\t  function isPowerOf2(value) {\n\t    return (value & value - 1) === 0;\n\t  }\n\n\t  /**\n\t   * Gets whether or not we can generate mips for the given format\n\t   * @param {number} internalFormat The internalFormat parameter from texImage2D etc..\n\t   * @param {number} type The type parameter for texImage2D etc..\n\t   * @return {boolean} true if we can generate mips\n\t   */\n\t  function canGenerateMipmap(gl, width, height, internalFormat /*, type */) {\n\t    if (!utils.isWebGL2(gl)) {\n\t      return isPowerOf2(width) && isPowerOf2(height);\n\t    }\n\t    var info = textureInternalFormatInfo[internalFormat];\n\t    if (!info) {\n\t      throw \"unknown internal format\";\n\t    }\n\t    return info.colorRenderable && info.textureFilterable;\n\t  }\n\n\t  /**\n\t   * Gets whether or not we can generate mips for the given format\n\t   * @param {number} internalFormat The internalFormat parameter from texImage2D etc..\n\t   * @param {number} type The type parameter for texImage2D etc..\n\t   * @return {boolean} true if we can generate mips\n\t   */\n\t  function canFilter(internalFormat /*, type */) {\n\t    var info = textureInternalFormatInfo[internalFormat];\n\t    if (!info) {\n\t      throw \"unknown internal format\";\n\t    }\n\t    return info.textureFilterable;\n\t  }\n\n\t  /**\n\t   * Gets the number of compontents for a given image format.\n\t   * @param {number} format the format.\n\t   * @return {number} the number of components for the format.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function getNumComponentsForFormat(format) {\n\t    var info = formatInfo[format];\n\t    if (!info) {\n\t      throw \"unknown format: \" + format;\n\t    }\n\t    return info.numColorComponents;\n\t  }\n\n\t  /**\n\t   * Gets the texture type for a given array type.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @return {number} the gl texture type\n\t   */\n\t  function getTextureTypeForArrayType(gl, src, defaultType) {\n\t    if (isArrayBuffer(src)) {\n\t      return typedArrays.getGLTypeForTypedArray(src);\n\t    }\n\t    return defaultType || gl.UNSIGNED_BYTE;\n\t  }\n\n\t  function guessDimensions(gl, target, width, height, numElements) {\n\t    if (numElements % 1 !== 0) {\n\t      throw \"can't guess dimensions\";\n\t    }\n\t    if (!width && !height) {\n\t      var size = Math.sqrt(numElements / (target === gl.TEXTURE_CUBE_MAP ? 6 : 1));\n\t      if (size % 1 === 0) {\n\t        width = size;\n\t        height = size;\n\t      } else {\n\t        width = numElements;\n\t        height = 1;\n\t      }\n\t    } else if (!height) {\n\t      height = numElements / width;\n\t      if (height % 1) {\n\t        throw \"can't guess dimensions\";\n\t      }\n\t    } else if (!width) {\n\t      width = numElements / height;\n\t      if (width % 1) {\n\t        throw \"can't guess dimensions\";\n\t      }\n\t    }\n\t    return {\n\t      width: width,\n\t      height: height\n\t    };\n\t  }\n\n\t  /**\n\t   * Sets the default texture color.\n\t   *\n\t   * The default texture color is used when loading textures from\n\t   * urls. Because the URL will be loaded async we'd like to be\n\t   * able to use the texture immediately. By putting a 1x1 pixel\n\t   * color in the texture we can start using the texture before\n\t   * the URL has loaded.\n\t   *\n\t   * @param {number[]} color Array of 4 values in the range 0 to 1\n\t   * @deprecated see {@link module:twgl.setDefaults}\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setDefaultTextureColor(color) {\n\t    defaults.textureColor = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);\n\t  }\n\n\t  function setDefaults(newDefaults) {\n\t    utils.copyExistingProperties(newDefaults, defaults);\n\t    if (newDefaults.textureColor) {\n\t      setDefaultTextureColor(newDefaults.textureColor);\n\t    }\n\t  }\n\n\t  /**\n\t   * Gets a string for gl enum\n\t   *\n\t   * Note: Several enums are the same. Without more\n\t   * context (which function) it's impossible to always\n\t   * give the correct enum.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {number} value the value of the enum you want to look up.\n\t   */\n\t  var glEnumToString = function () {\n\t    var enums;\n\n\t    function init(gl) {\n\t      if (!enums) {\n\t        enums = {};\n\t        for (var key in gl) {\n\t          if (typeof gl[key] === 'number') {\n\t            enums[gl[key]] = key;\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    return function glEnumToString(gl, value) {\n\t      init(gl);\n\t      return enums[value] || \"0x\" + value.toString(16);\n\t    };\n\t  }();\n\n\t  /**\n\t   * A function to generate the source for a texture.\n\t   * @callback TextureFunc\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} options the texture options\n\t   * @return {*} Returns any of the things documentented for `src` for {@link module:twgl.TextureOptions}.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Texture options passed to most texture functions. Each function will use whatever options\n\t   * are appropriate for its needs. This lets you pass the same options to all functions.\n\t   *\n\t   * @typedef {Object} TextureOptions\n\t   * @property {number} [target] the type of texture `gl.TEXTURE_2D` or `gl.TEXTURE_CUBE_MAP`. Defaults to `gl.TEXTURE_2D`.\n\t   * @property {number} [width] the width of the texture. Only used if src is an array or typed array or null.\n\t   * @property {number} [height] the height of a texture. Only used if src is an array or typed array or null.\n\t   * @property {number} [depth] the depth of a texture. Only used if src is an array or type array or null and target is `TEXTURE_3D` .\n\t   * @property {number} [min] the min filter setting (eg. `gl.LINEAR`). Defaults to `gl.NEAREST_MIPMAP_LINEAR`\n\t   *     or if texture is not a power of 2 on both dimensions then defaults to `gl.LINEAR`.\n\t   * @property {number} [mag] the mag filter setting (eg. `gl.LINEAR`). Defaults to `gl.LINEAR`\n\t   * @property {number} [minMag] both the min and mag filter settings.\n\t   * @property {number} [internalFormat] internal format for texture. Defaults to `gl.RGBA`\n\t   * @property {number} [format] format for texture. Defaults to `gl.RGBA`.\n\t   * @property {number} [type] type for texture. Defaults to `gl.UNSIGNED_BYTE` unless `src` is ArrayBuffer. If `src`\n\t   *     is ArrayBuffer defaults to type that matches ArrayBuffer type.\n\t   * @property {number} [wrap] Texture wrapping for both S and T (and R if TEXTURE_3D or WebGLSampler). Defaults to `gl.REPEAT` for 2D unless src is WebGL1 and src not npot and `gl.CLAMP_TO_EDGE` for cube\n\t   * @property {number} [wrapS] Texture wrapping for S. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n\t   * @property {number} [wrapT] Texture wrapping for T. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n\t   * @property {number} [wrapR] Texture wrapping for R. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n\t   * @property {number} [minLod] TEXTURE_MIN_LOD setting\n\t   * @property {number} [maxLod] TEXTURE_MAX_LOD setting\n\t   * @property {number} [baseLevel] TEXTURE_BASE_LEVEL setting\n\t   * @property {number} [maxLevel] TEXTURE_MAX_LEVEL setting\n\t   * @property {number} [unpackAlignment] The `gl.UNPACK_ALIGNMENT` used when uploading an array. Defaults to 1.\n\t   * @property {number} [premultiplyAlpha] Whether or not to premultiply alpha. Defaults to whatever the current setting is.\n\t   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n\t   *     the current setting for specific textures.\n\t   * @property {number} [flipY] Whether or not to flip the texture vertically on upload. Defaults to whatever the current setting is.\n\t   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n\t   *     the current setting for specific textures.\n\t   * @property {number} [colorspaceConversion] Whether or not to let the browser do colorspace conversion of the texture on upload. Defaults to whatever the current setting is.\n\t   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n\t   *     the current setting for specific textures.\n\t   * @property {(number[]|ArrayBuffer)} color color used as temporary 1x1 pixel color for textures loaded async when src is a string.\n\t   *    If it's a JavaScript array assumes color is 0 to 1 like most GL colors as in `[1, 0, 0, 1] = red=1, green=0, blue=0, alpha=0`.\n\t   *    Defaults to `[0.5, 0.75, 1, 1]`. See {@link module:twgl.setDefaultTextureColor}. If `false` texture is set. Can be used to re-load a texture\n\t   * @property {boolean} [auto] If not `false` then texture working filtering is set automatically for non-power of 2 images and\n\t   *    mips are generated for power of 2 images.\n\t   * @property {number[]} [cubeFaceOrder] The order that cube faces are pulled out of an img or set of images. The default is\n\t   *\n\t   *     [gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n\t   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n\t   *      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n\t   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n\t   *      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n\t   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]\n\t   *\n\t   * @property {(number[]|ArrayBuffer|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement|string|string[]|module:twgl.TextureFunc)} [src] source for texture\n\t   *\n\t   *    If `string` then it's assumed to be a URL to an image. The image will be downloaded async. A usable\n\t   *    1x1 pixel texture will be returned immediatley. The texture will be updated once the image has downloaded.\n\t   *    If `target` is `gl.TEXTURE_CUBE_MAP` will attempt to divide image into 6 square pieces. 1x6, 6x1, 3x2, 2x3.\n\t   *    The pieces will be uploaded in `cubeFaceOrder`\n\t   *\n\t   *    If `string[]` then it must have 6 entries, one for each face of a cube map. Target must be `gl.TEXTURE_CUBE_MAP`.\n\t   *\n\t   *    If `HTMLElement` then it wil be used immediately to create the contents of the texture. Examples `HTMLImageElement`,\n\t   *    `HTMLCanvasElement`, `HTMLVideoElement`.\n\t   *\n\t   *    If `number[]` or `ArrayBuffer` it's assumed to be data for a texture. If `width` or `height` is\n\t   *    not specified it is guessed as follows. First the number of elements is computed by `src.length / numComponets`\n\t   *    where `numComponents` is derived from `format`. If `target` is `gl.TEXTURE_CUBE_MAP` then `numElements` is divided\n\t   *    by 6. Then\n\t   *\n\t   *    *   If neither `width` nor `height` are specified and `sqrt(numElements)` is an integer then width and height\n\t   *        are set to `sqrt(numElements)`. Otherwise `width = numElements` and `height = 1`.\n\t   *\n\t   *    *   If only one of `width` or `height` is specified then the other equals `numElements / specifiedDimension`.\n\t   *\n\t   * If `number[]` will be converted to `type`.\n\t   *\n\t   * If `src` is a function it will be called with a `WebGLRenderingContext` and these options.\n\t   * Whatever it returns is subject to these rules. So it can return a string url, an `HTMLElement`\n\t   * an array etc...\n\t   *\n\t   * If `src` is undefined then an empty texture will be created of size `width` by `height`.\n\t   *\n\t   * @property {string} [crossOrigin] What to set the crossOrigin property of images when they are downloaded.\n\t   *    default: undefined. Also see {@link module:twgl.setDefaults}.\n\t   *\n\t   * @memberOf module:twgl\n\t   */\n\n\t  // NOTE: While querying GL is considered slow it's not remotely as slow\n\t  // as uploading a texture. On top of that you're unlikely to call this in\n\t  // a perf critical loop. Even if upload a texture every frame that's unlikely\n\t  // to be more than 1 or 2 textures a frame. In other words, the benefits of\n\t  // making the API easy to use outweigh any supposed perf benefits\n\t  var lastPackState = {};\n\n\t  /**\n\t   * Saves any packing state that will be set based on the options.\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   */\n\t  function savePackState(gl, options) {\n\t    if (options.colorspaceConversion !== undefined) {\n\t      lastPackState.colorspaceConversion = gl.getParameter(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL);\n\t      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, options.colorspaceConversion);\n\t    }\n\t    if (options.premultiplyAlpha !== undefined) {\n\t      lastPackState.premultiplyAlpha = gl.getParameter(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL);\n\t      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlpha);\n\t    }\n\t    if (options.flipY !== undefined) {\n\t      lastPackState.flipY = gl.getParameter(gl.UNPACK_FLIP_Y_WEBGL);\n\t      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, options.flipY);\n\t    }\n\t  }\n\n\t  /**\n\t   * Restores any packing state that was set based on the options.\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   */\n\t  function restorePackState(gl, options) {\n\t    if (options.colorspaceConversion !== undefined) {\n\t      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, lastPackState.colorspaceConversion);\n\t    }\n\t    if (options.premultiplyAlpha !== undefined) {\n\t      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, lastPackState.premultiplyAlpha);\n\t    }\n\t    if (options.flipY !== undefined) {\n\t      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, lastPackState.flipY);\n\t    }\n\t  }\n\n\t  var WebGLSamplerCtor = window.WebGLSampler || function NotWebGLSampler() {};\n\n\t  /**\n\t   * Sets the parameters of a texture or sampler\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {number|WebGLSampler} target texture target or sampler\n\t   * @param {function()} parameteriFn texParamteri or samplerParameteri fn\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   */\n\t  function setTextureSamplerParameters(gl, target, parameteriFn, options) {\n\t    if (options.minMag) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MIN_FILTER, options.minMag);\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MAG_FILTER, options.minMag);\n\t    }\n\t    if (options.min) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MIN_FILTER, options.min);\n\t    }\n\t    if (options.mag) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MAG_FILTER, options.mag);\n\t    }\n\t    if (options.wrap) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_WRAP_S, options.wrap);\n\t      parameteriFn.call(gl, target, gl.TEXTURE_WRAP_T, options.wrap);\n\t      if (target === gl.TEXTURE_3D || target instanceof WebGLSamplerCtor) {\n\t        parameteriFn.call(gl, target, gl.TEXTURE_WRAP_R, options.wrap);\n\t      }\n\t    }\n\t    if (options.wrapR) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_WRAP_R, options.wrapR);\n\t    }\n\t    if (options.wrapS) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_WRAP_S, options.wrapS);\n\t    }\n\t    if (options.wrapT) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_WRAP_T, options.wrapT);\n\t    }\n\t    if (options.minLod) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MIN_LOD, options.minLod);\n\t    }\n\t    if (options.maxLod) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MAX_LOD, options.maxLod);\n\t    }\n\t    if (options.baseLevel) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_BASE_LEVEL, options.baseLevel);\n\t    }\n\t    if (options.maxLevel) {\n\t      parameteriFn.call(gl, target, gl.TEXTURE_MAX_LEVEL, options.maxLevel);\n\t    }\n\t  }\n\n\t  /**\n\t   * Sets the texture parameters of a texture.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureParameters(gl, tex, options) {\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    setTextureSamplerParameters(gl, target, gl.texParameteri, options);\n\t  }\n\n\t  /**\n\t   * Sets the sampler parameters of a sampler.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLSampler} sampler the WebGLSampler to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setSamplerParameters(gl, sampler, options) {\n\t    setTextureSamplerParameters(gl, sampler, gl.samplerParameteri, options);\n\t  }\n\n\t  /**\n\t   * Creates a new sampler object and sets parameters.\n\t   *\n\t   * Example:\n\t   *\n\t   *      const sampler = twgl.createSampler(gl, {\n\t   *        minMag: gl.NEAREST,         // sets both TEXTURE_MIN_FILTER and TEXTURE_MAG_FILTER\n\t   *        wrap: gl.CLAMP_TO_NEAREST,  // sets both TEXTURE_WRAP_S and TEXTURE_WRAP_T and TEXTURE_WRAP_R\n\t   *      });\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per sampler.\n\t   * @return {Object.<string,WebGLSampler>} the created samplers by name\n\t   */\n\t  function createSampler(gl, options) {\n\t    var sampler = gl.createSampler();\n\t    setSamplerParameters(gl, sampler, options);\n\t    return sampler;\n\t  }\n\n\t  /**\n\t   * Creates a multiple sampler objects and sets parameters on each.\n\t   *\n\t   * Example:\n\t   *\n\t   *      const samplers = twgl.createSamplers(gl, {\n\t   *        nearest: {\n\t   *          minMag: gl.NEAREST,\n\t   *        },\n\t   *        nearestClampS: {\n\t   *          minMag: gl.NEAREST,\n\t   *          wrapS: gl.CLAMP_TO_NEAREST,\n\t   *        },\n\t   *        linear: {\n\t   *          minMag: gl.LINEAR,\n\t   *        },\n\t   *        nearestClamp: {\n\t   *          minMag: gl.NEAREST,\n\t   *          wrap: gl.CLAMP_TO_EDGE,\n\t   *        },\n\t   *        linearClamp: {\n\t   *          minMag: gl.LINEAR,\n\t   *          wrap: gl.CLAMP_TO_EDGE,\n\t   *        },\n\t   *        linearClampT: {\n\t   *          minMag: gl.LINEAR,\n\t   *          wrapT: gl.CLAMP_TO_EDGE,\n\t   *        },\n\t   *      });\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set on the sampler\n\t   */\n\t  function createSamplers(gl, samplerOptions) {\n\t    var samplers = {};\n\t    Object.keys(samplerOptions).forEach(function (name) {\n\t      samplers[name] = createSampler(gl, samplerOptions[name]);\n\t    });\n\t    return samplers;\n\t  }\n\n\t  /**\n\t   * Makes a 1x1 pixel\n\t   * If no color is passed in uses the default color which can be set by calling `setDefaultTextureColor`.\n\t   * @param {(number[]|ArrayBuffer)} [color] The color using 0-1 values\n\t   * @return {Uint8Array} Unit8Array with color.\n\t   */\n\t  function make1Pixel(color) {\n\t    color = color || defaults.textureColor;\n\t    if (isArrayBuffer(color)) {\n\t      return color;\n\t    }\n\t    return new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);\n\t  }\n\n\t  /**\n\t   * Sets filtering or generates mips for texture based on width or height\n\t   * If width or height is not passed in uses `options.width` and//or `options.height`\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @param {number} [width] width of texture\n\t   * @param {number} [height] height of texture\n\t   * @param {number} [internalFormat] The internalFormat parameter from texImage2D etc..\n\t   * @param {number} [type] The type parameter for texImage2D etc..\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureFilteringForSize(gl, tex, options, width, height, internalFormat, type) {\n\t    options = options || defaults.textureOptions;\n\t    internalFormat = internalFormat || gl.RGBA;\n\t    type = type || gl.UNSIGNED_BYTE;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    width = width || options.width;\n\t    height = height || options.height;\n\t    gl.bindTexture(target, tex);\n\t    if (canGenerateMipmap(gl, width, height, internalFormat, type)) {\n\t      gl.generateMipmap(target);\n\t    } else {\n\t      var filtering = canFilter(internalFormat, type) ? gl.LINEAR : gl.NEAREST;\n\t      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filtering);\n\t      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filtering);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t    }\n\t  }\n\n\t  /**\n\t   * Gets an array of cubemap face enums\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @return {number[]} cubemap face enums\n\t   */\n\t  function getCubeFaceOrder(gl, options) {\n\t    options = options || {};\n\t    return options.cubeFaceOrder || [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];\n\t  }\n\n\t  /**\n\t   * @typedef {Object} FaceInfo\n\t   * @property {number} face gl enum for texImage2D\n\t   * @property {number} ndx face index (0 - 5) into source data\n\t   * @ignore\n\t   */\n\n\t  /**\n\t   * Gets an array of FaceInfos\n\t   * There's a bug in some NVidia drivers that will crash the driver if\n\t   * `gl.TEXTURE_CUBE_MAP_POSITIVE_X` is not uploaded first. So, we take\n\t   * the user's desired order from his faces to WebGL and make sure we\n\t   * do the faces in WebGL order\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @return {FaceInfo[]} cubemap face infos. Arguably the `face` property of each element is redundent but\n\t   *    it's needed internally to sort the array of `ndx` properties by `face`.\n\t   */\n\t  function getCubeFacesWithNdx(gl, options) {\n\t    var faces = getCubeFaceOrder(gl, options);\n\t    // work around bug in NVidia drivers. We have to upload the first face first else the driver crashes :(\n\t    var facesWithNdx = faces.map(function (face, ndx) {\n\t      return { face: face, ndx: ndx };\n\t    });\n\t    facesWithNdx.sort(function (a, b) {\n\t      return a.face - b.face;\n\t    });\n\t    return facesWithNdx;\n\t  }\n\n\t  /**\n\t   * Set a texture from the contents of an element. Will also set\n\t   * texture filtering or generate mips based on the dimensions of the element\n\t   * unless `options.auto === false`. If `target === gl.TEXTURE_CUBE_MAP` will\n\t   * attempt to slice image into 1x6, 2x3, 3x2, or 6x1 images, one for each face.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {HTMLElement} element a canvas, img, or video element.\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   * @kind function\n\t   */\n\t  function setTextureFromElement(gl, tex, element, options) {\n\t    options = options || defaults.textureOptions;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    var width = element.width;\n\t    var height = element.height;\n\t    var internalFormat = options.internalFormat || options.format || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var format = options.format || formatType.format;\n\t    var type = options.type || formatType.type;\n\t    savePackState(gl, options);\n\t    gl.bindTexture(target, tex);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      // guess the parts\n\t      var imgWidth = element.width;\n\t      var imgHeight = element.height;\n\t      var size;\n\t      var slices;\n\t      if (imgWidth / 6 === imgHeight) {\n\t        // It's 6x1\n\t        size = imgHeight;\n\t        slices = [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0];\n\t      } else if (imgHeight / 6 === imgWidth) {\n\t        // It's 1x6\n\t        size = imgWidth;\n\t        slices = [0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5];\n\t      } else if (imgWidth / 3 === imgHeight / 2) {\n\t        // It's 3x2\n\t        size = imgWidth / 3;\n\t        slices = [0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1];\n\t      } else if (imgWidth / 2 === imgHeight / 3) {\n\t        // It's 2x3\n\t        size = imgWidth / 2;\n\t        slices = [0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2];\n\t      } else {\n\t        throw \"can't figure out cube map from element: \" + (element.src ? element.src : element.nodeName);\n\t      }\n\t      ctx.canvas.width = size;\n\t      ctx.canvas.height = size;\n\t      width = size;\n\t      height = size;\n\t      getCubeFacesWithNdx(gl, options).forEach(function (f) {\n\t        var xOffset = slices[f.ndx * 2 + 0] * size;\n\t        var yOffset = slices[f.ndx * 2 + 1] * size;\n\t        ctx.drawImage(element, xOffset, yOffset, size, size, 0, 0, size, size);\n\t        gl.texImage2D(f.face, 0, internalFormat, format, type, ctx.canvas);\n\t      });\n\t      // Free up the canvas memory\n\t      ctx.canvas.width = 1;\n\t      ctx.canvas.height = 1;\n\t    } else if (target === gl.TEXTURE_3D) {\n\t      var smallest = Math.min(element.width, element.height);\n\t      var largest = Math.max(element.width, element.height);\n\t      var depth = largest / smallest;\n\t      if (depth % 1 !== 0) {\n\t        throw \"can not compute 3D dimensions of element\";\n\t      }\n\t      var xMult = element.width === largest ? 1 : 0;\n\t      var yMult = element.height === largest ? 1 : 0;\n\t      gl.texImage3D(target, 0, internalFormat, smallest, smallest, smallest, 0, format, type, null);\n\t      // remove this is texSubImage3D gets width and height arguments\n\t      ctx.canvas.width = smallest;\n\t      ctx.canvas.height = smallest;\n\t      for (var d = 0; d < depth; ++d) {\n\t        //        gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, d * smallest);\n\t        //        gl.texSubImage3D(target, 0, 0, 0, d, format, type, element);\n\t        var srcX = d * smallest * xMult;\n\t        var srcY = d * smallest * yMult;\n\t        var srcW = smallest;\n\t        var srcH = smallest;\n\t        var dstX = 0;\n\t        var dstY = 0;\n\t        var dstW = smallest;\n\t        var dstH = smallest;\n\t        ctx.drawImage(element, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);\n\t        gl.texSubImage3D(target, 0, 0, 0, d, smallest, smallest, 1, format, type, ctx.canvas);\n\t      }\n\t      ctx.canvas.width = 0;\n\t      ctx.canvas.height = 0;\n\t      // FIX (save state)\n\t      //      gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, 0);\n\t    } else {\n\t      gl.texImage2D(target, 0, internalFormat, format, type, element);\n\t    }\n\t    restorePackState(gl, options);\n\t    if (options.auto !== false) {\n\t      setTextureFilteringForSize(gl, tex, options, width, height, internalFormat, type);\n\t    }\n\t    setTextureParameters(gl, tex, options);\n\t  }\n\n\t  function noop() {}\n\n\t  /**\n\t   * Loads an image\n\t   * @param {string} url url to image\n\t   * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null\n\t   *     if there was an error\n\t   * @return {HTMLImageElement} the image being loaded.\n\t   */\n\t  function loadImage(url, crossOrigin, callback) {\n\t    callback = callback || noop;\n\t    var img = new Image();\n\t    crossOrigin = crossOrigin !== undefined ? crossOrigin : defaults.crossOrigin;\n\t    if (crossOrigin !== undefined) {\n\t      img.crossOrigin = crossOrigin;\n\t    }\n\n\t    function clearEventHandlers() {\n\t      img.removeEventListener('error', onError); // eslint-disable-line\n\t      img.removeEventListener('load', onLoad); // eslint-disable-line\n\t      img = null;\n\t    }\n\n\t    function onError() {\n\t      var msg = \"couldn't load image: \" + url;\n\t      utils.error(msg);\n\t      callback(msg, img);\n\t      clearEventHandlers();\n\t    }\n\n\t    function onLoad() {\n\t      callback(null, img);\n\t      clearEventHandlers();\n\t    }\n\n\t    img.addEventListener('error', onError);\n\t    img.addEventListener('load', onLoad);\n\t    img.src = url;\n\t    return img;\n\t  }\n\n\t  /**\n\t   * Sets a texture to a 1x1 pixel color. If `options.color === false` is nothing happens. If it's not set\n\t   * the default texture color is used which can be set by calling `setDefaultTextureColor`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureTo1PixelColor(gl, tex, options) {\n\t    options = options || defaults.textureOptions;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    if (options.color === false) {\n\t      return;\n\t    }\n\t    // Assume it's a URL\n\t    // Put 1x1 pixels in texture. That makes it renderable immediately regardless of filtering.\n\t    var color = make1Pixel(options.color);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      for (var ii = 0; ii < 6; ++ii) {\n\t        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n\t      }\n\t    } else if (target === gl.TEXTURE_3D || target === gl.TEXTURE_2D_ARRAY) {\n\t      gl.texImage3D(target, 0, gl.RGBA, 1, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n\t    } else {\n\t      gl.texImage2D(target, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n\t    }\n\t  }\n\n\t  /**\n\t   * The src image(s) used to create a texture.\n\t   *\n\t   * When you call {@link module:twgl.createTexture} or {@link module:twgl.createTextures}\n\t   * you can pass in urls for images to load into the textures. If it's a single url\n\t   * then this will be a single HTMLImageElement. If it's an array of urls used for a cubemap\n\t   * this will be a corresponding array of images for the cubemap.\n\t   *\n\t   * @typedef {HTMLImageElement|HTMLImageElement[]} TextureSrc\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * A callback for when an image finished downloading and been uploaded into a texture\n\t   * @callback TextureReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {WebGLTexture} texture the texture.\n\t   * @param {module:twgl.TextureSrc} souce image(s) used to as the src for the texture\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * A callback for when all images have finished downloading and been uploaded into their respective textures\n\t   * @callback TexturesReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {Object.<string, WebGLTexture>} textures the created textures by name. Same as returned by {@link module:twgl.createTextures}.\n\t   * @param {Object.<string, module:twgl.TextureSrc>} sources the image(s) used for the texture by name.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * A callback for when an image finished downloading and been uploaded into a texture\n\t   * @callback CubemapReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {WebGLTexture} tex the texture.\n\t   * @param {HTMLImageElement[]} imgs the images for each face.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * A callback for when an image finished downloading and been uploaded into a texture\n\t   * @callback ThreeDReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {WebGLTexture} tex the texture.\n\t   * @param {HTMLImageElement[]} imgs the images for each slice.\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Loads a texture from an image from a Url as specified in `options.src`\n\t   * If `options.color !== false` will set the texture to a 1x1 pixel color so that the texture is\n\t   * immediately useable. It will be updated with the contents of the image once the image has finished\n\t   * downloading. Filtering options will be set as approriate for image unless `options.auto === false`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.TextureReadyCallback} [callback] A function to be called when the image has finished loading. err will\n\t   *    be non null if there was an error.\n\t   * @return {HTMLImageElement} the image being downloaded.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function loadTextureFromUrl(gl, tex, options, callback) {\n\t    callback = callback || noop;\n\t    options = options || defaults.textureOptions;\n\t    setTextureTo1PixelColor(gl, tex, options);\n\t    // Because it's async we need to copy the options.\n\t    options = utils.shallowCopy(options);\n\t    var img = loadImage(options.src, options.crossOrigin, function (err, img) {\n\t      if (err) {\n\t        callback(err, tex, img);\n\t      } else {\n\t        setTextureFromElement(gl, tex, img, options);\n\t        callback(null, tex, img);\n\t      }\n\t    });\n\t    return img;\n\t  }\n\n\t  /**\n\t   * Loads a cubemap from 6 urls as specified in `options.src`. Will set the cubemap to a 1x1 pixel color\n\t   * so that it is usable immediately unless `option.color === false`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.CubemapReadyCallback} [callback] A function to be called when all the images have finished loading. err will\n\t   *    be non null if there was an error.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function loadCubemapFromUrls(gl, tex, options, callback) {\n\t    callback = callback || noop;\n\t    var urls = options.src;\n\t    if (urls.length !== 6) {\n\t      throw \"there must be 6 urls for a cubemap\";\n\t    }\n\t    var internalFormat = options.internalFormat || options.format || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var format = options.format || formatType.format;\n\t    var type = options.type || gl.UNSIGNED_BYTE;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    if (target !== gl.TEXTURE_CUBE_MAP) {\n\t      throw \"target must be TEXTURE_CUBE_MAP\";\n\t    }\n\t    setTextureTo1PixelColor(gl, tex, options);\n\t    // Because it's async we need to copy the options.\n\t    options = utils.shallowCopy(options);\n\t    var numToLoad = 6;\n\t    var errors = [];\n\t    var imgs;\n\t    var faces = getCubeFaceOrder(gl, options);\n\n\t    function uploadImg(faceTarget) {\n\t      return function (err, img) {\n\t        --numToLoad;\n\t        if (err) {\n\t          errors.push(err);\n\t        } else {\n\t          if (img.width !== img.height) {\n\t            errors.push(\"cubemap face img is not a square: \" + img.src);\n\t          } else {\n\t            savePackState(gl, options);\n\t            gl.bindTexture(target, tex);\n\n\t            // So assuming this is the first image we now have one face that's img sized\n\t            // and 5 faces that are 1x1 pixel so size the other faces\n\t            if (numToLoad === 5) {\n\t              // use the default order\n\t              getCubeFaceOrder(gl).forEach(function (otherTarget) {\n\t                // Should we re-use the same face or a color?\n\t                gl.texImage2D(otherTarget, 0, internalFormat, format, type, img);\n\t              });\n\t            } else {\n\t              gl.texImage2D(faceTarget, 0, internalFormat, format, type, img);\n\t            }\n\n\t            restorePackState(gl, options);\n\t            gl.generateMipmap(target);\n\t          }\n\t        }\n\n\t        if (numToLoad === 0) {\n\t          callback(errors.length ? errors : undefined, imgs, tex);\n\t        }\n\t      };\n\t    }\n\n\t    imgs = urls.map(function (url, ndx) {\n\t      return loadImage(url, options.crossOrigin, uploadImg(faces[ndx]));\n\t    });\n\t  }\n\n\t  /**\n\t   * Loads a 2d array or 3d texture from urls as specified in `options.src`.\n\t   * Will set the texture to a 1x1 pixel color\n\t   * so that it is usable immediately unless `option.color === false`.\n\t   *\n\t   * If the width and height is not specified the width and height of the first\n\t   * image loaded will be used. Note that since images are loaded async\n\t   * which image downloads first is unknown.\n\t   *\n\t   * If an image is not the same size as the width and height it will be scaled\n\t   * to that width and height.\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.ThreeDReadyCallback} [callback] A function to be called when all the images have finished loading. err will\n\t   *    be non null if there was an error.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function loadSlicesFromUrls(gl, tex, options, callback) {\n\t    callback = callback || noop;\n\t    var urls = options.src;\n\t    var internalFormat = options.internalFormat || options.format || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var format = options.format || formatType.format;\n\t    var type = options.type || gl.UNSIGNED_BYTE;\n\t    var target = options.target || gl.TEXTURE_2D_ARRAY;\n\t    if (target !== gl.TEXTURE_3D && target !== gl.TEXTURE_2D_ARRAY) {\n\t      throw \"target must be TEXTURE_3D or TEXTURE_2D_ARRAY\";\n\t    }\n\t    setTextureTo1PixelColor(gl, tex, options);\n\t    // Because it's async we need to copy the options.\n\t    options = utils.shallowCopy(options);\n\t    var numToLoad = urls.length;\n\t    var errors = [];\n\t    var imgs;\n\t    var width = options.width;\n\t    var height = options.height;\n\t    var depth = urls.length;\n\t    var firstImage = true;\n\n\t    function uploadImg(slice) {\n\t      return function (err, img) {\n\t        --numToLoad;\n\t        if (err) {\n\t          errors.push(err);\n\t        } else {\n\t          savePackState(gl, options);\n\t          gl.bindTexture(target, tex);\n\n\t          if (firstImage) {\n\t            firstImage = false;\n\t            width = options.width || img.width;\n\t            height = options.height || img.height;\n\t            gl.texImage3D(target, 0, internalFormat, width, height, depth, 0, format, type, null);\n\n\t            // put it in every slice otherwise some slices will be 0,0,0,0\n\t            for (var s = 0; s < depth; ++s) {\n\t              gl.texSubImage3D(target, 0, 0, 0, s, width, height, 1, format, type, img);\n\t            }\n\t          } else {\n\t            var src = img;\n\t            if (img.width !== width || img.height !== height) {\n\t              // Size the image to fix\n\t              src = ctx.canvas;\n\t              ctx.canvas.width = width;\n\t              ctx.canvas.height = height;\n\t              ctx.drawImage(img, 0, 0, width, height);\n\t            }\n\n\t            gl.texSubImage3D(target, 0, 0, 0, slice, width, height, 1, format, type, src);\n\n\t            // free the canvas memory\n\t            if (src === ctx.canvas) {\n\t              ctx.canvas.width = 0;\n\t              ctx.canvas.height = 0;\n\t            }\n\t          }\n\n\t          restorePackState(gl, options);\n\t          gl.generateMipmap(target);\n\t        }\n\n\t        if (numToLoad === 0) {\n\t          callback(errors.length ? errors : undefined, imgs, tex);\n\t        }\n\t      };\n\t    }\n\n\t    imgs = urls.map(function (url, ndx) {\n\t      return loadImage(url, options.crossOrigin, uploadImg(ndx));\n\t    });\n\t  }\n\n\t  /**\n\t   * Sets a texture from an array or typed array. If the width or height is not provided will attempt to\n\t   * guess the size. See {@link module:twgl.TextureOptions}.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {(number[]|ArrayBuffer)} src An array or typed arry with texture data.\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureFromArray(gl, tex, src, options) {\n\t    options = options || defaults.textureOptions;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    var width = options.width;\n\t    var height = options.height;\n\t    var depth = options.depth;\n\t    var internalFormat = options.internalFormat || options.format || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var format = options.format || formatType.format;\n\t    var type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);\n\t    if (!isArrayBuffer(src)) {\n\t      var Type = typedArrays.getTypedArrayTypeForGLType(type);\n\t      src = new Type(src);\n\t    } else {\n\t      if (src instanceof Uint8ClampedArray) {\n\t        src = new Uint8Array(src.buffer);\n\t      }\n\t    }\n\t    var bytesPerElement = getBytesPerElementForInternalFormat(internalFormat, type);\n\t    var numElements = src.byteLength / bytesPerElement; // TODO: check UNPACK_ALIGNMENT?\n\t    if (numElements % 1) {\n\t      throw \"length wrong size for format: \" + glEnumToString(gl, format);\n\t    }\n\t    var dimensions;\n\t    if (target === gl.TEXTURE_3D) {\n\t      if (!width && !height && !depth) {\n\t        var size = Math.cbrt(numElements);\n\t        if (size % 1 !== 0) {\n\t          throw \"can't guess cube size of array of numElements: \" + numElements;\n\t        }\n\t        width = size;\n\t        height = size;\n\t        depth = size;\n\t      } else if (width && (!height || !depth)) {\n\t        dimensions = guessDimensions(gl, target, height, depth, numElements / width);\n\t        height = dimensions.width;\n\t        depth = dimensions.height;\n\t      } else if (height && (!width || !depth)) {\n\t        dimensions = guessDimensions(gl, target, width, depth, numElements / height);\n\t        width = dimensions.width;\n\t        depth = dimensions.height;\n\t      } else {\n\t        dimensions = guessDimensions(gl, target, width, height, numElements / depth);\n\t        width = dimensions.width;\n\t        height = dimensions.height;\n\t      }\n\t    } else {\n\t      dimensions = guessDimensions(gl, target, width, height, numElements);\n\t      width = dimensions.width;\n\t      height = dimensions.height;\n\t    }\n\t    gl.pixelStorei(gl.UNPACK_ALIGNMENT, options.unpackAlignment || 1);\n\t    savePackState(gl, options);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      (function () {\n\t        var elementsPerElement = bytesPerElement / src.BYTES_PER_ELEMENT;\n\t        var faceSize = numElements / 6 * elementsPerElement;\n\n\t        getCubeFacesWithNdx(gl, options).forEach(function (f) {\n\t          var offset = faceSize * f.ndx;\n\t          var data = src.subarray(offset, offset + faceSize);\n\t          gl.texImage2D(f.face, 0, internalFormat, width, height, 0, format, type, data);\n\t        });\n\t      })();\n\t    } else if (target === gl.TEXTURE_3D) {\n\t      gl.texImage3D(target, 0, internalFormat, width, height, depth, 0, format, type, src);\n\t    } else {\n\t      gl.texImage2D(target, 0, internalFormat, width, height, 0, format, type, src);\n\t    }\n\t    restorePackState(gl, options);\n\t    return {\n\t      width: width,\n\t      height: height,\n\t      depth: depth,\n\t      type: type\n\t    };\n\t  }\n\n\t  /**\n\t   * Sets a texture with no contents of a certain size. In other words calls `gl.texImage2D` with `null`.\n\t   * You must set `options.width` and `options.height`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setEmptyTexture(gl, tex, options) {\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    var internalFormat = options.internalFormat || options.format || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var format = options.format || formatType.format;\n\t    var type = options.type || formatType.type;\n\t    savePackState(gl, options);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      for (var ii = 0; ii < 6; ++ii) {\n\t        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, internalFormat, options.width, options.height, 0, format, type, null);\n\t      }\n\t    } else if (target === gl.TEXTURE_3D) {\n\t      gl.texImage3D(target, 0, internalFormat, options.width, options.height, options.depth, 0, format, type, null);\n\t    } else {\n\t      gl.texImage2D(target, 0, internalFormat, options.width, options.height, 0, format, type, null);\n\t    }\n\t    restorePackState(gl, options);\n\t  }\n\n\t  /**\n\t   * Creates a texture based on the options passed in.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.TextureReadyCallback} [callback] A callback called when an image has been downloaded and uploaded to the texture.\n\t   * @return {WebGLTexture} the created texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function createTexture(gl, options, callback) {\n\t    callback = callback || noop;\n\t    options = options || defaults.textureOptions;\n\t    var tex = gl.createTexture();\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    var width = options.width || 1;\n\t    var height = options.height || 1;\n\t    var internalFormat = options.internalFormat || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var type = options.type || formatType.type;\n\t    gl.bindTexture(target, tex);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      // this should have been the default for CUBEMAPS :(\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t    }\n\t    var src = options.src;\n\t    if (src) {\n\t      if (typeof src === \"function\") {\n\t        src = src(gl, options);\n\t      }\n\t      if (typeof src === \"string\") {\n\t        loadTextureFromUrl(gl, tex, options, callback);\n\t      } else if (isArrayBuffer(src) || Array.isArray(src) && (typeof src[0] === 'number' || Array.isArray(src[0]) || isArrayBuffer(src[0]))) {\n\t        var dimensions = setTextureFromArray(gl, tex, src, options);\n\t        width = dimensions.width;\n\t        height = dimensions.height;\n\t        type = dimensions.type;\n\t      } else if (Array.isArray(src) && typeof src[0] === 'string') {\n\t        if (target === gl.TEXTURE_CUBE_MAP) {\n\t          loadCubemapFromUrls(gl, tex, options, callback);\n\t        } else {\n\t          loadSlicesFromUrls(gl, tex, options, callback);\n\t        }\n\t      } else if (src instanceof HTMLElement) {\n\t        setTextureFromElement(gl, tex, src, options);\n\t        width = src.width;\n\t        height = src.height;\n\t      } else {\n\t        throw \"unsupported src type\";\n\t      }\n\t    } else {\n\t      setEmptyTexture(gl, tex, options);\n\t    }\n\t    if (options.auto !== false) {\n\t      setTextureFilteringForSize(gl, tex, options, width, height, internalFormat, type);\n\t    }\n\t    setTextureParameters(gl, tex, options);\n\t    return tex;\n\t  }\n\n\t  /**\n\t   * Resizes a texture based on the options passed in.\n\t   *\n\t   * Note: This is not a generic resize anything function.\n\t   * It's mostly used by {@link module:twgl.resizeFramebufferInfo}\n\t   * It will use `options.src` if it exists to try to determine a `type`\n\t   * otherwise it will assume `gl.UNSIGNED_BYTE`. No data is provided\n\t   * for the texture. Texture parameters will be set accordingly\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the texture to resize\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {number} [width] the new width. If not passed in will use `options.width`\n\t   * @param {number} [height] the new height. If not passed in will use `options.height`\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function resizeTexture(gl, tex, options, width, height) {\n\t    width = width || options.width;\n\t    height = height || options.height;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    var internalFormat = options.internalFormat || options.format || gl.RGBA;\n\t    var formatType = getFormatAndTypeForInternalFormat(internalFormat);\n\t    var format = options.format || formatType.format;\n\t    var type;\n\t    var src = options.src;\n\t    if (!src) {\n\t      type = options.type || formatType.type;\n\t    } else if (isArrayBuffer(src) || Array.isArray(src) && typeof src[0] === 'number') {\n\t      type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);\n\t    } else {\n\t      type = options.type || formatType.type;\n\t    }\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      for (var ii = 0; ii < 6; ++ii) {\n\t        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, format, width, height, 0, format, type, null);\n\t      }\n\t    } else {\n\t      gl.texImage2D(target, 0, format, width, height, 0, format, type, null);\n\t    }\n\t  }\n\n\t  /**\n\t   * Check if a src is an async request.\n\t   * if src is a string we're going to download an image\n\t   * if src is an array of strings we're going to download cubemap images\n\t   * @param {*} src The src from a TextureOptions\n\t   * @returns {bool} true if src is async.\n\t   */\n\t  function isAsyncSrc(src) {\n\t    return typeof src === 'string' || Array.isArray(src) && typeof src[0] === 'string';\n\t  }\n\n\t  /**\n\t   * Creates a bunch of textures based on the passed in options.\n\t   *\n\t   * Example:\n\t   *\n\t   *     var textures = twgl.createTextures(gl, {\n\t   *       // a power of 2 image\n\t   *       hftIcon: { src: \"images/hft-icon-16.png\", mag: gl.NEAREST },\n\t   *       // a non-power of 2 image\n\t   *       clover: { src: \"images/clover.jpg\" },\n\t   *       // From a canvas\n\t   *       fromCanvas: { src: ctx.canvas },\n\t   *       // A cubemap from 6 images\n\t   *       yokohama: {\n\t   *         target: gl.TEXTURE_CUBE_MAP,\n\t   *         src: [\n\t   *           'images/yokohama/posx.jpg',\n\t   *           'images/yokohama/negx.jpg',\n\t   *           'images/yokohama/posy.jpg',\n\t   *           'images/yokohama/negy.jpg',\n\t   *           'images/yokohama/posz.jpg',\n\t   *           'images/yokohama/negz.jpg',\n\t   *         ],\n\t   *       },\n\t   *       // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)\n\t   *       goldengate: {\n\t   *         target: gl.TEXTURE_CUBE_MAP,\n\t   *         src: 'images/goldengate.jpg',\n\t   *       },\n\t   *       // A 2x2 pixel texture from a JavaScript array\n\t   *       checker: {\n\t   *         mag: gl.NEAREST,\n\t   *         min: gl.LINEAR,\n\t   *         src: [\n\t   *           255,255,255,255,\n\t   *           192,192,192,255,\n\t   *           192,192,192,255,\n\t   *           255,255,255,255,\n\t   *         ],\n\t   *       },\n\t   *       // a 1x2 pixel texture from a typed array.\n\t   *       stripe: {\n\t   *         mag: gl.NEAREST,\n\t   *         min: gl.LINEAR,\n\t   *         format: gl.LUMINANCE,\n\t   *         src: new Uint8Array([\n\t   *           255,\n\t   *           128,\n\t   *           255,\n\t   *           128,\n\t   *           255,\n\t   *           128,\n\t   *           255,\n\t   *           128,\n\t   *         ]),\n\t   *         width: 1,\n\t   *       },\n\t   *     });\n\t   *\n\t   * Now\n\t   *\n\t   * *   `textures.hftIcon` will be a 2d texture\n\t   * *   `textures.clover` will be a 2d texture\n\t   * *   `textures.fromCanvas` will be a 2d texture\n\t   * *   `textures.yohohama` will be a cubemap texture\n\t   * *   `textures.goldengate` will be a cubemap texture\n\t   * *   `textures.checker` will be a 2d texture\n\t   * *   `textures.stripe` will be a 2d texture\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per texture.\n\t   * @param {module:twgl.TexturesReadyCallback} [callback] A callback called when all textures have been downloaded.\n\t   * @return {Object.<string,WebGLTexture>} the created textures by name\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function createTextures(gl, textureOptions, callback) {\n\t    callback = callback || noop;\n\t    var numDownloading = 0;\n\t    var errors = [];\n\t    var textures = {};\n\t    var images = {};\n\n\t    function callCallbackIfReady() {\n\t      if (numDownloading === 0) {\n\t        setTimeout(function () {\n\t          callback(errors.length ? errors : undefined, textures, images);\n\t        }, 0);\n\t      }\n\t    }\n\n\t    Object.keys(textureOptions).forEach(function (name) {\n\t      var options = textureOptions[name];\n\t      var onLoadFn;\n\t      if (isAsyncSrc(options.src)) {\n\t        onLoadFn = function onLoadFn(err, tex, img) {\n\t          images[name] = img;\n\t          --numDownloading;\n\t          if (err) {\n\t            errors.push(err);\n\t          }\n\t          callCallbackIfReady();\n\t        };\n\t        ++numDownloading;\n\t      }\n\t      textures[name] = createTexture(gl, options, onLoadFn);\n\t    });\n\n\t    // queue the callback if there are no images to download.\n\t    // We do this because if your code is structured to wait for\n\t    // images to download but then you comment out all the async\n\t    // images your code would break.\n\t    callCallbackIfReady();\n\n\t    return textures;\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"setDefaults_\": setDefaults,\n\n\t    \"createSampler\": createSampler,\n\t    \"createSamplers\": createSamplers,\n\t    \"setSamplerParameters\": setSamplerParameters,\n\n\t    \"createTexture\": createTexture,\n\t    \"setEmptyTexture\": setEmptyTexture,\n\t    \"setTextureFromArray\": setTextureFromArray,\n\t    \"loadTextureFromUrl\": loadTextureFromUrl,\n\t    \"setTextureFromElement\": setTextureFromElement,\n\t    \"setTextureFilteringForSize\": setTextureFilteringForSize,\n\t    \"setTextureParameters\": setTextureParameters,\n\t    \"setDefaultTextureColor\": setDefaultTextureColor,\n\t    \"createTextures\": createTextures,\n\t    \"resizeTexture\": resizeTexture,\n\t    \"getNumComponentsForFormat\": getNumComponentsForFormat,\n\t    \"getBytesPerElementForInternalFormat\": getBytesPerElementForInternalFormat\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (programs) {\n\t  \"use strict\";\n\n\t  /**\n\t   * vertex array object related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.attributes` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/vertexArrays\n\t   */\n\n\t  /**\n\t   * @typedef {Object} VertexArrayInfo\n\t   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n\t   * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..\n\t   * @property {WebGLVertexArrayObject} [vertexArrayObject] a vertex array object\n\t   * @memberOf module:twgl\n\t   */\n\n\t  /**\n\t   * Creates a VertexArrayInfo from a BufferInfo and one or more ProgramInfos\n\t   *\n\t   * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to\n\t   * {@link module:twgl:drawBufferInfo}.\n\t   *\n\t   * > **IMPORTANT:** Vertex Array Objects are **not** a direct analog for a BufferInfo. Vertex Array Objects\n\t   *   assign buffers to specific attributes at creation time. That means they can only be used with programs\n\t   *   who's attributes use the same attribute locations for the same purposes.\n\t   *\n\t   * > Bind your attribute locations by passing an array of attribute names to {@link module:twgl.createProgramInfo}\n\t   *   or use WebGL 2's GLSL ES 3's `layout(location = <num>)` to make sure locations match.\n\t   *\n\t   * also\n\t   *\n\t   * > **IMPORTANT:** After calling twgl.setBuffersAndAttribute with a BufferInfo that uses a Vertex Array Object\n\t   *   that Vertex Array Object will be bound. That means **ANY MANIPULATION OF ELEMENT_ARRAY_BUFFER or ATTRIBUTES**\n\t   *   will affect the Vertex Array Object state.\n\t   *\n\t   * > Call `gl.bindVertexArray(null)` to get back manipulating the global attributes and ELEMENT_ARRAY_BUFFER.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {module:twgl.ProgramInfo|module:twgl.ProgramInfo[]} programInfo a programInfo or array of programInfos\n\t   * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...\n\t   *\n\t   *    You need to make sure every attribute that will be used is bound. So for example assume shader 1\n\t   *    uses attributes A, B, C and shader 2 uses attributes A, B, D. If you only pass in the programInfo\n\t   *    for shader 1 then only attributes A, B, and C will have their attributes set because TWGL doesn't\n\t   *    now attribute D's location.\n\t   *\n\t   *    So, you can pass in both shader 1 and shader 2's programInfo\n\t   *\n\t   * @return {module:twgl.VertexArrayInfo} The created VertexArrayInfo\n\t   *\n\t   * @memberOf module:twgl/vertexArrays\n\t   */\n\n\t  function createVertexArrayInfo(gl, programInfos, bufferInfo) {\n\t    var vao = gl.createVertexArray();\n\t    gl.bindVertexArray(vao);\n\t    if (!programInfos.length) {\n\t      programInfos = [programInfos];\n\t    }\n\t    programInfos.forEach(function (programInfo) {\n\t      programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n\t    });\n\t    gl.bindVertexArray(null);\n\t    return {\n\t      numElements: bufferInfo.numElements,\n\t      elementType: bufferInfo.elementType,\n\t      vertexArrayObject: vao\n\t    };\n\t  }\n\n\t  /**\n\t   * Creates a vertex array object and then sets the attributes on it\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters\n\t   * @param {Object.<string, module:twgl.AttribInfo>} attribs AttribInfos mapped by attribute name.\n\t   * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices\n\t   * @memberOf module:twgl/vertexArrays\n\t   */\n\t  function createVAOAndSetAttributes(gl, setters, attribs, indices) {\n\t    var vao = gl.createVertexArray();\n\t    gl.bindVertexArray(vao);\n\t    programs.setAttributes(setters, attribs);\n\t    if (indices) {\n\t      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\t    }\n\t    // We unbind this because otherwise any change to ELEMENT_ARRAY_BUFFER\n\t    // like when creating buffers for other stuff will mess up this VAO's binding\n\t    gl.bindVertexArray(null);\n\t    return vao;\n\t  }\n\n\t  /**\n\t   * Creates a vertex array object and then sets the attributes\n\t   * on it\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {Object.<string, function>| module:twgl.ProgramInfo} programInfo as returned from createProgramInfo or Attribute setters as returned from createAttributeSetters\n\t   * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...\n\t   * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices\n\t   * @memberOf module:twgl/vertexArrays\n\t   */\n\t  function createVAOFromBufferInfo(gl, programInfo, bufferInfo) {\n\t    return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);\n\t  }\n\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"createVertexArrayInfo\": createVertexArrayInfo,\n\t    \"createVAOAndSetAttributes\": createVAOAndSetAttributes,\n\t    \"createVAOFromBufferInfo\": createVAOFromBufferInfo\n\t  };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }\n/******/ ])\n});\n;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/twgl.js/dist/3.x/twgl.js\n// module id = 1\n// module chunks = 0","//      \r\nimport { m4 } from '../node_modules/twgl.js/dist/3.x/twgl-full'\r\n\r\nexport default class Node {\r\n                       \r\n               \r\n                           \r\n                           \r\n                   \r\n\r\n  constructor (drawInfo         , parent       ) {\r\n    this.drawInfo = drawInfo\r\n    this.children = []\r\n    this.localMatrix = m4.identity()\r\n    this.worldMatrix = m4.identity()\r\n    if (parent) {\r\n      this.setParent(parent)\r\n    }\r\n  }\r\n\r\n  setParent (parent      )       {\r\n    // remove us from our parent\r\n    if (this.parent) {\r\n      const index = this.parent.children.indexOf(this)\r\n      if (index >= 0) {\r\n        this.parent.children.splice(index, 1)\r\n      }\r\n    }\r\n\r\n    // Add us to our new parent\r\n    parent.children.push(this)\r\n    this.parent = parent\r\n  }\r\n\r\n  updateWorldMatrix (parentWorldMatrix               )       {\r\n    if (parentWorldMatrix) {\r\n      // a matrix was passed in so do the math\r\n      m4.multiply(parentWorldMatrix, this.localMatrix, this.worldMatrix)\r\n    } else {\r\n      // no matrix was passed in so just copy local to world\r\n      m4.copy(this.localMatrix, this.worldMatrix)\r\n    }\r\n\r\n    // now process all the children\r\n    const worldMatrix = this.worldMatrix\r\n    this.children.forEach(function(child) {\r\n      child.updateWorldMatrix(worldMatrix)\r\n    })\r\n  }\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node.js\n// module id = 2\n// module chunks = 0","//      \r\n\r\n// Import third-party modules\r\nimport twgl from '../node_modules/twgl.js/dist/3.x/twgl'\r\nimport {m4} from '../node_modules/twgl.js/dist/3.x/twgl-full'\r\n\r\n// Loacel constants\r\nconst pixelRatio = window.devicePixelRatio\r\n\r\nexport default function render (\r\n  gl                       ,\r\n  objects               ,\r\n  currentTime        \r\n)       {\r\n  twgl.resizeCanvasToDisplaySize(gl.canvas, pixelRatio)\r\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)\r\n\r\n  gl.enable(gl.CULL_FACE)\r\n  gl.enable(gl.DEPTH_TEST)\r\n\r\n  gl.clearColor(1, 1, 1, 1)\r\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\r\n\r\n  // TODO set zNear to `hardcover Z position - hardcover width`,\r\n  // so the front cover while opening will be inside frustrum\r\n  const projectionMatrix = m4.perspective(45 * Math.PI / 180, gl.canvas.width / gl.canvas.height, 100, 501)\r\n\r\n  const objectsDrawInfo = objects.map(object => {\r\n    object.drawInfo.uniforms.u_matrix = m4.multiply(projectionMatrix, object.worldMatrix)\r\n    return object.drawInfo\r\n  })\r\n\r\n  twgl.drawObjectList(gl, objectsDrawInfo)\r\n\r\n  window.requestAnimationFrame(render.bind(null, gl, objects))\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./_render.js\n// module id = 3\n// module chunks = 0","//      \r\n\r\n// Import third-party modules\r\nimport twgl from '../node_modules/twgl.js/dist/3.x/twgl'\r\nimport {m4} from '../node_modules/twgl.js/dist/3.x/twgl-full'\r\n\r\n// Import local modules\r\nimport Node from './node'\r\n\r\n// Set local constants\r\nconst coverColor = [254 / 255, 116 / 255, 40 / 255, 1]\r\nconst grayColor = [30 / 255, 30 / 255, 30 / 255, 1]\r\n\r\nconst xLinePrimitive = new Float32Array([\r\n  -100, 100, -500,\r\n   100, 100, -500,\r\n])\r\n\r\nconst yLinePrimitive = new Float32Array([\r\n  -100, 100, -500,\r\n  -100, -100, -240, // 240 — is position 'at screen'\r\n])\r\n\r\nexport default class CoordinatesGrid {\r\n                           \r\n                     \r\n\r\n  constructor (gl                       , programInfo        ) {\r\n    this.gl = gl\r\n    this.programInfo = programInfo\r\n  }\r\n\r\n  prepareLines(gridSceneParent      )              {\r\n    const grid = new Node()\r\n    const lines = []\r\n\r\n    this.addLine(xLinePrimitive, coverColor, lines, grid, m4.identity())\r\n    this.addLine(yLinePrimitive, coverColor, lines, grid, m4.identity())\r\n\r\n    for (let i = 1; i < 11; i++) {\r\n      this.addLine(xLinePrimitive, grayColor, lines, grid, m4.translation([0, -i * 20, i * 26])) // xGridLine\r\n      this.addLine(yLinePrimitive, grayColor, lines, grid, m4.translation([i * 20, 0, 0])) // yGridLine\r\n    }\r\n\r\n    grid.setParent(gridSceneParent)\r\n    return lines\r\n  }\r\n\r\n  addLine (primitive              , color               , lines             , grid      , localMatrix              ) {\r\n    const line = new Node(this.prepareOptions(primitive, color))\r\n    line.localMatrix = localMatrix\r\n    line.setParent(grid)\r\n    lines.push(line)\r\n  }\r\n\r\n  prepareOptions (primitive              , color               ) {\r\n    return {\r\n      programInfo: this.programInfo,\r\n      type: this.gl.LINES,\r\n      uniforms: { u_color: color },\r\n      bufferInfo: twgl.createBufferInfoFromArrays(this.gl, { 'a_position': primitive })\r\n    }\r\n  }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./coordinatesGrid.js\n// module id = 4\n// module chunks = 0","//      \r\n\r\n// Import third-party modules\r\nimport twgl from '../node_modules/twgl.js/dist/3.x/twgl'\r\nimport {m4} from '../node_modules/twgl.js/dist/3.x/twgl-full'\r\n\r\n// Import local modules\r\nimport Node from './node'\r\n\r\n// Set local constants\r\nconst coverColor = [254 / 255, 116 / 255, 40 / 255, 1]\r\nconst flyleafColor = [63/255, 54/255, 58/255, 1]\r\nconst hardcoverHeight = 200\r\nconst hardcoverWidth = hardcoverHeight * 0.71 // from http://artgorbunov.ru/books/ui/demo/\r\nconst fromTop = 100 - hardcoverHeight * 0.1\r\n\r\nconst coverThickness = 0.5 // dummy number\r\n\r\n//  240 — is position 'at screen',\r\n// -249 — size from _almost_ pixel perfect comparison with http://artgorbunov.ru/books/ui/demo/\r\n// Maybe we need that 9 points shift away from camera to gain a space\r\n// for moving hardcover towards user\r\nconst fromCamera = -249\r\n\r\nconst halfWidth = hardcoverWidth / 2\r\nconst bottomY = fromTop - hardcoverHeight\r\nconst frontCoverBackZ = fromCamera - coverThickness\r\n\r\nconst frontCoverFacePosition = [\r\n -halfWidth, bottomY, fromCamera,\r\n  halfWidth, bottomY, fromCamera,\r\n -halfWidth, fromTop, fromCamera,\r\n\r\n  halfWidth, bottomY, fromCamera,\r\n  halfWidth, fromTop, fromCamera,\r\n -halfWidth, fromTop, fromCamera,\r\n]\r\n\r\n// Quick and dirty\r\nexport default function hardcoverNode(gl                       , programInfo        , hardcoverSceneParent      ) {\r\n  const hardcover = new Node({}, hardcoverSceneParent)\r\n  const frontCover = new Node({}, hardcover)\r\n  frontCover.localMatrix = rotationAroundRightSide(-60)\r\n  frontCover.setRotation = (degree) => { frontCover.localMatrix = rotationAroundRightSide(degree) }\r\n  const enchancedGetPlaneNode = getPlaneNode.bind(null, gl, programInfo)\r\n  return [\r\n    frontCoverFace(enchancedGetPlaneNode, frontCover),\r\n    frontCoverThicknessSide(enchancedGetPlaneNode, frontCover),\r\n    frontCoverInnerSide(enchancedGetPlaneNode, frontCover),\r\n    frontCoverFlyleaf(enchancedGetPlaneNode, hardcover)\r\n  ]\r\n}\r\n\r\nfunction frontCoverFace (getNode          , sceneParent      ) {\r\n  return getNode(coverColor, frontCoverFacePosition, sceneParent)\r\n}\r\n\r\nfunction frontCoverThicknessSide (getNode          , sceneParent      ) {\r\n  const color = [218 / 255, 102 / 255, 35 / 255, 1] // 85% of brightness in cover color\r\n  const position = [\r\n    halfWidth, bottomY, fromCamera,\r\n    halfWidth, bottomY, frontCoverBackZ,\r\n    halfWidth, fromTop, fromCamera,\r\n\r\n    halfWidth, fromTop, fromCamera,\r\n    halfWidth, bottomY, frontCoverBackZ,\r\n    halfWidth, fromTop, frontCoverBackZ,\r\n  ]\r\n  return getNode(color, position, sceneParent)\r\n}\r\n\r\nfunction frontCoverInnerSide (getNode          , sceneParent      ) {\r\n  const node = getNode(flyleafColor, frontCoverFacePosition, sceneParent)\r\n  // After rotation by 180° it will be opened as frontCover, so we need to position it back inside initial hardcover position\r\n  // and push it back by coverThickness to form some new face of cube\r\n  node.localMatrix = m4.translate(rotationAroundRightSide(180), [-hardcoverWidth, 0, -coverThickness])\r\n  return node\r\n}\r\n\r\nfunction frontCoverFlyleaf (getNode          , sceneParent      ) {\r\n  const node = getNode(flyleafColor, frontCoverFacePosition, sceneParent)\r\n  // For frontCoverFlyleaf() we should copy frontCover() and translate it by Z by (-coverThickness) and change color\r\n  node.localMatrix = m4.translation([0, 0, -coverThickness])\r\n  return node\r\n}\r\n\r\nfunction getPlaneNode (gl                       , programInfo        , color               , position               , parent       ) {\r\n  return new Node({\r\n    programInfo,\r\n    type: gl.TRIANGLES,\r\n    uniforms: { u_color: color },\r\n    bufferInfo: twgl.createBufferInfoFromArrays(gl, { 'a_position': position })\r\n  }, parent)\r\n}\r\n\r\n// Thanks http://stackoverflow.com/a/13284798/1363799\r\nfunction rotationAroundRightSide (angleInDegrees) {\r\n  const rotatePointX = halfWidth\r\n  const rotatePointY = 100 - fromTop\r\n  const rotatePointZ = fromCamera\r\n\r\n  let matrix = m4.identity()\r\n  matrix = m4.translate(matrix, [-rotatePointX, rotatePointY, rotatePointZ - coverThickness])\r\n  matrix = m4.rotateY(matrix, angleInDegrees * Math.PI / 180)\r\n  matrix = m4.translate(matrix, [rotatePointX, -rotatePointY, -rotatePointZ + coverThickness])\r\n  return matrix\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./hardcoverNode.js\n// module id = 5\n// module chunks = 0","/*\n * Copyright 2016, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n(function(root, factory) {  // eslint-disable-line\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function() {\n      return factory.call(root);\n    });\n  } else {\n    // Browser globals\n    root.webglLessonsUI = factory.call(root);\n  }\n}(this, function() {\n\n  function setupSlider(selector, options) {\n    var parent = document.querySelector(selector);\n    if (!parent) {\n      return; // like jquery don't fail on a bad selector\n    }\n    if (!options.name) {\n      options.name = selector.substring(1);\n    }\n    return createSlider(parent, options);\n  }\n\n  function createSlider(parent, options) {\n    var precision = options.precision || 0;\n    var min = options.min || 0;\n    var step = options.step || 1;\n    var value = options.value || 0;\n    var max = options.max || 1;\n    var fn = options.slide;\n    var name = options.name;\n    var uiPrecision = options.uiPrecision === undefined ? precision : options.uiPrecision;\n    var uiMult = options.uiMult || 1;\n\n    min /= step;\n    max /= step;\n    value /= step;\n\n    parent.innerHTML = `\n      <div class=\"gman-widget-outer\">\n        <div class=\"gman-widget-label\">${name}</div>\n        <div class=\"gman-widget-value\"></div>\n        <input class=\"gman-widget-slider\" type=\"range\" min=\"${min}\" max=\"${max}\" value=\"${value}\" />\n      </div>\n    `;\n    var valueElem = parent.querySelector(\".gman-widget-value\");\n    var sliderElem = parent.querySelector(\".gman-widget-slider\");\n\n    function updateValue(value) {\n      valueElem.textContent = (value * step * uiMult).toFixed(uiPrecision);\n    }\n\n    updateValue(value);\n\n    function handleChange(event) {\n      var value = parseInt(event.target.value);\n      updateValue(value);\n      fn(event, { value: value * step });\n    }\n\n    sliderElem.addEventListener('input', handleChange);\n    sliderElem.addEventListener('change', handleChange);\n\n    return {\n      elem: parent,\n      updateValue: (v) => {\n        v /= step;\n        sliderElem.value = v;\n        updateValue(v);\n      },\n    };\n  }\n\n  function makeSlider(options) {\n    const div = document.createElement(\"div\");\n    return createSlider(div, options);\n  }\n\n  var widgetId = 0;\n  function getWidgetId() {\n    return \"__widget_\" + widgetId++;\n  }\n\n  function makeCheckbox(options) {\n    const div = document.createElement(\"div\");\n    div.className = \"gman-widget-outer\";\n    const label = document.createElement(\"label\");\n    const id = getWidgetId();\n    label.setAttribute('for', id);\n    label.textContent = options.name;\n    label.className = \"gman-checkbox-label\";\n    const input = document.createElement(\"input\");\n    input.type = \"checkbox\";\n    input.checked = options.value;\n    input.id = id;\n    input.className = \"gman-widget-checkbox\";\n    div.appendChild(label);\n    div.appendChild(input);\n    input.addEventListener('change', function(e) {\n       options.change(e, {\n         value: e.target.checked,\n       });\n    });\n\n    return {\n      elem: div,\n      updateValue: function(v) {\n        input.checked = !!v;\n      },\n    };\n  }\n\n  function makeOption(options) {\n    const div = document.createElement(\"div\");\n    div.className = \"gman-widget-outer\";\n    const label = document.createElement(\"label\");\n    const id = getWidgetId();\n    label.setAttribute('for', id);\n    label.textContent = options.name;\n    label.className = \"gman-widget-label\";\n    const selectElem = document.createElement(\"select\");\n    options.options.forEach((name, ndx) => {\n      const opt = document.createElement(\"option\");\n      opt.textContent = name;\n      opt.value = ndx;\n      opt.selected = ndx === options.value\n      selectElem.appendChild(opt);\n    });\n    selectElem.className = \"gman-widget-select\";\n    div.appendChild(label);\n    div.appendChild(selectElem);\n    selectElem.addEventListener('change', function(e) {\n       options.change(e, {\n         value: selectElem.selectedIndex,\n       });\n    });\n\n    return {\n      elem: div,\n      updateValue: function(v) {\n        selectedElem.selectedIndex = v;\n      },\n    };\n  }\n\n  function noop() {\n  }\n\n  function genSlider(object, ui) {\n    const changeFn = ui.change || noop;\n    ui.name = ui.name || ui.key;\n    ui.value = object[ui.key];\n    ui.slide = ui.slide || function(event, uiInfo) {\n      object[ui.key] = uiInfo.value;\n      changeFn();\n    };\n    return makeSlider(ui);\n  }\n\n  function genCheckbox(object, ui) {\n    const changeFn = ui.change || noop;\n    ui.value = object[ui.key];\n    ui.name = ui.name || ui.key;\n    ui.change = function(event, uiInfo) {\n      object[ui.key] = uiInfo.value;\n      changeFn();\n    };\n    return makeCheckbox(ui);\n  }\n\n  function genOption(object, ui) {\n    const changeFn = ui.change || noop;\n    ui.value = object[ui.key];\n    ui.name = ui.name || ui.key;\n    ui.change = function(event, uiInfo) {\n      object[ui.key] = uiInfo.value;\n      changeFn();\n    };\n    return makeOption(ui);\n  }\n\n  const uiFuncs = {\n    slider: genSlider,\n    checkbox: genCheckbox,\n    option: genOption,\n  };\n\n  function setupUI(parent, object, uiInfos) {\n    const widgets = {};\n    uiInfos.forEach(function(ui) {\n      const widget = uiFuncs[ui.type](object, ui);\n      parent.appendChild(widget.elem);\n      widgets[ui.key] = widget;\n    });\n    return widgets;\n  }\n\n  function updateUI(widgets, data) {\n    Object.keys(widgets).forEach(key => {\n      const widget = widgets[key];\n      widget.updateValue(data[key]);\n    });\n  }\n\n  return {\n    setupUI: setupUI,\n    updateUI: updateUI,\n    setupSlider: setupSlider,\n    makeSlider: makeSlider,\n    makeCheckbox: makeCheckbox,\n  };\n\n}));\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/webgl-fundamentals/webgl/resources/webgl-lessons-ui.js\n// module id = 6\n// module chunks = 0","module.exports = \"precision mediump float;\\r\\n\\r\\nuniform vec4 u_color;\\r\\n\\r\\nvoid main() {\\r\\n   gl_FragColor = u_color;\\r\\n}\\r\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./shaderFragment.glsl\n// module id = 7\n// module chunks = 0","module.exports = \"attribute vec4 a_position;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n  gl_Position = u_matrix * a_position;\\r\\n}\\r\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./shaderVertex.glsl\n// module id = 8\n// module chunks = 0","//      \r\n\r\n// $FlowFixMe\r\nimport shaderVertex from './shaderVertex.glsl'\r\n// $FlowFixMe\r\nimport shaderFragment from './shaderFragment.glsl'\r\n\r\n// Import third-party modules\r\nimport twgl from '../node_modules/twgl.js/dist/3.x/twgl'\r\nimport {m4} from '../node_modules/twgl.js/dist/3.x/twgl-full'\r\nimport webglUI from '../node_modules/webgl-fundamentals/webgl/resources/webgl-lessons-ui'\r\n\r\n// Import local modules\r\nimport Node from './node'\r\nimport CoordinatesGrid from './coordinatesGrid'\r\nimport hardcoverNode from './hardcoverNode'\r\nimport render from './_render'\r\n\r\nconst coverColor = [254 / 255, 116 / 255, 40 / 255, 1]\r\n\r\nconst gl                        = twgl.getContext(document.getElementById('canvas'))\r\n\r\nconst attributes = ['a_position']\r\nconst programInfo = twgl.createProgramInfo(gl, [shaderVertex, shaderFragment], attributes)\r\n\r\n// BookShelf -- world object\r\nconst bookShelf = new Node()\r\nconst grid = new CoordinatesGrid(gl, programInfo)\r\n\r\nconst objects = [].concat(\r\n  grid.prepareLines(bookShelf),\r\n  hardcoverNode(gl, programInfo, bookShelf)\r\n)\r\n\r\nwebglUI.setupSlider('#FrontCoverOpenDegree', {\r\n  value: 60, // from hardcoverNode: frontCover.localMatrix = rotationAroundRightSide(-60)\r\n  max: 180,\r\n  slide: (event, {value}) => {\r\n    // TODO Refactor this dirty hack of integrating slider\r\n    bookShelf.children[1].children[0].setRotation(-value)\r\n    bookShelf.updateWorldMatrix()\r\n  }\r\n})\r\n\r\nbookShelf.updateWorldMatrix()\r\nconst enhancedRender = render.bind(null, gl, objects)\r\n\r\nwindow.requestAnimationFrame(enhancedRender)\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./_entry.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}